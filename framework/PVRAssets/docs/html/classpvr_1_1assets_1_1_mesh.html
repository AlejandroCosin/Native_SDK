<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PVRAssets: pvr::assets::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="80%" height="80%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRAssets</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1assets.html">assets</a></li><li class="navelem"><a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1assets_1_1_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::assets::Mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a> class. Represent a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh's is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.  
 <a href="classpvr_1_1assets_1_1_mesh.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html" title="The FaceData class contains the information of the Indices that defines the Faces of a Mesh.">FaceData</a> class contains the information of the Indices that defines the Faces of a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>.  <a href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html">InternalData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw internal structure of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>.  <a href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html">MeshInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains mesh information.  <a href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a single VertexAttribute.  <a href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4722749d8d5bfa2c811074f83a109169"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpvr_1_1_indexed_array.html">IndexedArray</a>&lt; <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>, StringHash &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a></td></tr>
<tr class="memdesc:a4722749d8d5bfa2c811074f83a109169"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container is automatically kept sorted.  <a href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">More...</a><br /></td></tr>
<tr class="separator:a4722749d8d5bfa2c811074f83a109169"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad86f903670f1604c60460197a75bb9ef"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ad86f903670f1604c60460197a75bb9ef">addData</a> (const uint8_t *data, uint32_t size, uint32_t stride)</td></tr>
<tr class="memdesc:ad86f903670f1604c60460197a75bb9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicitly append a block of vertex data to the mesh and (optionally) populate it with data.  <a href="classpvr_1_1assets_1_1_mesh.html#ad86f903670f1604c60460197a75bb9ef">More...</a><br /></td></tr>
<tr class="separator:ad86f903670f1604c60460197a75bb9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a29004239651b6c879a912bd347c2f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a70a29004239651b6c879a912bd347c2f">addData</a> (const uint8_t *data, uint32_t size, uint32_t stride, uint32_t index)</td></tr>
<tr class="memdesc:a70a29004239651b6c879a912bd347c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a block of vertex data to the mesh at the specified index and (optionally) populate it with data.  <a href="classpvr_1_1assets_1_1_mesh.html#a70a29004239651b6c879a912bd347c2f">More...</a><br /></td></tr>
<tr class="separator:a70a29004239651b6c879a912bd347c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba19b4f7de6dc15ef164950b7f9b893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aeba19b4f7de6dc15ef164950b7f9b893">addFaces</a> (const uint8_t *data, uint32_t size, const IndexType indexType)</td></tr>
<tr class="memdesc:aeba19b4f7de6dc15ef164950b7f9b893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add face information to the mesh.  <a href="classpvr_1_1assets_1_1_mesh.html#aeba19b4f7de6dc15ef164950b7f9b893">More...</a><br /></td></tr>
<tr class="separator:aeba19b4f7de6dc15ef164950b7f9b893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dd8fec1aacd0e21644e68b3da5eece"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a22dd8fec1aacd0e21644e68b3da5eece">addVertexAttribute</a> (const StringHash &amp;semanticName, const DataType &amp;type, uint32_t width, uint32_t offset, uint32_t dataIndex, bool forceReplace=false)</td></tr>
<tr class="memdesc:a22dd8fec1aacd0e21644e68b3da5eece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex attribute to the mesh.  <a href="classpvr_1_1assets_1_1_mesh.html#a22dd8fec1aacd0e21644e68b3da5eece">More...</a><br /></td></tr>
<tr class="separator:a22dd8fec1aacd0e21644e68b3da5eece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1c6afb7857d5a2a55ad1df8a94fac4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#abe1c6afb7857d5a2a55ad1df8a94fac4">addVertexAttribute</a> (const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> &amp;element, bool forceReplace=false)</td></tr>
<tr class="memdesc:abe1c6afb7857d5a2a55ad1df8a94fac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex attribute to the mesh.  <a href="classpvr_1_1assets_1_1_mesh.html#abe1c6afb7857d5a2a55ad1df8a94fac4">More...</a><br /></td></tr>
<tr class="separator:abe1c6afb7857d5a2a55ad1df8a94fac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320f2a19d317b96675e82d626482cfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae320f2a19d317b96675e82d626482cfc">clearAllData</a> ()</td></tr>
<tr class="memdesc:ae320f2a19d317b96675e82d626482cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all data blocks.  <a href="classpvr_1_1assets_1_1_mesh.html#ae320f2a19d317b96675e82d626482cfc">More...</a><br /></td></tr>
<tr class="separator:ae320f2a19d317b96675e82d626482cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add38ffc4f6966aa5a7d9ba73b6aa12bc"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#add38ffc4f6966aa5a7d9ba73b6aa12bc">getData</a> (uint32_t index)</td></tr>
<tr class="memdesc:add38ffc4f6966aa5a7d9ba73b6aa12bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data of a specified Data block. Read/write overload.  <a href="classpvr_1_1assets_1_1_mesh.html#add38ffc4f6966aa5a7d9ba73b6aa12bc">More...</a><br /></td></tr>
<tr class="separator:add38ffc4f6966aa5a7d9ba73b6aa12bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c5dd234334f09afe33f4f4c1dd6f1f"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a80c5dd234334f09afe33f4f4c1dd6f1f">getData</a> (uint32_t index) const</td></tr>
<tr class="memdesc:a80c5dd234334f09afe33f4f4c1dd6f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data of a specified Data block. Read only overload.  <a href="classpvr_1_1assets_1_1_mesh.html#a80c5dd234334f09afe33f4f4c1dd6f1f">More...</a><br /></td></tr>
<tr class="separator:a80c5dd234334f09afe33f4f4c1dd6f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b6bac172510bce138ff6110f6f0d6d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ab1b6bac172510bce138ff6110f6f0d6d">getDataSize</a> (uint32_t index) const</td></tr>
<tr class="memdesc:ab1b6bac172510bce138ff6110f6f0d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the specified Data block.  <a href="classpvr_1_1assets_1_1_mesh.html#ab1b6bac172510bce138ff6110f6f0d6d">More...</a><br /></td></tr>
<tr class="separator:ab1b6bac172510bce138ff6110f6f0d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25853ea014e345aaf8437f4f4e59ad26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a25853ea014e345aaf8437f4f4e59ad26">getFaces</a> ()</td></tr>
<tr class="memdesc:a25853ea014e345aaf8437f4f4e59ad26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all face data of this mesh.  <a href="classpvr_1_1assets_1_1_mesh.html#a25853ea014e345aaf8437f4f4e59ad26">More...</a><br /></td></tr>
<tr class="separator:a25853ea014e345aaf8437f4f4e59ad26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfd510fb21ed9833a5c047464959af9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a6cfd510fb21ed9833a5c047464959af9">getFaces</a> () const</td></tr>
<tr class="memdesc:a6cfd510fb21ed9833a5c047464959af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all face data of this mesh.  <a href="classpvr_1_1assets_1_1_mesh.html#a6cfd510fb21ed9833a5c047464959af9">More...</a><br /></td></tr>
<tr class="separator:a6cfd510fb21ed9833a5c047464959af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2c88d289cccdee673a91beaffd62df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html">InternalData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a9d2c88d289cccdee673a91beaffd62df">getInternalData</a> ()</td></tr>
<tr class="memdesc:a9d2c88d289cccdee673a91beaffd62df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the internal representation and data of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. Handle with care.  <a href="classpvr_1_1assets_1_1_mesh.html#a9d2c88d289cccdee673a91beaffd62df">More...</a><br /></td></tr>
<tr class="separator:a9d2c88d289cccdee673a91beaffd62df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542e53405460a419d30d375ef5b6786f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html">MeshInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a542e53405460a419d30d375ef5b6786f">getMeshInfo</a> ()</td></tr>
<tr class="memdesc:a542e53405460a419d30d375ef5b6786f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>.  <a href="classpvr_1_1assets_1_1_mesh.html#a542e53405460a419d30d375ef5b6786f">More...</a><br /></td></tr>
<tr class="separator:a542e53405460a419d30d375ef5b6786f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe8bc96416756a0a8a1c72abe2abfe8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html">MeshInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#acbe8bc96416756a0a8a1c72abe2abfe8">getMeshInfo</a> () const</td></tr>
<tr class="memdesc:acbe8bc96416756a0a8a1c72abe2abfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>.  <a href="classpvr_1_1assets_1_1_mesh.html#acbe8bc96416756a0a8a1c72abe2abfe8">More...</a><br /></td></tr>
<tr class="separator:acbe8bc96416756a0a8a1c72abe2abfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658595a7fbaabb8335387ebd2923b024"><td class="memItemLeft" align="right" valign="top">const FreeValue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a658595a7fbaabb8335387ebd2923b024">getMeshSemantic</a> (const StringHash &amp;semantic) const</td></tr>
<tr class="memdesc:a658595a7fbaabb8335387ebd2923b024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a Per-Mesh semantic as a FreeValue, null if it does not exist.  <a href="classpvr_1_1assets_1_1_mesh.html#a658595a7fbaabb8335387ebd2923b024">More...</a><br /></td></tr>
<tr class="separator:a658595a7fbaabb8335387ebd2923b024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae078fac970d3cded1a663b0fae57ac89"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae078fac970d3cded1a663b0fae57ac89">getNumBoneBatches</a> () const</td></tr>
<tr class="memdesc:ae078fac970d3cded1a663b0fae57ac89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of BoneBatches the bones of this mesh are organised into.  <a href="classpvr_1_1assets_1_1_mesh.html#ae078fac970d3cded1a663b0fae57ac89">More...</a><br /></td></tr>
<tr class="separator:ae078fac970d3cded1a663b0fae57ac89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb12dcd4e3c1665c79a46f45d65f5de6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aeb12dcd4e3c1665c79a46f45d65f5de6">getNumBones</a> () const</td></tr>
<tr class="memdesc:aeb12dcd4e3c1665c79a46f45d65f5de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information of a VertexAttribute by its SemanticName.  <a href="classpvr_1_1assets_1_1_mesh.html#aeb12dcd4e3c1665c79a46f45d65f5de6">More...</a><br /></td></tr>
<tr class="separator:aeb12dcd4e3c1665c79a46f45d65f5de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b5ed1b3a6ab9c7eca98ef9a9b8a3ae"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae9b5ed1b3a6ab9c7eca98ef9a9b8a3ae">getNumDataElements</a> () const</td></tr>
<tr class="memdesc:ae9b5ed1b3a6ab9c7eca98ef9a9b8a3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertex data blocks that this mesh has.  <a href="classpvr_1_1assets_1_1_mesh.html#ae9b5ed1b3a6ab9c7eca98ef9a9b8a3ae">More...</a><br /></td></tr>
<tr class="separator:ae9b5ed1b3a6ab9c7eca98ef9a9b8a3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca175937ad1a7a4c04eabe8c02fa470b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aca175937ad1a7a4c04eabe8c02fa470b">getNumElements</a> () const</td></tr>
<tr class="memdesc:aca175937ad1a7a4c04eabe8c02fa470b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of different vertex attributes that this mesh has.  <a href="classpvr_1_1assets_1_1_mesh.html#aca175937ad1a7a4c04eabe8c02fa470b">More...</a><br /></td></tr>
<tr class="separator:aca175937ad1a7a4c04eabe8c02fa470b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbba15a663acb65338cf483d5558c690"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#acbba15a663acb65338cf483d5558c690">getNumFaces</a> () const</td></tr>
<tr class="memdesc:acbba15a663acb65338cf483d5558c690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces that comprise this mesh.  <a href="classpvr_1_1assets_1_1_mesh.html#acbba15a663acb65338cf483d5558c690">More...</a><br /></td></tr>
<tr class="separator:acbba15a663acb65338cf483d5558c690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada000783180c3373894c242b653e259"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aada000783180c3373894c242b653e259">getNumIndices</a> () const</td></tr>
<tr class="memdesc:aada000783180c3373894c242b653e259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of indices that comprise this mesh. Takes TriangleStrips into consideration.  <a href="classpvr_1_1assets_1_1_mesh.html#aada000783180c3373894c242b653e259">More...</a><br /></td></tr>
<tr class="separator:aada000783180c3373894c242b653e259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236a3ddb680b65f2fe63aa7d0362ea54"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a236a3ddb680b65f2fe63aa7d0362ea54">getNumStrips</a> () const</td></tr>
<tr class="memdesc:a236a3ddb680b65f2fe63aa7d0362ea54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Triangle Strips (if any) that comprise this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>.  <a href="classpvr_1_1assets_1_1_mesh.html#a236a3ddb680b65f2fe63aa7d0362ea54">More...</a><br /></td></tr>
<tr class="separator:a236a3ddb680b65f2fe63aa7d0362ea54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb435d8bfafe4caf7dbc4b6785e6d12"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a3fb435d8bfafe4caf7dbc4b6785e6d12">getNumVertices</a> () const</td></tr>
<tr class="memdesc:a3fb435d8bfafe4caf7dbc4b6785e6d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertices that comprise this mesh.  <a href="classpvr_1_1assets_1_1_mesh.html#a3fb435d8bfafe4caf7dbc4b6785e6d12">More...</a><br /></td></tr>
<tr class="separator:a3fb435d8bfafe4caf7dbc4b6785e6d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c969e7321869baa41380f9b7157632"><td class="memItemLeft" align="right" valign="top">PrimitiveTopology&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aa0c969e7321869baa41380f9b7157632">getPrimitiveType</a> () const</td></tr>
<tr class="memdesc:aa0c969e7321869baa41380f9b7157632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a> represent.  <a href="classpvr_1_1assets_1_1_mesh.html#aa0c969e7321869baa41380f9b7157632">More...</a><br /></td></tr>
<tr class="separator:aa0c969e7321869baa41380f9b7157632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af955b58e0c37aee49b416b5e6050b4f1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#af955b58e0c37aee49b416b5e6050b4f1">getSkeletonId</a> () const</td></tr>
<tr class="memdesc:af955b58e0c37aee49b416b5e6050b4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the skeleton identifier (const).  <a href="classpvr_1_1assets_1_1_mesh.html#af955b58e0c37aee49b416b5e6050b4f1">More...</a><br /></td></tr>
<tr class="separator:af955b58e0c37aee49b416b5e6050b4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfd32860fd316e88bf6cfc7ae8eb59d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4bfd32860fd316e88bf6cfc7ae8eb59d">getStride</a> (uint32_t index) const</td></tr>
<tr class="memdesc:a4bfd32860fd316e88bf6cfc7ae8eb59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get distance in bytes from vertex in an array to the next.  <a href="classpvr_1_1assets_1_1_mesh.html#a4bfd32860fd316e88bf6cfc7ae8eb59d">More...</a><br /></td></tr>
<tr class="separator:a4bfd32860fd316e88bf6cfc7ae8eb59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cb924f1c47c49dd390160898a98ab5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ac8cb924f1c47c49dd390160898a98ab5">getStripLength</a> (uint32_t strip) const</td></tr>
<tr class="memdesc:ac8cb924f1c47c49dd390160898a98ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the specified triangle strip.  <a href="classpvr_1_1assets_1_1_mesh.html#ac8cb924f1c47c49dd390160898a98ab5">More...</a><br /></td></tr>
<tr class="separator:ac8cb924f1c47c49dd390160898a98ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8a415cc89f863f7d44b5bd741764d0"><td class="memItemLeft" align="right" valign="top">const uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a9e8a415cc89f863f7d44b5bd741764d0">getStripLengths</a> () const</td></tr>
<tr class="memdesc:a9e8a415cc89f863f7d44b5bd741764d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an array containing the Triangle Strip lengths.  <a href="classpvr_1_1assets_1_1_mesh.html#a9e8a415cc89f863f7d44b5bd741764d0">More...</a><br /></td></tr>
<tr class="separator:a9e8a415cc89f863f7d44b5bd741764d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28f87f9e2c099ed6b3dc744226a3346"><td class="memItemLeft" align="right" valign="top">const glm::mat4x4 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ad28f87f9e2c099ed6b3dc744226a3346">getUnpackMatrix</a> () const</td></tr>
<tr class="memdesc:ad28f87f9e2c099ed6b3dc744226a3346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression.  <a href="classpvr_1_1assets_1_1_mesh.html#ad28f87f9e2c099ed6b3dc744226a3346">More...</a><br /></td></tr>
<tr class="separator:ad28f87f9e2c099ed6b3dc744226a3346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cf008b3a2f8b09e5701796c8adcb5b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae1cf008b3a2f8b09e5701796c8adcb5b">getUserDataPtr</a> ()</td></tr>
<tr class="memdesc:ae1cf008b3a2f8b09e5701796c8adcb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the UserData of this mesh, if such user data exist.  <a href="classpvr_1_1assets_1_1_mesh.html#ae1cf008b3a2f8b09e5701796c8adcb5b">More...</a><br /></td></tr>
<tr class="separator:ae1cf008b3a2f8b09e5701796c8adcb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b64c4fa3599131a60f6052e31f2a7c4"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; void &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a7b64c4fa3599131a60f6052e31f2a7c4">getUserDataPtr</a> () const</td></tr>
<tr class="memdesc:a7b64c4fa3599131a60f6052e31f2a7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the UserData of this mesh, if such user data exist.  <a href="classpvr_1_1assets_1_1_mesh.html#a7b64c4fa3599131a60f6052e31f2a7c4">More...</a><br /></td></tr>
<tr class="separator:a7b64c4fa3599131a60f6052e31f2a7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f1c097545468fbac086f48a67ded92"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ad3f1c097545468fbac086f48a67ded92">getVertexAttribute</a> (int32_t idx) const</td></tr>
<tr class="memdesc:ad3f1c097545468fbac086f48a67ded92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information of a VertexAttribute by its SemanticName.  <a href="classpvr_1_1assets_1_1_mesh.html#ad3f1c097545468fbac086f48a67ded92">More...</a><br /></td></tr>
<tr class="separator:ad3f1c097545468fbac086f48a67ded92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28398285026edc8f62c96a8c73afaf48"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a28398285026edc8f62c96a8c73afaf48">getVertexAttributeByName</a> (const StringHash &amp;semanticName) const</td></tr>
<tr class="memdesc:a28398285026edc8f62c96a8c73afaf48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information of a VertexAttribute by its SemanticName (return NULL if not exist)  <a href="classpvr_1_1assets_1_1_mesh.html#a28398285026edc8f62c96a8c73afaf48">More...</a><br /></td></tr>
<tr class="separator:a28398285026edc8f62c96a8c73afaf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034f04c34f1aebbcb9eac337a40d30ba"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a034f04c34f1aebbcb9eac337a40d30ba">getVertexAttributeIndex</a> (const char *semanticName) const</td></tr>
<tr class="memdesc:a034f04c34f1aebbcb9eac337a40d30ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Index of a VertexAttribute by its SemanticName.  <a href="classpvr_1_1assets_1_1_mesh.html#a034f04c34f1aebbcb9eac337a40d30ba">More...</a><br /></td></tr>
<tr class="separator:a034f04c34f1aebbcb9eac337a40d30ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40407ad5da4c5bf49064b979f3efe7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a40407ad5da4c5bf49064b979f3efe7d9">getVertexAttributes</a> ()</td></tr>
<tr class="memdesc:a40407ad5da4c5bf49064b979f3efe7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the vertex attributes.  <a href="classpvr_1_1assets_1_1_mesh.html#a40407ad5da4c5bf49064b979f3efe7d9">More...</a><br /></td></tr>
<tr class="separator:a40407ad5da4c5bf49064b979f3efe7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7905baa0e098d7d6708e56e2157217e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae7905baa0e098d7d6708e56e2157217e">getVertexAttributes</a> () const</td></tr>
<tr class="memdesc:ae7905baa0e098d7d6708e56e2157217e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the vertex attributes.  <a href="classpvr_1_1assets_1_1_mesh.html#ae7905baa0e098d7d6708e56e2157217e">More...</a><br /></td></tr>
<tr class="separator:ae7905baa0e098d7d6708e56e2157217e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2694a121dd1b9e93d8d274eb15feaf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a3a2694a121dd1b9e93d8d274eb15feaf">getVertexAttributesSize</a> () const</td></tr>
<tr class="memdesc:a3a2694a121dd1b9e93d8d274eb15feaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of vertex attributes.  <a href="classpvr_1_1assets_1_1_mesh.html#a3a2694a121dd1b9e93d8d274eb15feaf">More...</a><br /></td></tr>
<tr class="separator:a3a2694a121dd1b9e93d8d274eb15feaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab8a05538e8e43df507561f622e27ff"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; StridedBuffer &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a1ab8a05538e8e43df507561f622e27ff">getVertexData</a> () const</td></tr>
<tr class="memdesc:a1ab8a05538e8e43df507561f622e27ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all DataBlocks of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>.  <a href="classpvr_1_1assets_1_1_mesh.html#a1ab8a05538e8e43df507561f622e27ff">More...</a><br /></td></tr>
<tr class="separator:a1ab8a05538e8e43df507561f622e27ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f197e403110d17f40e25ea88de40c71"><td class="memItemLeft" align="right" valign="top">const StridedBuffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a2f197e403110d17f40e25ea88de40c71">getVertexData</a> (uint32_t n) const</td></tr>
<tr class="memdesc:a2f197e403110d17f40e25ea88de40c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all DataBlocks of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>.  <a href="classpvr_1_1assets_1_1_mesh.html#a2f197e403110d17f40e25ea88de40c71">More...</a><br /></td></tr>
<tr class="separator:a2f197e403110d17f40e25ea88de40c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2ba13eaed9b97ac1975af18dcfd421"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a1e2ba13eaed9b97ac1975af18dcfd421">removeAllVertexAttributes</a> ()</td></tr>
<tr class="memdesc:a1e2ba13eaed9b97ac1975af18dcfd421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all vertex attribute to the mesh.  <a href="classpvr_1_1assets_1_1_mesh.html#a1e2ba13eaed9b97ac1975af18dcfd421">More...</a><br /></td></tr>
<tr class="separator:a1e2ba13eaed9b97ac1975af18dcfd421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2f385432d65c533b61618aa0b01bb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#adf2f385432d65c533b61618aa0b01bb5">removeData</a> (uint32_t index)</td></tr>
<tr class="memdesc:adf2f385432d65c533b61618aa0b01bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a block of data.  <a href="classpvr_1_1assets_1_1_mesh.html#adf2f385432d65c533b61618aa0b01bb5">More...</a><br /></td></tr>
<tr class="separator:adf2f385432d65c533b61618aa0b01bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede8af714093e8affa635c468a791730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aede8af714093e8affa635c468a791730">removeVertexAttribute</a> (const StringHash &amp;semanticName)</td></tr>
<tr class="memdesc:aede8af714093e8affa635c468a791730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a vertex attribute to the mesh.  <a href="classpvr_1_1assets_1_1_mesh.html#aede8af714093e8affa635c468a791730">More...</a><br /></td></tr>
<tr class="separator:aede8af714093e8affa635c468a791730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd580700ba77baa5451ab23cad67f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a1dd580700ba77baa5451ab23cad67f7d">setNumFaces</a> (uint32_t numFaces)</td></tr>
<tr class="memdesc:a1dd580700ba77baa5451ab23cad67f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the total number of faces. Will not change the actual Face Data.  <a href="classpvr_1_1assets_1_1_mesh.html#a1dd580700ba77baa5451ab23cad67f7d">More...</a><br /></td></tr>
<tr class="separator:a1dd580700ba77baa5451ab23cad67f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f35f211c34039ffee592af24b7d1c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ad6f35f211c34039ffee592af24b7d1c7">setNumVertices</a> (uint32_t numVertices)</td></tr>
<tr class="memdesc:ad6f35f211c34039ffee592af24b7d1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the total number of vertices. Will not change the actual Vertex Data.  <a href="classpvr_1_1assets_1_1_mesh.html#ad6f35f211c34039ffee592af24b7d1c7">More...</a><br /></td></tr>
<tr class="separator:ad6f35f211c34039ffee592af24b7d1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511cf5eb1381ebb0b46c188dfc19b76d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a511cf5eb1381ebb0b46c188dfc19b76d">setPrimitiveType</a> (const PrimitiveTopology &amp;type)</td></tr>
<tr class="memdesc:a511cf5eb1381ebb0b46c188dfc19b76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a> represent.  <a href="classpvr_1_1assets_1_1_mesh.html#a511cf5eb1381ebb0b46c188dfc19b76d">More...</a><br /></td></tr>
<tr class="separator:a511cf5eb1381ebb0b46c188dfc19b76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3ae0aff3ae49e0bb969b076415bc3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#adc3ae0aff3ae49e0bb969b076415bc3a">setStride</a> (uint32_t index, uint32_t stride)</td></tr>
<tr class="memdesc:adc3ae0aff3ae49e0bb969b076415bc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stride of a Data block.  <a href="classpvr_1_1assets_1_1_mesh.html#adc3ae0aff3ae49e0bb969b076415bc3a">More...</a><br /></td></tr>
<tr class="separator:adc3ae0aff3ae49e0bb969b076415bc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3b53368879dea40e0afe52cd207258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a2a3b53368879dea40e0afe52cd207258">setStripData</a> (uint32_t numStrips, const uint32_t *lengths)</td></tr>
<tr class="memdesc:a2a3b53368879dea40e0afe52cd207258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TriangleStrip number and lengths.  <a href="classpvr_1_1assets_1_1_mesh.html#a2a3b53368879dea40e0afe52cd207258">More...</a><br /></td></tr>
<tr class="separator:a2a3b53368879dea40e0afe52cd207258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6511bf2b294ecaf38ebf6f6668b9a4e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a6511bf2b294ecaf38ebf6f6668b9a4e4">setUnpackMatrix</a> (const glm::mat4x4 &amp;unpackMatrix)</td></tr>
<tr class="memdesc:a6511bf2b294ecaf38ebf6f6668b9a4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression.  <a href="classpvr_1_1assets_1_1_mesh.html#a6511bf2b294ecaf38ebf6f6668b9a4e4">More...</a><br /></td></tr>
<tr class="separator:a6511bf2b294ecaf38ebf6f6668b9a4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3618393c88d60e2c21643c2e472f4c01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a3618393c88d60e2c21643c2e472f4c01">setUserDataPtr</a> (const std::shared_ptr&lt; void &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a3618393c88d60e2c21643c2e472f4c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the UserData of this mesh (wrap the data into a std::shared_ptr and cast to Ref Counted void pointer.  <a href="classpvr_1_1assets_1_1_mesh.html#a3618393c88d60e2c21643c2e472f4c01">More...</a><br /></td></tr>
<tr class="separator:a3618393c88d60e2c21643c2e472f4c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96a1c1ff722b758f6c8940b61289d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae96a1c1ff722b758f6c8940b61289d4b">setVertexAttributeIndex</a> (const char *attributeName, size_t userIndex)</td></tr>
<tr class="memdesc:ae96a1c1ff722b758f6c8940b61289d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate the specified Attribute in a specific position in the vertex attribute array. Can be used to sort the vertex attributes according to a specific order.  <a href="classpvr_1_1assets_1_1_mesh.html#ae96a1c1ff722b758f6c8940b61289d4b">More...</a><br /></td></tr>
<tr class="separator:ae96a1c1ff722b758f6c8940b61289d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a> class. Represent a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh's is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4722749d8d5bfa2c811074f83a109169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4722749d8d5bfa2c811074f83a109169">&#9670;&nbsp;</a></span>VertexAttributeContainer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpvr_1_1_indexed_array.html">IndexedArray</a>&lt;<a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>, StringHash&gt; <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">pvr::assets::Mesh::VertexAttributeContainer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This container is automatically kept sorted. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad86f903670f1604c60460197a75bb9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86f903670f1604c60460197a75bb9ef">&#9670;&nbsp;</a></span>addData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::assets::Mesh::addData </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implicitly append a block of vertex data to the mesh and (optionally) populate it with data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to data that will be copied to the new block. If <em>data</em> is NULL, the block remains uninitialized.</td></tr>
    <tr><td class="paramname">size</td><td>The ordinal of the data block. If no block exists, it will be created along with all the ones before it, as</td></tr>
    <tr><td class="paramname">stride</td><td>The stride that the block index will be set to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">The index of the block that was just created.</p>
<p class="enddd">The index of the block that was just created.</p>
</dd></dl>
<p>With this call, a new data block will be appended to the end of the mesh, and will be populated with (size) bytes of data copied from the (data) pointer. (stride) will be saved as metadata with the data of the block and will be queriable with the (getStride) call with the same index as the data.</p>

</div>
</div>
<a id="a70a29004239651b6c879a912bd347c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a29004239651b6c879a912bd347c2f">&#9670;&nbsp;</a></span>addData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::assets::Mesh::addData </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a block of vertex data to the mesh at the specified index and (optionally) populate it with data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to data that will be copied to the new block. If <em>data</em> is NULL, the block remains uninitialized.</td></tr>
    <tr><td class="paramname">size</td><td>The ordinal of the data block. If no block exists, it will be created along with all the ones before it, as</td></tr>
    <tr><td class="paramname">stride</td><td>The stride that the block index will be set to.</td></tr>
    <tr><td class="paramname">index</td><td>The index where this block will be created on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the block that was just created.</dd></dl>
<p>With this call, a new data block will be added to the specified index of the mesh, and will be populated with (size) bytes of data copied from the (data) pointer. (stride) will be saved as metadata with the data of the block and will be queriable with the (getStride) call with the same index as the data.</p>

</div>
</div>
<a id="aeba19b4f7de6dc15ef164950b7f9b893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba19b4f7de6dc15ef164950b7f9b893">&#9670;&nbsp;</a></span>addFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::addFaces </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add face information to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the face data</td></tr>
    <tr><td class="paramname">size</td><td>The size, in bytes, of the face data</td></tr>
    <tr><td class="paramname">indexType</td><td>The actual datatype contained in (data). (16 or 32 bit)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22dd8fec1aacd0e21644e68b3da5eece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22dd8fec1aacd0e21644e68b3da5eece">&#9670;&nbsp;</a></span>addVertexAttribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::assets::Mesh::addVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semanticName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceReplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a vertex attribute to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semanticName</td><td>The semantic that the vertex attribute to add represents</td></tr>
    <tr><td class="paramname">type</td><td>The DataType of the Vertex Attribute</td></tr>
    <tr><td class="paramname">width</td><td>The number of (type) values per Vertex Attribute</td></tr>
    <tr><td class="paramname">offset</td><td>The Offset of this Vertex Attribute from the start of its DataBlock</td></tr>
    <tr><td class="paramname">dataIndex</td><td>The DataBlock this Vertex Attribute belongs to</td></tr>
    <tr><td class="paramname">forceReplace</td><td>force replace the attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index where the element was added (or where the already existing item was)</dd></dl>

</div>
</div>
<a id="abe1c6afb7857d5a2a55ad1df8a94fac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1c6afb7857d5a2a55ad1df8a94fac4">&#9670;&nbsp;</a></span>addVertexAttribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::assets::Mesh::addVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceReplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a vertex attribute to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The vertex attribute to add</td></tr>
    <tr><td class="paramname">forceReplace</td><td>If set to true, the element will be replaced if it already exists. Otherwise, the insertion will fail.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index where the element was added (or where the already existing item was)</dd></dl>

</div>
</div>
<a id="ae320f2a19d317b96675e82d626482cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae320f2a19d317b96675e82d626482cfc">&#9670;&nbsp;</a></span>clearAllData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::clearAllData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all data blocks. </p>

</div>
</div>
<a id="add38ffc4f6966aa5a7d9ba73b6aa12bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add38ffc4f6966aa5a7d9ba73b6aa12bc">&#9670;&nbsp;</a></span>getData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* pvr::assets::Mesh::getData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data of a specified Data block. Read/write overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the data block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified data block.</dd></dl>

</div>
</div>
<a id="a80c5dd234334f09afe33f4f4c1dd6f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c5dd234334f09afe33f4f4c1dd6f1f">&#9670;&nbsp;</a></span>getData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* pvr::assets::Mesh::getData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data of a specified Data block. Read only overload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the data block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the specified data block.</dd></dl>

</div>
</div>
<a id="ab1b6bac172510bce138ff6110f6f0d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b6bac172510bce138ff6110f6f0d6d">&#9670;&nbsp;</a></span>getDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t pvr::assets::Mesh::getDataSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the specified Data block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the data block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of the specified Data block.</dd></dl>

</div>
</div>
<a id="a25853ea014e345aaf8437f4f4e59ad26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25853ea014e345aaf8437f4f4e59ad26">&#9670;&nbsp;</a></span>getFaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a>&amp; pvr::assets::Mesh::getFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all face data of this mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the face data object of this mesh</dd></dl>

</div>
</div>
<a id="a6cfd510fb21ed9833a5c047464959af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfd510fb21ed9833a5c047464959af9">&#9670;&nbsp;</a></span>getFaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a>&amp; pvr::assets::Mesh::getFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all face data of this mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the face data object of this mesh</dd></dl>

</div>
</div>
<a id="a9d2c88d289cccdee673a91beaffd62df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2c88d289cccdee673a91beaffd62df">&#9670;&nbsp;</a></span>getInternalData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html">InternalData</a>&amp; pvr::assets::Mesh::getInternalData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the internal representation and data of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. Handle with care. </p>
<dl class="section return"><dt>Returns</dt><dd>The internal representation of this object.</dd></dl>

</div>
</div>
<a id="a542e53405460a419d30d375ef5b6786f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542e53405460a419d30d375ef5b6786f">&#9670;&nbsp;</a></span>getMeshInfo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html">MeshInfo</a>&amp; pvr::assets::Mesh::getMeshInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html" title="Contains mesh information.">Mesh::MeshInfo</a> object containing information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a></dd></dl>

</div>
</div>
<a id="acbe8bc96416756a0a8a1c72abe2abfe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe8bc96416756a0a8a1c72abe2abfe8">&#9670;&nbsp;</a></span>getMeshInfo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html">MeshInfo</a>&amp; pvr::assets::Mesh::getMeshInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html" title="Contains mesh information.">Mesh::MeshInfo</a> object containing information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a></dd></dl>

</div>
</div>
<a id="a658595a7fbaabb8335387ebd2923b024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658595a7fbaabb8335387ebd2923b024">&#9670;&nbsp;</a></span>getMeshSemantic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const FreeValue* pvr::assets::Mesh::getMeshSemantic </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semantic</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of a Per-Mesh semantic as a FreeValue, null if it does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semantic</td><td>The semantic name to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a FreeValue containing the value of the semantic. If the semantic does not exist, return NULL</dd></dl>

</div>
</div>
<a id="ae078fac970d3cded1a663b0fae57ac89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae078fac970d3cded1a663b0fae57ac89">&#9670;&nbsp;</a></span>getNumBoneBatches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumBoneBatches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of BoneBatches the bones of this mesh are organised into. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bone batches</dd></dl>

</div>
</div>
<a id="aeb12dcd4e3c1665c79a46f45d65f5de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb12dcd4e3c1665c79a46f45d65f5de6">&#9670;&nbsp;</a></span>getNumBones()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumBones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the information of a VertexAttribute by its SemanticName. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html" title="Definition of a single VertexAttribute.">VertexAttributeData</a> object with information on this attribute. (layout, index etc.) Null if failed</dd></dl>
<p>This method does lookup in O(logN) time. Prefer to call the getVertexAttributeID and then use the constant-time O(1) getVertexAttribute(int32_t) method</p>

</div>
</div>
<a id="ae9b5ed1b3a6ab9c7eca98ef9a9b8a3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b5ed1b3a6ab9c7eca98ef9a9b8a3ae">&#9670;&nbsp;</a></span>getNumDataElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumDataElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of vertex data blocks that this mesh has. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of data blocks</dd></dl>

</div>
</div>
<a id="aca175937ad1a7a4c04eabe8c02fa470b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca175937ad1a7a4c04eabe8c02fa470b">&#9670;&nbsp;</a></span>getNumElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of different vertex attributes that this mesh has. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertex attributes</dd></dl>

</div>
</div>
<a id="acbba15a663acb65338cf483d5558c690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbba15a663acb65338cf483d5558c690">&#9670;&nbsp;</a></span>getNumFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of faces that comprise this mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of faces</dd></dl>

</div>
</div>
<a id="aada000783180c3373894c242b653e259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada000783180c3373894c242b653e259">&#9670;&nbsp;</a></span>getNumIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of indices that comprise this mesh. Takes TriangleStrips into consideration. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of indexes</dd></dl>

</div>
</div>
<a id="a236a3ddb680b65f2fe63aa7d0362ea54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236a3ddb680b65f2fe63aa7d0362ea54">&#9670;&nbsp;</a></span>getNumStrips()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumStrips </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of Triangle Strips (if any) that comprise this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of Triangle Strips (if any) that comprise this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. 0 if the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a> is not made of strips</dd></dl>

</div>
</div>
<a id="a3fb435d8bfafe4caf7dbc4b6785e6d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb435d8bfafe4caf7dbc4b6785e6d12">&#9670;&nbsp;</a></span>getNumVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getNumVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of vertices that comprise this mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices</dd></dl>

</div>
</div>
<a id="aa0c969e7321869baa41380f9b7157632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c969e7321869baa41380f9b7157632">&#9670;&nbsp;</a></span>getPrimitiveType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PrimitiveTopology pvr::assets::Mesh::getPrimitiveType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a> represent. </p>
<dl class="section return"><dt>Returns</dt><dd>The primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a> represent (Triangles, TriangleStrips, TriangleFans, Patch etc.)</dd></dl>

</div>
</div>
<a id="af955b58e0c37aee49b416b5e6050b4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af955b58e0c37aee49b416b5e6050b4f1">&#9670;&nbsp;</a></span>getSkeletonId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::assets::Mesh::getSkeletonId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the skeleton identifier (const). </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structpvr_1_1assets_1_1_skeleton.html" title="The skeleton structure encapsulates all that which is required to define a skeleton including name,...">Skeleton</a> identifier</dd></dl>

</div>
</div>
<a id="a4bfd32860fd316e88bf6cfc7ae8eb59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfd32860fd316e88bf6cfc7ae8eb59d">&#9670;&nbsp;</a></span>getStride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getStride </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get distance in bytes from vertex in an array to the next. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the data block whose stride to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance in bytes from one array entry to the next.</dd></dl>

</div>
</div>
<a id="ac8cb924f1c47c49dd390160898a98ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cb924f1c47c49dd390160898a98ab5">&#9670;&nbsp;</a></span>getStripLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getStripLength </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>strip</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the specified triangle strip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strip</td><td>The index of the strip of which to return the length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the TriangleStrip with index (strip)</dd></dl>

</div>
</div>
<a id="a9e8a415cc89f863f7d44b5bd741764d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8a415cc89f863f7d44b5bd741764d0">&#9670;&nbsp;</a></span>getStripLengths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t* pvr::assets::Mesh::getStripLengths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an array containing the Triangle Strip lengths. </p>
<dl class="section return"><dt>Returns</dt><dd>An array of 32 bit values representing the Triangle Strip lengths. Use getNumStrips for the length of the array.</dd></dl>

</div>
</div>
<a id="ad28f87f9e2c099ed6b3dc744226a3346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28f87f9e2c099ed6b3dc744226a3346">&#9670;&nbsp;</a></span>getUnpackMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const glm::mat4x4&amp; pvr::assets::Mesh::getUnpackMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression. </p>
<dl class="section return"><dt>Returns</dt><dd>The unpack matrix</dd></dl>

</div>
</div>
<a id="ae1cf008b3a2f8b09e5701796c8adcb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1cf008b3a2f8b09e5701796c8adcb5b">&#9670;&nbsp;</a></span>getUserDataPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;void&gt; pvr::assets::Mesh::getUserDataPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the UserData of this mesh, if such user data exist. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the UserData, as a Reference Counted Void pointer. Cast to appropriate (ref counted)type</dd></dl>

</div>
</div>
<a id="a7b64c4fa3599131a60f6052e31f2a7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b64c4fa3599131a60f6052e31f2a7c4">&#9670;&nbsp;</a></span>getUserDataPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;void&gt;&amp; pvr::assets::Mesh::getUserDataPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the UserData of this mesh, if such user data exist. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the UserData, as a Reference Counted Void pointer. Cast to appropriate (ref counted)type</dd></dl>

</div>
</div>
<a id="ad3f1c097545468fbac086f48a67ded92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f1c097545468fbac086f48a67ded92">&#9670;&nbsp;</a></span>getVertexAttribute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>* pvr::assets::Mesh::getVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the information of a VertexAttribute by its SemanticName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>A semantic id with which to retrieve a vertex attribute. <dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html" title="Definition of a single VertexAttribute.">VertexAttributeData</a> object with information on this attribute. (layout, data index etc.) Null if failed</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>This method does lookup in constant O(1) time. Use the <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a034f04c34f1aebbcb9eac337a40d30ba" title="Get the Index of a VertexAttribute by its SemanticName.">getVertexAttributeIndex()</a> to get the index to use this method</p>

</div>
</div>
<a id="a28398285026edc8f62c96a8c73afaf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28398285026edc8f62c96a8c73afaf48">&#9670;&nbsp;</a></span>getVertexAttributeByName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>* pvr::assets::Mesh::getVertexAttributeByName </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semanticName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the information of a VertexAttribute by its SemanticName (return NULL if not exist) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semanticName</td><td>A semantic name with which to look for a vertex attribute. <dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html" title="Definition of a single VertexAttribute.">VertexAttributeData</a> object with information on this attribute. (layout, index etc.) Null if failed</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>This method does lookup in O(logN) time. Prefer to call the getVertexAttributeID and then use the constant-time O(1) getVertexAttribute(int32_t) method</p>

</div>
</div>
<a id="a034f04c34f1aebbcb9eac337a40d30ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034f04c34f1aebbcb9eac337a40d30ba">&#9670;&nbsp;</a></span>getVertexAttributeIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pvr::assets::Mesh::getVertexAttributeIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>semanticName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Index of a VertexAttribute by its SemanticName. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semanticName</td><td>A semantic name with which to look for a vertex attribute. <dl class="section return"><dt>Returns</dt><dd>The Index of the vertexAttribute.</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>Use this method to get the Index of a vertex attribute in O(logN) time and then be able to retrieve it by index with getVertexAttribute in constant time</p>

</div>
</div>
<a id="a40407ad5da4c5bf49064b979f3efe7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40407ad5da4c5bf49064b979f3efe7d9">&#9670;&nbsp;</a></span>getVertexAttributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a>&amp; pvr::assets::Mesh::getVertexAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the vertex attributes. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the actual container the Vertex Attributes are stored in.</dd></dl>

</div>
</div>
<a id="ae7905baa0e098d7d6708e56e2157217e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7905baa0e098d7d6708e56e2157217e">&#9670;&nbsp;</a></span>getVertexAttributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a>&amp; pvr::assets::Mesh::getVertexAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the vertex attributes. </p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the actual container the Vertex Attributes are stored in.</dd></dl>

</div>
</div>
<a id="a3a2694a121dd1b9e93d8d274eb15feaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2694a121dd1b9e93d8d274eb15feaf">&#9670;&nbsp;</a></span>getVertexAttributesSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::assets::Mesh::getVertexAttributesSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of vertex attributes. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertex attributes</dd></dl>

</div>
</div>
<a id="a1ab8a05538e8e43df507561f622e27ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab8a05538e8e43df507561f622e27ff">&#9670;&nbsp;</a></span>getVertexData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;StridedBuffer&gt;&amp; pvr::assets::Mesh::getVertexData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all DataBlocks of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The datablocks, as an std::vector of StridedBuffers that additionally have a stride member.</dd></dl>
<p>Use as char arrays and additionally use the <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4bfd32860fd316e88bf6cfc7ae8eb59d" title="Get distance in bytes from vertex in an array to the next.">getStride()</a> method to get the element stride</p>

</div>
</div>
<a id="a2f197e403110d17f40e25ea88de40c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f197e403110d17f40e25ea88de40c71">&#9670;&nbsp;</a></span>getVertexData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StridedBuffer&amp; pvr::assets::Mesh::getVertexData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all DataBlocks of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The datablocks, as an std::vector of StridedBuffers that additionally have a stride member.</dd></dl>
<p>Use as char arrays and additionally use the <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4bfd32860fd316e88bf6cfc7ae8eb59d" title="Get distance in bytes from vertex in an array to the next.">getStride()</a> method to get the element stride</p>

</div>
</div>
<a id="a1e2ba13eaed9b97ac1975af18dcfd421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2ba13eaed9b97ac1975af18dcfd421">&#9670;&nbsp;</a></span>removeAllVertexAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::removeAllVertexAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all vertex attribute to the mesh. </p>

</div>
</div>
<a id="adf2f385432d65c533b61618aa0b01bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2f385432d65c533b61618aa0b01bb5">&#9670;&nbsp;</a></span>removeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::removeData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a block of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the block to delete</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aede8af714093e8affa635c468a791730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede8af714093e8affa635c468a791730">&#9670;&nbsp;</a></span>removeVertexAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::removeVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semanticName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a vertex attribute to the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semanticName</td><td>The semantic that the vertex attribute to remove has</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dd580700ba77baa5451ab23cad67f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd580700ba77baa5451ab23cad67f7d">&#9670;&nbsp;</a></span>setNumFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setNumFaces </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numFaces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the total number of faces. Will not change the actual Face Data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numFaces</td><td>Set the number of faces</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6f35f211c34039ffee592af24b7d1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f35f211c34039ffee592af24b7d1c7">&#9670;&nbsp;</a></span>setNumVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setNumVertices </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numVertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the total number of vertices. Will not change the actual Vertex Data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numVertices</td><td>Set the number of vertices</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a511cf5eb1381ebb0b46c188dfc19b76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511cf5eb1381ebb0b46c188dfc19b76d">&#9670;&nbsp;</a></span>setPrimitiveType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setPrimitiveType </td>
          <td>(</td>
          <td class="paramtype">const PrimitiveTopology &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a> represent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a> will represent (Triangles, TriangleStrips, TriangleFans, Patch etc.)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc3ae0aff3ae49e0bb969b076415bc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3ae0aff3ae49e0bb969b076415bc3a">&#9670;&nbsp;</a></span>setStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setStride </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stride of a Data block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The ordinal of the data block (as it was defined by the addData call). If no block exists, it will be created along with all the ones before it, as blocks are always assumed to be continuous</td></tr>
    <tr><td class="paramname">stride</td><td>The stride that the block (index) will be set to.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a3b53368879dea40e0afe52cd207258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3b53368879dea40e0afe52cd207258">&#9670;&nbsp;</a></span>setStripData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setStripData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numStrips</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the TriangleStrip number and lengths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numStrips</td><td>The number of TriangleStrips</td></tr>
    <tr><td class="paramname">lengths</td><td>An array of size numStrips containing the length of each TriangleStrip, respectively</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6511bf2b294ecaf38ebf6f6668b9a4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6511bf2b294ecaf38ebf6f6668b9a4e4">&#9670;&nbsp;</a></span>setUnpackMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setUnpackMatrix </td>
          <td>(</td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>unpackMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily,...">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unpackMatrix</td><td>An unpack matrix</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3618393c88d60e2c21643c2e472f4c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3618393c88d60e2c21643c2e472f4c01">&#9670;&nbsp;</a></span>setUserDataPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setUserDataPtr </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the UserData of this mesh (wrap the data into a std::shared_ptr and cast to Ref Counted void pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The UserData. Must be wrapped in an appropriate std::shared_ptr, and then cast into a std::shared_ptr to void</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae96a1c1ff722b758f6c8940b61289d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96a1c1ff722b758f6c8940b61289d4b">&#9670;&nbsp;</a></span>setVertexAttributeIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setVertexAttributeIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attributeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>userIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locate the specified Attribute in a specific position in the vertex attribute array. Can be used to sort the vertex attributes according to a specific order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributeName</td><td>The name of an attribute</td></tr>
    <tr><td class="paramname">userIndex</td><td>The index to put this attribute to. If another attribute is there, indices will be swapped.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRAssets/model/<a class="el" href="_mesh_8h_source.html">Mesh.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="20%" height="20%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
