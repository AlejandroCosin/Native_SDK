<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PVRAssets: pvr::IndexedArray&lt; ValueType_, IndexType_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="80%" height="80%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRAssets</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="classpvr_1_1_indexed_array.html">IndexedArray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1_indexed_array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::IndexedArray&lt; ValueType_, IndexType_ &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A combination of array (std::vector) with associative container (std::map). Supports association of names with values, and retrieval by index.  
 <a href="classpvr_1_1_indexed_array.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An (constant) Linear iterator of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a> class. Will linearly iterate the backing store skipping empy spots. Unordered.  <a href="classpvr_1_1_indexed_array_1_1const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An (modifiable) Linear iterator of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a> class. Will linearly iterate the backing store skipping empy spots. Unordered.  <a href="classpvr_1_1_indexed_array_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afb0ccad7d43d3e6845cc40624a8ad076"><td class="memItemLeft" align="right" valign="top">typedef maptype_::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#afb0ccad7d43d3e6845cc40624a8ad076">const_index_iterator</a></td></tr>
<tr class="memdesc:afb0ccad7d43d3e6845cc40624a8ad076"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Indexed (Constant) iterator of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a> class. Will follow the indexing map of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a> iterating items in their Indexing order.  <a href="classpvr_1_1_indexed_array.html#afb0ccad7d43d3e6845cc40624a8ad076">More...</a><br /></td></tr>
<tr class="separator:afb0ccad7d43d3e6845cc40624a8ad076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782c77681cab6a206279fd79f3f27efe"><td class="memItemLeft" align="right" valign="top">typedef maptype_::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a782c77681cab6a206279fd79f3f27efe">index_iterator</a></td></tr>
<tr class="memdesc:a782c77681cab6a206279fd79f3f27efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Indexed iterator of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a> class. Will follow the indexing map of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a> iterating items in their Indexing order.  <a href="classpvr_1_1_indexed_array.html#a782c77681cab6a206279fd79f3f27efe">More...</a><br /></td></tr>
<tr class="separator:a782c77681cab6a206279fd79f3f27efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aef0bfb2ab12222311071c4dc052e64dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_indexed_array_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#aef0bfb2ab12222311071c4dc052e64dc">begin</a> ()</td></tr>
<tr class="memdesc:aef0bfb2ab12222311071c4dc052e64dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Linear iterator to the first non-deleted item in the backing store.  <a href="classpvr_1_1_indexed_array.html#aef0bfb2ab12222311071c4dc052e64dc">More...</a><br /></td></tr>
<tr class="separator:aef0bfb2ab12222311071c4dc052e64dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe42763be337e0b24402837f45e190c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_indexed_array_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a8fe42763be337e0b24402837f45e190c">begin</a> () const</td></tr>
<tr class="memdesc:a8fe42763be337e0b24402837f45e190c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Linear <a class="el" href="classpvr_1_1_indexed_array_1_1const__iterator.html" title="An (constant) Linear iterator of the IndexedArray class. Will linearly iterate the backing store skip...">const_iterator</a> to the first non-deleted item in the backing store.  <a href="classpvr_1_1_indexed_array.html#a8fe42763be337e0b24402837f45e190c">More...</a><br /></td></tr>
<tr class="separator:a8fe42763be337e0b24402837f45e190c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec5ba281a4a0607f8a88c89e00eaf20"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a9ec5ba281a4a0607f8a88c89e00eaf20">capacity</a> () const</td></tr>
<tr class="memdesc:a9ec5ba281a4a0607f8a88c89e00eaf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current capacity of the backing array of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>.  <a href="classpvr_1_1_indexed_array.html#a9ec5ba281a4a0607f8a88c89e00eaf20">More...</a><br /></td></tr>
<tr class="separator:a9ec5ba281a4a0607f8a88c89e00eaf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b86079a6fdbec384a6c948521a143f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#aa3b86079a6fdbec384a6c948521a143f">clear</a> ()</td></tr>
<tr class="memdesc:aa3b86079a6fdbec384a6c948521a143f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>.  <a href="classpvr_1_1_indexed_array.html#aa3b86079a6fdbec384a6c948521a143f">More...</a><br /></td></tr>
<tr class="separator:aa3b86079a6fdbec384a6c948521a143f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17498f4a82d16b4906b0468237fb4ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#af17498f4a82d16b4906b0468237fb4ba">compact</a> ()</td></tr>
<tr class="memdesc:af17498f4a82d16b4906b0468237fb4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts the backing array by removing existing items from the end of the vector and putting them in the place of deleted items, and then updating their index, until no more positions marked as deleted are left. Will ensure the contiguousness of the backing vector, but will invalidate previously gotten item indices.  <a href="classpvr_1_1_indexed_array.html#af17498f4a82d16b4906b0468237fb4ba">More...</a><br /></td></tr>
<tr class="separator:af17498f4a82d16b4906b0468237fb4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a85600a95919b0a980d2c015eefc63"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#ae8a85600a95919b0a980d2c015eefc63">deletedItemsCount</a> () const</td></tr>
<tr class="memdesc:ae8a85600a95919b0a980d2c015eefc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of deleted items.  <a href="classpvr_1_1_indexed_array.html#ae8a85600a95919b0a980d2c015eefc63">More...</a><br /></td></tr>
<tr class="separator:ae8a85600a95919b0a980d2c015eefc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed600c1b8483c9ff8397930745670e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_indexed_array_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a7ed600c1b8483c9ff8397930745670e9">end</a> ()</td></tr>
<tr class="memdesc:a7ed600c1b8483c9ff8397930745670e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing one item past the last item in the backing array.  <a href="classpvr_1_1_indexed_array.html#a7ed600c1b8483c9ff8397930745670e9">More...</a><br /></td></tr>
<tr class="separator:a7ed600c1b8483c9ff8397930745670e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968979700a2d3bea7401f714f0fe5a74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_indexed_array_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a968979700a2d3bea7401f714f0fe5a74">end</a> () const</td></tr>
<tr class="memdesc:a968979700a2d3bea7401f714f0fe5a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classpvr_1_1_indexed_array_1_1const__iterator.html" title="An (constant) Linear iterator of the IndexedArray class. Will linearly iterate the backing store skip...">const_iterator</a> pointing one item past the last item in the backing array.  <a href="classpvr_1_1_indexed_array.html#a968979700a2d3bea7401f714f0fe5a74">More...</a><br /></td></tr>
<tr class="separator:a968979700a2d3bea7401f714f0fe5a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67ed0d00a2496d00fdc39a14924764d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#aa67ed0d00a2496d00fdc39a14924764d">erase</a> (const IndexType_ &amp;key)</td></tr>
<tr class="memdesc:aa67ed0d00a2496d00fdc39a14924764d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the item with the specified key from the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>.  <a href="classpvr_1_1_indexed_array.html#aa67ed0d00a2496d00fdc39a14924764d">More...</a><br /></td></tr>
<tr class="separator:aa67ed0d00a2496d00fdc39a14924764d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b081c28171501d77650532d4349dcf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a56b081c28171501d77650532d4349dcf">getIndex</a> (const IndexType_ &amp;key) const</td></tr>
<tr class="memdesc:a56b081c28171501d77650532d4349dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a specific key in the backing array. Valid until a reshuffling of the array is done via insert, compact or similar operation.  <a href="classpvr_1_1_indexed_array.html#a56b081c28171501d77650532d4349dcf">More...</a><br /></td></tr>
<tr class="separator:a56b081c28171501d77650532d4349dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e5a920b354cff055ad8964b2edd3a8"><td class="memItemLeft" align="right" valign="top">maptype_::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a92e5a920b354cff055ad8964b2edd3a8">indexed_begin</a> ()</td></tr>
<tr class="memdesc:a92e5a920b354cff055ad8964b2edd3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an indexed_const_iterator to the first item in the map.  <a href="classpvr_1_1_indexed_array.html#a92e5a920b354cff055ad8964b2edd3a8">More...</a><br /></td></tr>
<tr class="separator:a92e5a920b354cff055ad8964b2edd3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14889278fbd62088276567bcd762de1a"><td class="memItemLeft" align="right" valign="top">maptype_::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a14889278fbd62088276567bcd762de1a">indexed_begin</a> () const</td></tr>
<tr class="memdesc:a14889278fbd62088276567bcd762de1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a indexed_const_iterator to the first item in the map.  <a href="classpvr_1_1_indexed_array.html#a14889278fbd62088276567bcd762de1a">More...</a><br /></td></tr>
<tr class="separator:a14889278fbd62088276567bcd762de1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082022aecf9605516a50ee9e643a49d7"><td class="memItemLeft" align="right" valign="top">maptype_::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a082022aecf9605516a50ee9e643a49d7">indexed_end</a> ()</td></tr>
<tr class="memdesc:a082022aecf9605516a50ee9e643a49d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an indexed_iterator pointing one item past the last item in the map.  <a href="classpvr_1_1_indexed_array.html#a082022aecf9605516a50ee9e643a49d7">More...</a><br /></td></tr>
<tr class="separator:a082022aecf9605516a50ee9e643a49d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ececf18821288a3312e6b7f2971260"><td class="memItemLeft" align="right" valign="top">maptype_::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#ae9ececf18821288a3312e6b7f2971260">indexed_end</a> () const</td></tr>
<tr class="memdesc:ae9ececf18821288a3312e6b7f2971260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an indexed_const_iterator pointing one item past the last item in the map.  <a href="classpvr_1_1_indexed_array.html#ae9ececf18821288a3312e6b7f2971260">More...</a><br /></td></tr>
<tr class="separator:ae9ececf18821288a3312e6b7f2971260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659f1981296374a659c21f5f4ebbf26c"><td class="memItemLeft" align="right" valign="top">maptype_::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a659f1981296374a659c21f5f4ebbf26c">indexed_find</a> (const IndexType_ &amp;key)</td></tr>
<tr class="memdesc:a659f1981296374a659c21f5f4ebbf26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an indexed iterator by finding the provided key Indexing map.  <a href="classpvr_1_1_indexed_array.html#a659f1981296374a659c21f5f4ebbf26c">More...</a><br /></td></tr>
<tr class="separator:a659f1981296374a659c21f5f4ebbf26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f8ef4ef8c58ab81aa5f20e2971cdad"><td class="memItemLeft" align="right" valign="top">maptype_::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#ac2f8ef4ef8c58ab81aa5f20e2971cdad">indexed_find</a> (const IndexType_ &amp;key) const</td></tr>
<tr class="memdesc:ac2f8ef4ef8c58ab81aa5f20e2971cdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const indexed iterator by finding the provided key Indexing map.  <a href="classpvr_1_1_indexed_array.html#ac2f8ef4ef8c58ab81aa5f20e2971cdad">More...</a><br /></td></tr>
<tr class="separator:ac2f8ef4ef8c58ab81aa5f20e2971cdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45c7465ac70d247b92b6f14b72019e7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#ad45c7465ac70d247b92b6f14b72019e7">insert</a> (const IndexType_ &amp;key, const ValueType_ &amp;val)</td></tr>
<tr class="memdesc:ad45c7465ac70d247b92b6f14b72019e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an item at the first possible spot in the backing array. If key exists, will update the value.  <a href="classpvr_1_1_indexed_array.html#ad45c7465ac70d247b92b6f14b72019e7">More...</a><br /></td></tr>
<tr class="separator:ad45c7465ac70d247b92b6f14b72019e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d837ac51c85ae08233d6bc9506566a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#ad9d837ac51c85ae08233d6bc9506566a">insertAt</a> (size_t where, const IndexType_ &amp;key, const ValueType_ &amp;val)</td></tr>
<tr class="memdesc:ad9d837ac51c85ae08233d6bc9506566a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an item at a specific point in the backing array.  <a href="classpvr_1_1_indexed_array.html#ad9d837ac51c85ae08233d6bc9506566a">More...</a><br /></td></tr>
<tr class="separator:ad9d837ac51c85ae08233d6bc9506566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dab1c6d92f30f2cf1aaeb26636e90ce"><td class="memItemLeft" align="right" valign="top">ValueType_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a8dab1c6d92f30f2cf1aaeb26636e90ce">operator[]</a> (const IndexType_ &amp;key)</td></tr>
<tr class="memdesc:a8dab1c6d92f30f2cf1aaeb26636e90ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed indexing operator. Uses std::map find to retrieve the specified value. If the key does not exist, it will be inserted.  <a href="classpvr_1_1_indexed_array.html#a8dab1c6d92f30f2cf1aaeb26636e90ce">More...</a><br /></td></tr>
<tr class="separator:a8dab1c6d92f30f2cf1aaeb26636e90ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198f1d024acc685429fb3bc2622846dd"><td class="memItemLeft" align="right" valign="top">const ValueType_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a198f1d024acc685429fb3bc2622846dd">operator[]</a> (const IndexType_ &amp;key) const</td></tr>
<tr class="memdesc:a198f1d024acc685429fb3bc2622846dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed indexing operator. Uses std::map find to retrieve the specified value. If the key does not exist, it will be inserted.  <a href="classpvr_1_1_indexed_array.html#a198f1d024acc685429fb3bc2622846dd">More...</a><br /></td></tr>
<tr class="separator:a198f1d024acc685429fb3bc2622846dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f92746bf6e8443fc770868132e45697"><td class="memItemLeft" align="right" valign="top">ValueType_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a1f92746bf6e8443fc770868132e45697">operator[]</a> (size_t idx)</td></tr>
<tr class="memdesc:a1f92746bf6e8443fc770868132e45697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array indexing operator. Constant time. Use getIndex to get the indices of specific items. If idx points to a deleted item or past the last item, the behaviour is undefined.  <a href="classpvr_1_1_indexed_array.html#a1f92746bf6e8443fc770868132e45697">More...</a><br /></td></tr>
<tr class="separator:a1f92746bf6e8443fc770868132e45697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add003e9e7e15d0459b1df3c4356d6be4"><td class="memItemLeft" align="right" valign="top">const ValueType_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#add003e9e7e15d0459b1df3c4356d6be4">operator[]</a> (size_t idx) const</td></tr>
<tr class="memdesc:add003e9e7e15d0459b1df3c4356d6be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const array indexing operator. Use getIndex to get the indices of specific items. If idx points to a deleted item or past the last item, the behaviour is undefined.  <a href="classpvr_1_1_indexed_array.html#add003e9e7e15d0459b1df3c4356d6be4">More...</a><br /></td></tr>
<tr class="separator:add003e9e7e15d0459b1df3c4356d6be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92da13fb7957ca214b6d3fec340a51da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#a92da13fb7957ca214b6d3fec340a51da">relocate</a> (const IndexType_ &amp;key, size_t index)</td></tr>
<tr class="memdesc:a92da13fb7957ca214b6d3fec340a51da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a specific item (identified by a key) to a specific index in the list. If an item is already in this spot in the list, their positions are swapped.  <a href="classpvr_1_1_indexed_array.html#a92da13fb7957ca214b6d3fec340a51da">More...</a><br /></td></tr>
<tr class="separator:a92da13fb7957ca214b6d3fec340a51da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7186f7b14ae8ee5eb79d465de2a2381"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#ae7186f7b14ae8ee5eb79d465de2a2381">size</a> () const</td></tr>
<tr class="memdesc:ae7186f7b14ae8ee5eb79d465de2a2381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of items in the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>.  <a href="classpvr_1_1_indexed_array.html#ae7186f7b14ae8ee5eb79d465de2a2381">More...</a><br /></td></tr>
<tr class="separator:ae7186f7b14ae8ee5eb79d465de2a2381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54308766b4791cfca46a04029de862b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_indexed_array.html#aa54308766b4791cfca46a04029de862b">sizeWithDeleted</a> () const</td></tr>
<tr class="memdesc:aa54308766b4791cfca46a04029de862b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of items in the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>, including items that have been deleted.  <a href="classpvr_1_1_indexed_array.html#aa54308766b4791cfca46a04029de862b">More...</a><br /></td></tr>
<tr class="separator:aa54308766b4791cfca46a04029de862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ValueType_, typename IndexType_ = std::string&gt;<br />
class pvr::IndexedArray&lt; ValueType_, IndexType_ &gt;</h3>

<p>A combination of array (std::vector) with associative container (std::map). Supports association of names with values, and retrieval by index. </p>
<p>An std::vector style array class with the additional feature of associating "names" (IndexType_, std::string by default) with the values stored. Keys are of type IndexType_, correspond to vector position 1:1, so that each vector position ("index") is associated with a "key", and only one key. Use: Add pairs of values with insert(key, value). Retrieve indices by key, using getIndex(key) &ndash; O(logn) Retrieve values by index, using indexing operator [] &ndash; O(1) The remove() function destroys the items on which it was called, but a default-constructed object will still exist. Performing <a class="el" href="classpvr_1_1_indexed_array.html#ad45c7465ac70d247b92b6f14b72019e7" title="Insert an item at the first possible spot in the backing array. If key exists, will update the value.">insert()</a> after removing an item will use the place of a previously deleted item, if it exists. CAUTION: If remove() has been called, the vector no longer guarantees contiguousness until <a class="el" href="classpvr_1_1_indexed_array.html#af17498f4a82d16b4906b0468237fb4ba" title="Compacts the backing array by removing existing items from the end of the vector and putting them in ...">compact()</a> is called. CAUTION: To manually reclaim all memory and guarantee contiguous allocation, call <a class="el" href="classpvr_1_1_indexed_array.html#af17498f4a82d16b4906b0468237fb4ba" title="Compacts the backing array by removing existing items from the end of the vector and putting them in ...">compact()</a>. Calling compact invalidates all indices, which must then be retrieved anew by "getInxdex". Calling getIndex on an unknown key returns (size_t)(-1) Accessing an unknown item by index is undefined. Accessing an index not retrieved by getIndex since the last <a class="el" href="classpvr_1_1_indexed_array.html#af17498f4a82d16b4906b0468237fb4ba" title="Compacts the backing array by removing existing items from the end of the vector and putting them in ...">compact()</a> operation is undefined.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afb0ccad7d43d3e6845cc40624a8ad076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0ccad7d43d3e6845cc40624a8ad076">&#9670;&nbsp;</a></span>const_index_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef maptype_::const_iterator <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::<a class="el" href="classpvr_1_1_indexed_array.html#afb0ccad7d43d3e6845cc40624a8ad076">const_index_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Indexed (Constant) iterator of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a> class. Will follow the indexing map of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a> iterating items in their Indexing order. </p>

</div>
</div>
<a id="a782c77681cab6a206279fd79f3f27efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782c77681cab6a206279fd79f3f27efe">&#9670;&nbsp;</a></span>index_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef maptype_::iterator <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::<a class="el" href="classpvr_1_1_indexed_array.html#a782c77681cab6a206279fd79f3f27efe">index_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Indexed iterator of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a> class. Will follow the indexing map of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a> iterating items in their Indexing order. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aef0bfb2ab12222311071c4dc052e64dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0bfb2ab12222311071c4dc052e64dc">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_indexed_array_1_1iterator.html">iterator</a> <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a Linear iterator to the first non-deleted item in the backing store. </p>
<dl class="section return"><dt>Returns</dt><dd>A Linear iterator to the first non-deleted item in the backing store.</dd></dl>

</div>
</div>
<a id="a8fe42763be337e0b24402837f45e190c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe42763be337e0b24402837f45e190c">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_indexed_array_1_1const__iterator.html">const_iterator</a> <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a Linear <a class="el" href="classpvr_1_1_indexed_array_1_1const__iterator.html" title="An (constant) Linear iterator of the IndexedArray class. Will linearly iterate the backing store skip...">const_iterator</a> to the first non-deleted item in the backing store. </p>
<dl class="section return"><dt>Returns</dt><dd>A Linear <a class="el" href="classpvr_1_1_indexed_array_1_1const__iterator.html" title="An (constant) Linear iterator of the IndexedArray class. Will linearly iterate the backing store skip...">const_iterator</a> to the first non-deleted item in the backing store.</dd></dl>

</div>
</div>
<a id="a9ec5ba281a4a0607f8a88c89e00eaf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec5ba281a4a0607f8a88c89e00eaf20">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current capacity of the backing array of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The current capacity of the backing array of the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>.</dd></dl>

</div>
</div>
<a id="aa3b86079a6fdbec384a6c948521a143f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b86079a6fdbec384a6c948521a143f">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empties the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>. </p>

</div>
</div>
<a id="af17498f4a82d16b4906b0468237fb4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17498f4a82d16b4906b0468237fb4ba">&#9670;&nbsp;</a></span>compact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compacts the backing array by removing existing items from the end of the vector and putting them in the place of deleted items, and then updating their index, until no more positions marked as deleted are left. Will ensure the contiguousness of the backing vector, but will invalidate previously gotten item indices. </p>

</div>
</div>
<a id="ae8a85600a95919b0a980d2c015eefc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a85600a95919b0a980d2c015eefc63">&#9670;&nbsp;</a></span>deletedItemsCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::deletedItemsCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of deleted items. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of deleted items.</dd></dl>

</div>
</div>
<a id="a7ed600c1b8483c9ff8397930745670e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed600c1b8483c9ff8397930745670e9">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_indexed_array_1_1iterator.html">iterator</a> <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator pointing one item past the last item in the backing array. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the backing array</dd></dl>

</div>
</div>
<a id="a968979700a2d3bea7401f714f0fe5a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968979700a2d3bea7401f714f0fe5a74">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_indexed_array_1_1const__iterator.html">const_iterator</a> <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a <a class="el" href="classpvr_1_1_indexed_array_1_1const__iterator.html" title="An (constant) Linear iterator of the IndexedArray class. Will linearly iterate the backing store skip...">const_iterator</a> pointing one item past the last item in the backing array. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the backing array</dd></dl>

</div>
</div>
<a id="aa67ed0d00a2496d00fdc39a14924764d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67ed0d00a2496d00fdc39a14924764d">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const IndexType_ &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the item with the specified key from the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The Key of the item to erase</td></tr>
  </table>
  </dd>
</dl>
<p>This method will find the entry with specified key and remove it. It will not invalidata existing indices, but it will void the contiguousness guarantee the backing array normally has. Call <a class="el" href="classpvr_1_1_indexed_array.html#af17498f4a82d16b4906b0468237fb4ba" title="Compacts the backing array by removing existing items from the end of the vector and putting them in ...">compact()</a> afterwards to make the vector contiguous again (but invalidate existing indices).</p>

</div>
</div>
<a id="a56b081c28171501d77650532d4349dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b081c28171501d77650532d4349dcf">&#9670;&nbsp;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::getIndex </td>
          <td>(</td>
          <td class="paramtype">const IndexType_ &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of a specific key in the backing array. Valid until a reshuffling of the array is done via insert, compact or similar operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The Key of the item to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of <em>key</em> , -1 if key does not exist.</dd></dl>

</div>
</div>
<a id="a92e5a920b354cff055ad8964b2edd3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e5a920b354cff055ad8964b2edd3a8">&#9670;&nbsp;</a></span>indexed_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">maptype_::iterator <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::indexed_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an indexed_const_iterator to the first item in the map. </p>
<dl class="section return"><dt>Returns</dt><dd>An indexed iterator to the beginning</dd></dl>

</div>
</div>
<a id="a14889278fbd62088276567bcd762de1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14889278fbd62088276567bcd762de1a">&#9670;&nbsp;</a></span>indexed_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">maptype_::const_iterator <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::indexed_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a indexed_const_iterator to the first item in the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant indexed iterator to the beginning</dd></dl>

</div>
</div>
<a id="a082022aecf9605516a50ee9e643a49d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082022aecf9605516a50ee9e643a49d7">&#9670;&nbsp;</a></span>indexed_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">maptype_::iterator <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::indexed_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an indexed_iterator pointing one item past the last item in the map. </p>
<dl class="section return"><dt>Returns</dt><dd>An indexed iterator to the end</dd></dl>

</div>
</div>
<a id="ae9ececf18821288a3312e6b7f2971260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ececf18821288a3312e6b7f2971260">&#9670;&nbsp;</a></span>indexed_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">maptype_::const_iterator <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::indexed_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an indexed_const_iterator pointing one item past the last item in the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A const indexed iterator to the end</dd></dl>

</div>
</div>
<a id="a659f1981296374a659c21f5f4ebbf26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659f1981296374a659c21f5f4ebbf26c">&#9670;&nbsp;</a></span>indexed_find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">maptype_::iterator <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::indexed_find </td>
          <td>(</td>
          <td class="paramtype">const IndexType_ &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an indexed iterator by finding the provided key Indexing map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key with which to lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An indexed_iterator</dd></dl>

</div>
</div>
<a id="ac2f8ef4ef8c58ab81aa5f20e2971cdad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f8ef4ef8c58ab81aa5f20e2971cdad">&#9670;&nbsp;</a></span>indexed_find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">maptype_::const_iterator <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::indexed_find </td>
          <td>(</td>
          <td class="paramtype">const IndexType_ &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const indexed iterator by finding the provided key Indexing map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key with which to lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const indexed iterator</dd></dl>

</div>
</div>
<a id="ad45c7465ac70d247b92b6f14b72019e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45c7465ac70d247b92b6f14b72019e7">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const IndexType_ &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType_ &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an item at the first possible spot in the backing array. If key exists, will update the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The Key of the new item</td></tr>
    <tr><td class="paramname">val</td><td>The Value of the new item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index, in the backing array, of the inserted/updated item</dd></dl>

</div>
</div>
<a id="ad9d837ac51c85ae08233d6bc9506566a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d837ac51c85ae08233d6bc9506566a">&#9670;&nbsp;</a></span>insertAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::insertAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType_ &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType_ &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an item at a specific point in the backing array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">where</td><td>The index where to insert the new item</td></tr>
    <tr><td class="paramname">key</td><td>The Key of the new item</td></tr>
    <tr><td class="paramname">val</td><td>The Value of the new item</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dab1c6d92f30f2cf1aaeb26636e90ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dab1c6d92f30f2cf1aaeb26636e90ce">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType_&amp; <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const IndexType_ &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indexed indexing operator. Uses std::map find to retrieve the specified value. If the key does not exist, it will be inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the item at specified index</dd></dl>

</div>
</div>
<a id="a198f1d024acc685429fb3bc2622846dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198f1d024acc685429fb3bc2622846dd">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ValueType_&amp; <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const IndexType_ &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indexed indexing operator. Uses std::map find to retrieve the specified value. If the key does not exist, it will be inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the item at specified index</dd></dl>

</div>
</div>
<a id="a1f92746bf6e8443fc770868132e45697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f92746bf6e8443fc770868132e45697">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType_&amp; <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array indexing operator. Constant time. Use getIndex to get the indices of specific items. If idx points to a deleted item or past the last item, the behaviour is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The backing index to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the item at specified index</dd></dl>

</div>
</div>
<a id="add003e9e7e15d0459b1df3c4356d6be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add003e9e7e15d0459b1df3c4356d6be4">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ValueType_&amp; <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const array indexing operator. Use getIndex to get the indices of specific items. If idx points to a deleted item or past the last item, the behaviour is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The backing index to retrieve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const Reference to the item at specified index</dd></dl>

</div>
</div>
<a id="a92da13fb7957ca214b6d3fec340a51da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92da13fb7957ca214b6d3fec340a51da">&#9670;&nbsp;</a></span>relocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::relocate </td>
          <td>(</td>
          <td class="paramtype">const IndexType_ &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move a specific item (identified by a key) to a specific index in the list. If an item is already in this spot in the list, their positions are swapped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the item to relocate.</td></tr>
    <tr><td class="paramname">index</td><td>The index where to relocate the item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the specified key was not found in the index.</dd></dl>

</div>
</div>
<a id="ae7186f7b14ae8ee5eb79d465de2a2381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7186f7b14ae8ee5eb79d465de2a2381">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of items in the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of items in the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>.</dd></dl>

</div>
</div>
<a id="aa54308766b4791cfca46a04029de862b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54308766b4791cfca46a04029de862b">&#9670;&nbsp;</a></span>sizeWithDeleted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType_ , typename IndexType_  = std::string&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classpvr_1_1_indexed_array.html">pvr::IndexedArray</a>&lt; ValueType_, IndexType_ &gt;::sizeWithDeleted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of items in the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>, including items that have been deleted. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of items in the <a class="el" href="classpvr_1_1_indexed_array.html" title="A combination of array (std::vector) with associative container (std::map). Supports association of n...">IndexedArray</a>, including items that have been deleted.</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRAssets/<a class="el" href="_indexed_array_8h_source.html">IndexedArray.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="20%" height="20%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
