<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PVRUtils: /usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRUtils/Vulkan/HelperVk.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="80%" height="80%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_ca6309d378ceffb9970caf11a0592736.html">SDK</a></li><li class="navelem"><a class="el" href="dir_1b17efea2d0d450cd18d875f7f2a6e9c.html">framework</a></li><li class="navelem"><a class="el" href="dir_04d546e47904494c8f2a634ed861a0d7.html">PVRUtils</a></li><li class="navelem"><a class="el" href="dir_f07b109ccd199f39a4dc7ead82937581.html">Vulkan</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">HelperVk.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains helper functions for several common complicated Vulkan tasks, such as swapchain creation and texture uploading.  
<a href="#details">More...</a></p>

<p><a href="_helper_vk_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_create_swapchain_parameters.html">pvr::utils::CreateSwapchainParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter object for the createSwapchainRenderpassFramebuffers call. Defaults are sensible and immediately usable, can be used, but it is recommended to pass the Vulkan Memory Allocator if one is used in the application.  <a href="structpvr_1_1utils_1_1_create_swapchain_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">pvr::utils::DebugUtilsCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple wrapper structure which provides a more abstract representation of a set of debug utils messengers or debug callbacks when using either VK_EXT_debug_utils or VK_EXT_debug_report respectively.  <a href="structpvr_1_1utils_1_1_debug_utils_callbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">pvr::utils::DeviceExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of device extensions to be used for initiailising a device using the helper function 'createDeviceAndQueues'.  <a href="structpvr_1_1utils_1_1_device_extensions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_image_update_info.html">pvr::utils::ImageUpdateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_image_update_info.html" title="The ImageUpdateInfo struct.">ImageUpdateInfo</a> struct.  <a href="structpvr_1_1utils_1_1_image_update_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">pvr::utils::InstanceExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of instance extensions to be used for initiailising an instance using the helper function 'createInstanceAndSurface'.  <a href="structpvr_1_1utils_1_1_instance_extensions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">pvr::utils::InstanceLayers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of instance layers to be used for initiailising an instance using the helper function 'createInstanceAndSurface'.  <a href="structpvr_1_1utils_1_1_instance_layers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_on_screen_objects.html">pvr::utils::OnScreenObjects</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packaging for Swapchain, on screen Framebuffers, Renderpass, Attachments. Returned by createSwapchainRenderpassFramebuffers  <a href="structpvr_1_1utils_1_1_on_screen_objects.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html">pvr::utils::QueueAccessInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating the family id and queue id of a particular queue retrieved via the helper function 'createDeviceAndQueues'. The family id corresponds to the family id the queue was retrieved from. The queue id corresponds to the particular queue index for the retrieved queue.  <a href="structpvr_1_1utils_1_1_queue_access_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html">pvr::utils::QueuePopulateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating the set of queue flags required for a particular queue retrieved via the helper function 'createDeviceAndQueues'. Optionally additionally providing a surface will indicate that the queue must support presentation via the provided surface.  <a href="structpvr_1_1utils_1_1_queue_populate_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">pvr::utils::VertexBindings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.  <a href="structpvr_1_1utils_1_1_vertex_bindings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">pvr::utils::VertexBindings_Name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name.  <a href="structpvr_1_1utils_1_1_vertex_bindings___name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">pvr::utils::VulkanVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html" title="The VulkanVersion structure provides an easy mechanism for constructing the Vulkan version for use wh...">VulkanVersion</a> structure provides an easy mechanism for constructing the Vulkan version for use when creating a Vulkan instance.  <a href="structpvr_1_1utils_1_1_vulkan_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepvr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr.html">pvr</a></td></tr>
<tr class="memdesc:namespacepvr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main PowerVR Framework namespace <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepvr_1_1utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html">pvr::utils</a></td></tr>
<tr class="memdesc:namespacepvr_1_1utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main namespace for the PVRUtils Library <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a100ef068316423d649e18a3a2168aacb"><td class="memTemplParams" colspan="2">template&lt;typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:a100ef068316423d649e18a3a2168aacb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a100ef068316423d649e18a3a2168aacb">pvr::utils::appendSingleBuffersFromModel</a> (pvrvk::Device &amp;device, const assets::Model &amp;model, VboContainer_ &amp;vbos, IboContainer_ &amp;ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a100ef068316423d649e18a3a2168aacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user.  <a href="namespacepvr_1_1utils.html#a100ef068316423d649e18a3a2168aacb">More...</a><br /></td></tr>
<tr class="separator:a100ef068316423d649e18a3a2168aacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4342936bd81db16b3f74ec91957bbd4f"><td class="memItemLeft" align="right" valign="top"><a id="a4342936bd81db16b3f74ec91957bbd4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pvr::utils::details::assignAttachmentIndexes</b> (bool hasDepth, bool isMultisampled, int &amp;outColorIdx, int &amp;outDepthIdx, int &amp;outColorResolveIdx, int &amp;outDepthResolveIdx)</td></tr>
<tr class="separator:a4342936bd81db16b3f74ec91957bbd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab62f121a7b8a9d790ca4e4e3dfcff0aa">pvr::utils::beginCommandBufferDebugLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.  <a href="namespacepvr_1_1utils.html#ab62f121a7b8a9d790ca4e4e3dfcff0aa">More...</a><br /></td></tr>
<tr class="separator:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f241ba112200732fffaeb2906b6ed4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">pvr::utils::beginCommandBufferDebugLabel</a> (pvrvk::CommandBufferBase commandBufferBase, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a3f241ba112200732fffaeb2906b6ed4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.  <a href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">More...</a><br /></td></tr>
<tr class="separator:a3f241ba112200732fffaeb2906b6ed4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dc67a22e33dc6bf735edc27a1432ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a45dc67a22e33dc6bf735edc27a1432ef">pvr::utils::beginCommandBufferDebugLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a45dc67a22e33dc6bf735edc27a1432ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this secondary command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.  <a href="namespacepvr_1_1utils.html#a45dc67a22e33dc6bf735edc27a1432ef">More...</a><br /></td></tr>
<tr class="separator:a45dc67a22e33dc6bf735edc27a1432ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaec27096b06e097a3ead372e30c68c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7eaec27096b06e097a3ead372e30c68c">pvr::utils::beginQueueDebugLabel</a> (pvrvk::Queue queue, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a7eaec27096b06e097a3ead372e30c68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this queue. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.  <a href="namespacepvr_1_1utils.html#a7eaec27096b06e097a3ead372e30c68c">More...</a><br /></td></tr>
<tr class="separator:a7eaec27096b06e097a3ead372e30c68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f76f7564d0c8100418857026db23840"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4f76f7564d0c8100418857026db23840">pvr::utils::captureImageRegion</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Image &amp;image, pvrvk::Offset3D srcOffset=pvrvk::Offset3D(0, 0, 0), pvrvk::Extent3D srcExtent=pvrvk::Extent3D(static_cast&lt; uint32_t &gt;(-1), static_cast&lt; uint32_t &gt;(-1), static_cast&lt; uint32_t &gt;(-1)), pvrvk::Format destinationImageFormat=pvrvk::Format::e_UNDEFINED, pvrvk::ImageLayout imageInitialLayout=pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL, pvrvk::ImageLayout imageFinalLayout=pvrvk::ImageLayout::e_TRANSFER_DST_OPTIMAL, vma::Allocator bufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr)</td></tr>
<tr class="memdesc:a4f76f7564d0c8100418857026db23840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves and returns the contents of a particular image region. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set.  <a href="namespacepvr_1_1utils.html#a4f76f7564d0c8100418857026db23840">More...</a><br /></td></tr>
<tr class="separator:a4f76f7564d0c8100418857026db23840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad0c9ce4267ec635305fc87aba0b9d9c2">pvr::utils::create3dPlaneMesh</a> (uint32_t width, uint32_t depth, bool generateTexCoords, bool generateNormalCoords, assets::Mesh &amp;outMesh)</td></tr>
<tr class="memdesc:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3d plane mesh based on the width and depth specified. Texture coordinates and normal coordinates can also optionally be generated based on the generateTexCoords and generateNormalCoords flags respectively. The generated mesh will be returned as a pvr::assets::Mesh.  <a href="namespacepvr_1_1utils.html#ad0c9ce4267ec635305fc87aba0b9d9c2">More...</a><br /></td></tr>
<tr class="separator:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4933d5feabd4336b9023ba4b7fcd50f5"><td class="memItemLeft" align="right" valign="top">pvrvk::Buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4933d5feabd4336b9023ba4b7fcd50f5">pvr::utils::createBuffer</a> (const pvrvk::Device &amp;device, const pvrvk::BufferCreateInfo &amp;createInfo, pvrvk::MemoryPropertyFlags requiredMemoryFlags, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, const vma::Allocator &amp;bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT, pvrvk::MemoryAllocateFlags memoryAllocateFlags=pvrvk::MemoryAllocateFlags::e_NONE)</td></tr>
<tr class="memdesc:a4933d5feabd4336b9023ba4b7fcd50f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer object and (optionally) allocate and bind memory for it  <a href="namespacepvr_1_1utils.html#a4933d5feabd4336b9023ba4b7fcd50f5">More...</a><br /></td></tr>
<tr class="separator:a4933d5feabd4336b9023ba4b7fcd50f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="memItemLeft" align="right" valign="top">DebugUtilsCallbacks&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3c7a82ad08f5f77c574a75fc1c4eca9a">pvr::utils::createDebugUtilsCallbacks</a> (pvrvk::Instance &amp;instance)</td></tr>
<tr class="memdesc:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a default set of debug utils messengers or debug callbacks using either VK_EXT_debug_utils or VK_EXT_debug_report respectively. The first callback will trigger an exception to be thrown when an error message is returned. The second callback will Log a message for errors and warnings.  <a href="namespacepvr_1_1utils.html#a3c7a82ad08f5f77c574a75fc1c4eca9a">More...</a><br /></td></tr>
<tr class="separator:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9424bfa72230f6de076797e8a9c018"><td class="memItemLeft" align="right" valign="top">std::vector&lt; pvrvk::ImageView &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5f9424bfa72230f6de076797e8a9c018">pvr::utils::createDepthStencilImageAndViews</a> (const pvrvk::Device &amp;device, int32_t imageCount, pvrvk::Format depthFormat, const pvrvk::Extent2D &amp;imageExtent, const pvrvk::ImageUsageFlags &amp;imageUsageFlags=pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT, pvrvk::SampleCountFlags sampleCount=pvrvk::SampleCountFlags::e_1_BIT, vma::Allocator dsImageAllocator=nullptr, vma::AllocationCreateFlags dsImageAllocationCreateFlags=vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT)</td></tr>
<tr class="memdesc:a5f9424bfa72230f6de076797e8a9c018"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED. Use createAttachmentImages instead  <a href="namespacepvr_1_1utils.html#a5f9424bfa72230f6de076797e8a9c018">More...</a><br /></td></tr>
<tr class="separator:a5f9424bfa72230f6de076797e8a9c018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34226196d1cd435e8f19abecc2d3b0eb"><td class="memItemLeft" align="right" valign="top">pvrvk::Device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a34226196d1cd435e8f19abecc2d3b0eb">pvr::utils::createDeviceAndQueues</a> (pvrvk::PhysicalDevice physicalDevice, const QueuePopulateInfo *queueCreateInfos, uint32_t numQueueCreateInfos, QueueAccessInfo *outAccessInfo, const DeviceExtensions &amp;deviceExtensions=DeviceExtensions())</td></tr>
<tr class="memdesc:a34226196d1cd435e8f19abecc2d3b0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the pvrvk::Device and the queues  <a href="namespacepvr_1_1utils.html#a34226196d1cd435e8f19abecc2d3b0eb">More...</a><br /></td></tr>
<tr class="separator:a34226196d1cd435e8f19abecc2d3b0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadbbd98fbeac18389e58b089db81e73"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aeadbbd98fbeac18389e58b089db81e73">pvr::utils::createImage</a> (const pvrvk::Device &amp;device, const pvrvk::ImageCreateInfo &amp;createInfo, pvrvk::MemoryPropertyFlags requiredMemoryFlags=pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, const vma::Allocator &amp;imageAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:aeadbbd98fbeac18389e58b089db81e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new Image(sparse or with memory backing, depending on <em>flags</em> . The user should not call bindMemory on the image if sparse flags are used. <em>requiredMemoryFlags</em>  is ignored if <em>flags</em>  contains sparse binding flags.  <a href="namespacepvr_1_1utils.html#aeadbbd98fbeac18389e58b089db81e73">More...</a><br /></td></tr>
<tr class="separator:aeadbbd98fbeac18389e58b089db81e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680ef5943947e565f7d14aa9ff0393d9"><td class="memItemLeft" align="right" valign="top">pvrvk::Instance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a680ef5943947e565f7d14aa9ff0393d9">pvr::utils::createInstance</a> (const std::string &amp;applicationName, VulkanVersion apiVersion=VulkanVersion(), const InstanceExtensions &amp;instanceExtensions=InstanceExtensions(), const InstanceLayers &amp;instanceLayers=InstanceLayers())</td></tr>
<tr class="memdesc:a680ef5943947e565f7d14aa9ff0393d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating a Vulkan instance and supported physical devices using the appropriately set parameters.  <a href="namespacepvr_1_1utils.html#a680ef5943947e565f7d14aa9ff0393d9">More...</a><br /></td></tr>
<tr class="separator:a680ef5943947e565f7d14aa9ff0393d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0791bbf3f9ee51623e57639997a3238c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a0791bbf3f9ee51623e57639997a3238c">pvr::utils::createMultipleBuffersFromMesh</a> (pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, std::vector&lt; pvrvk::Buffer &gt; &amp;outVbos, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator bufferAllocator, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a0791bbf3f9ee51623e57639997a3238c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh.  <a href="namespacepvr_1_1utils.html#a0791bbf3f9ee51623e57639997a3238c">More...</a><br /></td></tr>
<tr class="separator:a0791bbf3f9ee51623e57639997a3238c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada646be2dd95421863b51714591825cf"><td class="memItemLeft" align="right" valign="top">pvrvk::RenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ada646be2dd95421863b51714591825cf">pvr::utils::createOnscreenFramebufferAndRenderPass</a> (const pvrvk::Swapchain &amp;swapchain, pvrvk::ImageView *depthStencilImages, Multi&lt; pvrvk::Framebuffer &gt; &amp;outFramebuffers, pvrvk::ImageLayout initialSwapchainLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::AttachmentLoadOp colorLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp colorStoreOp=pvrvk::AttachmentStoreOp::e_STORE, pvrvk::AttachmentLoadOp depthStencilLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp depthStencilStoreOp=pvrvk::AttachmentStoreOp::e_DONT_CARE)</td></tr>
<tr class="memdesc:ada646be2dd95421863b51714591825cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED  <a href="namespacepvr_1_1utils.html#ada646be2dd95421863b51714591825cf">More...</a><br /></td></tr>
<tr class="separator:ada646be2dd95421863b51714591825cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba79655d85e1b12e2fa33fe431533cb"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:aaba79655d85e1b12e2fa33fe431533cb"><td class="memTemplItemLeft" align="right" valign="top">ContainerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aaba79655d85e1b12e2fa33fe431533cb">pvr::utils::createOnscreenFramebuffers</a> (const pvrvk::Swapchain &amp;swapchain, const pvrvk::RenderPass &amp;renderPass, const pvrvk::ImageView *depthStencilImages, pvrvk::ImageView *colorMultisampledImages, pvrvk::ImageView *depthStencilMultisampledImages)</td></tr>
<tr class="separator:aaba79655d85e1b12e2fa33fe431533cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0324a015a6d6d4df8b7caa525416ff89"><td class="memItemLeft" align="right" valign="top">pvrvk::RenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a0324a015a6d6d4df8b7caa525416ff89">pvr::utils::createOnScreenRenderPass</a> (const pvrvk::Swapchain &amp;swapchain, bool hasDepthStencil, const pvrvk::Format depthStencilFormat=pvrvk::Format::e_UNDEFINED, pvrvk::ImageLayout initialSwapchainLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::AttachmentLoadOp colorLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp colorStoreOp=pvrvk::AttachmentStoreOp::e_STORE, pvrvk::AttachmentLoadOp depthStencilLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp depthStencilStoreOp=pvrvk::AttachmentStoreOp::e_DONT_CARE, pvrvk::SampleCountFlags samples=pvrvk::SampleCountFlags::e_1_BIT)</td></tr>
<tr class="memdesc:a0324a015a6d6d4df8b7caa525416ff89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a renderpass for On-Screen (or other swapchain-based) rendering, based on the information contained in the swapchain. No other objects, (such as framebuffers and attachments) are created.  <a href="namespacepvr_1_1utils.html#a0324a015a6d6d4df8b7caa525416ff89">More...</a><br /></td></tr>
<tr class="separator:a0324a015a6d6d4df8b7caa525416ff89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecb636ae6f2c37e90259571ba245f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aeecb636ae6f2c37e90259571ba245f3b">pvr::utils::createSingleBuffersFromMesh</a> (pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, pvrvk::Buffer &amp;outVbo, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:aeecb636ae6f2c37e90259571ba245f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a single VBO and a single IBO from all the vertex data of a mesh.  <a href="namespacepvr_1_1utils.html#aeecb636ae6f2c37e90259571ba245f3b">More...</a><br /></td></tr>
<tr class="separator:aeecb636ae6f2c37e90259571ba245f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b47e0a1077b70398aad03b73ea46f6c"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:a8b47e0a1077b70398aad03b73ea46f6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8b47e0a1077b70398aad03b73ea46f6c">pvr::utils::createSingleBuffersFromMeshes</a> (pvrvk::Device &amp;device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboContainer_ &amp;outVbos, typename VboContainer_::iterator vbos_where, IboContainer_ &amp;outIbos, typename IboContainer_::iterator ibos_where, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a8b47e0a1077b70398aad03b73ea46f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container.  <a href="namespacepvr_1_1utils.html#a8b47e0a1077b70398aad03b73ea46f6c">More...</a><br /></td></tr>
<tr class="separator:a8b47e0a1077b70398aad03b73ea46f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3726d86dbda8ccaba9ed2c300b1fbe"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a7c3726d86dbda8ccaba9ed2c300b1fbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7c3726d86dbda8ccaba9ed2c300b1fbe">pvr::utils::createSingleBuffersFromMeshes</a> (pvrvk::Device &amp;device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboInsertIterator_ outVbos, IboInsertIterator_ outIbos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a7c3726d86dbda8ccaba9ed2c300b1fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container.  <a href="namespacepvr_1_1utils.html#a7c3726d86dbda8ccaba9ed2c300b1fbe">More...</a><br /></td></tr>
<tr class="separator:a7c3726d86dbda8ccaba9ed2c300b1fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7710bb6fdcb3e45a8787cb4cc3f64e6c"><td class="memTemplParams" colspan="2">template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a7710bb6fdcb3e45a8787cb4cc3f64e6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7710bb6fdcb3e45a8787cb4cc3f64e6c">pvr::utils::createSingleBuffersFromModel</a> (pvrvk::Device &amp;device, const assets::Model &amp;model, VboInsertIterator_ vbos, IboInsertIterator_ ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, vma::Allocator bufferAllocator=nullptr, vma::AllocationCreateFlags vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a7710bb6fdcb3e45a8787cb4cc3f64e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters.  <a href="namespacepvr_1_1utils.html#a7710bb6fdcb3e45a8787cb4cc3f64e6c">More...</a><br /></td></tr>
<tr class="separator:a7710bb6fdcb3e45a8787cb4cc3f64e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3530d448cda15aea32f3395ca427957b"><td class="memItemLeft" align="right" valign="top">pvrvk::Surface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3530d448cda15aea32f3395ca427957b">pvr::utils::createSurface</a> (const pvrvk::Instance &amp;instance, const pvrvk::PhysicalDevice &amp;physicalDevice, void *window, void *display, void *connection)</td></tr>
<tr class="memdesc:a3530d448cda15aea32f3395ca427957b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract vulkan native platform surface.  <a href="namespacepvr_1_1utils.html#a3530d448cda15aea32f3395ca427957b">More...</a><br /></td></tr>
<tr class="separator:a3530d448cda15aea32f3395ca427957b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbc4fadd267c20f1464ab4d21269bbf"><td class="memItemLeft" align="right" valign="top">pvrvk::Swapchain&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1bbc4fadd267c20f1464ab4d21269bbf">pvr::utils::createSwapchain</a> (const pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::ImageUsageFlags swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT, const std::vector&lt; pvrvk::Format &gt; &amp;preferredColorFormats=std::vector&lt; pvrvk::Format &gt;())</td></tr>
<tr class="memdesc:a1bbc4fadd267c20f1464ab4d21269bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface.  <a href="namespacepvr_1_1utils.html#a1bbc4fadd267c20f1464ab4d21269bbf">More...</a><br /></td></tr>
<tr class="separator:a1bbc4fadd267c20f1464ab4d21269bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c374ce16fadf5be9b63e3675e51585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a33c374ce16fadf5be9b63e3675e51585">pvr::utils::createSwapchainAndDepthStencilImageAndViews</a> (const pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::Swapchain &amp;outSwapchain, Multi&lt; pvrvk::ImageView &gt; &amp;outDepthStencilImages, const pvrvk::ImageUsageFlags &amp;swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT, const pvrvk::ImageUsageFlags &amp;dsImageUsageFlags=pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT, const vma::Allocator &amp;imageAllocator=nullptr, vma::AllocationCreateFlags dsImageAllocationCreateFlags=vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT)</td></tr>
<tr class="memdesc:a33c374ce16fadf5be9b63e3675e51585"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED. Either use createSwapchainRenderpassFramebuffers, or createSwapchain and createAttachments  <a href="namespacepvr_1_1utils.html#a33c374ce16fadf5be9b63e3675e51585">More...</a><br /></td></tr>
<tr class="separator:a33c374ce16fadf5be9b63e3675e51585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8589ef735f2d2222a14ba470218c02af"><td class="memItemLeft" align="right" valign="top">OnScreenObjects&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8589ef735f2d2222a14ba470218c02af">pvr::utils::createSwapchainRenderpassFramebuffers</a> (const pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, const CreateSwapchainParameters &amp;params=CreateSwapchainParameters())</td></tr>
<tr class="memdesc:a8589ef735f2d2222a14ba470218c02af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Framebuffer and RenderPass to use for 'default' rendering to the 'onscreen' color images. Default configuration is as follows. Formats and other configurations can be tweaked through displayAttributes and params. RenderPass: Attachment0: ColorAttachment swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store Attachment1: DepthStencilAttachment finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store If displayAttributes.aaSamples&gt;1 Multisampling will be enabled and the correct resolve attachments for multisampling will be created.  <a href="namespacepvr_1_1utils.html#a8589ef735f2d2222a14ba470218c02af">More...</a><br /></td></tr>
<tr class="separator:a8589ef735f2d2222a14ba470218c02af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da693f264b2b719a77fc84bf0a32ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2da693f264b2b719a77fc84bf0a32ec5">pvr::utils::endCommandBufferDebugLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer)</td></tr>
<tr class="memdesc:a2da693f264b2b719a77fc84bf0a32ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this command buffer.  <a href="namespacepvr_1_1utils.html#a2da693f264b2b719a77fc84bf0a32ec5">More...</a><br /></td></tr>
<tr class="separator:a2da693f264b2b719a77fc84bf0a32ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e6adce5bcec23564fd67553c9f4088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">pvr::utils::endCommandBufferDebugLabel</a> (pvrvk::CommandBufferBase commandBufferBase)</td></tr>
<tr class="memdesc:a12e6adce5bcec23564fd67553c9f4088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this base command buffer.  <a href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">More...</a><br /></td></tr>
<tr class="separator:a12e6adce5bcec23564fd67553c9f4088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee1c88c7937b7a16127e810b75b2ab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#adee1c88c7937b7a16127e810b75b2ab7">pvr::utils::endCommandBufferDebugLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer)</td></tr>
<tr class="memdesc:adee1c88c7937b7a16127e810b75b2ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this secondary command buffer.  <a href="namespacepvr_1_1utils.html#adee1c88c7937b7a16127e810b75b2ab7">More...</a><br /></td></tr>
<tr class="separator:adee1c88c7937b7a16127e810b75b2ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605300322093e44b7cd509533f14b4fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a605300322093e44b7cd509533f14b4fa">pvr::utils::endQueueDebugLabel</a> (pvrvk::Queue queue)</td></tr>
<tr class="memdesc:a605300322093e44b7cd509533f14b4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this queue.  <a href="namespacepvr_1_1utils.html#a605300322093e44b7cd509533f14b4fa">More...</a><br /></td></tr>
<tr class="separator:a605300322093e44b7cd509533f14b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af7fff69d5da0331018f68f0d95ba8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a9af7fff69d5da0331018f68f0d95ba8a">pvr::utils::generateTextureAtlas</a> (pvrvk::Device &amp;device, const pvrvk::Image *inputImages, pvrvk::Rect2Df *outUVs, uint32_t numImages, pvrvk::ImageLayout inputImageLayout, pvrvk::ImageView *outImageView, TextureHeader *outDescriptor, pvrvk::CommandBufferBase cmdBuffer, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a9af7fff69d5da0331018f68f0d95ba8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for generating a texture atlas based on a set of images.  <a href="namespacepvr_1_1utils.html#a9af7fff69d5da0331018f68f0d95ba8a">More...</a><br /></td></tr>
<tr class="separator:a9af7fff69d5da0331018f68f0d95ba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ce1f5bcf625224715988176c3519a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a56ce1f5bcf625224715988176c3519a2">pvr::utils::getColorBits</a> (pvrvk::Format format, uint32_t &amp;redBits, uint32_t &amp;greenBits, uint32_t &amp;blueBits, uint32_t &amp;alphaBits)</td></tr>
<tr class="memdesc:a56ce1f5bcf625224715988176c3519a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of color bits per pixel for the given pvrvk::Format.  <a href="namespacepvr_1_1utils.html#a56ce1f5bcf625224715988176c3519a2">More...</a><br /></td></tr>
<tr class="separator:a56ce1f5bcf625224715988176c3519a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcac1e9af1869244329d12c291200a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1bcac1e9af1869244329d12c291200a5">pvr::utils::getDepthStencilBits</a> (pvrvk::Format format, uint32_t &amp;depthBits, uint32_t &amp;stencilBits)</td></tr>
<tr class="memdesc:a1bcac1e9af1869244329d12c291200a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of depth and stencil bits per pixel for the given pvrvk::Format.  <a href="namespacepvr_1_1utils.html#a1bcac1e9af1869244329d12c291200a5">More...</a><br /></td></tr>
<tr class="separator:a1bcac1e9af1869244329d12c291200a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6bbf98fde377992e9e7e0d23f38a9dcc">pvr::utils::getMemoryTypeIndex</a> (const pvrvk::PhysicalDevice &amp;physicalDevice, const uint32_t allowedMemoryTypeBits, const pvrvk::MemoryPropertyFlags requiredMemoryProperties, const pvrvk::MemoryPropertyFlags optimalMemoryProperties, uint32_t &amp;outMemoryTypeIndex, pvrvk::MemoryPropertyFlags &amp;outMemoryPropertyFlags)</td></tr>
<tr class="memdesc:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for retrieving a memory type index for a suitable memory type which supports the memory type bits specified. If the optimal set of memory properties are supported then return the corresponding memory type index otherwise check for availablility of the required set of memory properties. This allows for implementations to optionally request the use of a more optimal set of memory properties whilst still preserving the ability to retrieve the required set of memory properties as a fallback.  <a href="namespacepvr_1_1utils.html#a6bbf98fde377992e9e7e0d23f38a9dcc">More...</a><br /></td></tr>
<tr class="separator:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2d4df80d31e3e63923ab1d68152ace"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7b2d4df80d31e3e63923ab1d68152ace">pvr::utils::getNumSamplesFromSampleCountFlags</a> (pvrvk::SampleCountFlags sampleCountFlags)</td></tr>
<tr class="memdesc:a7b2d4df80d31e3e63923ab1d68152ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert pvrvk sample count to the number of samples it is equivalent to  <a href="namespacepvr_1_1utils.html#a7b2d4df80d31e3e63923ab1d68152ace">More...</a><br /></td></tr>
<tr class="separator:a7b2d4df80d31e3e63923ab1d68152ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e3ce8540f44d3ab8649a7c4487234b"><td class="memItemLeft" align="right" valign="top"><a id="ad3e3ce8540f44d3ab8649a7c4487234b"></a>
pvrvk::Format&#160;</td><td class="memItemRight" valign="bottom"><b>pvr::utils::getSupportedDepthStencilFormat</b> (const pvrvk::Device &amp;device, pvr::DisplayAttributes &amp;displayAttributes, std::vector&lt; pvrvk::Format &gt; preferredDepthFormats={})</td></tr>
<tr class="separator:ad3e3ce8540f44d3ab8649a7c4487234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93735fa36d5aedc03cf746dfa208a4b5"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageAspectFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a93735fa36d5aedc03cf746dfa208a4b5">pvr::utils::inferAspectFromFormat</a> (pvrvk::Format format)</td></tr>
<tr class="memdesc:a93735fa36d5aedc03cf746dfa208a4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infers the pvrvk::ImageAspectFlags from the pvrvk::Format.  <a href="namespacepvr_1_1utils.html#a93735fa36d5aedc03cf746dfa208a4b5">More...</a><br /></td></tr>
<tr class="separator:a93735fa36d5aedc03cf746dfa208a4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab77d5528ee9f9dc1f4dda381175b89eb">pvr::utils::insertDebugUtilsLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time.  <a href="namespacepvr_1_1utils.html#ab77d5528ee9f9dc1f4dda381175b89eb">More...</a><br /></td></tr>
<tr class="separator:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3adba7320aa2b924adc48cfa5e043ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">pvr::utils::insertDebugUtilsLabel</a> (pvrvk::CommandBufferBase commandBufferBase, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ae3adba7320aa2b924adc48cfa5e043ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time.  <a href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">More...</a><br /></td></tr>
<tr class="separator:ae3adba7320aa2b924adc48cfa5e043ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2938b3543ae68e23f0f2eb348a786ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2938b3543ae68e23f0f2eb348a786ae9">pvr::utils::insertDebugUtilsLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a2938b3543ae68e23f0f2eb348a786ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time.  <a href="namespacepvr_1_1utils.html#a2938b3543ae68e23f0f2eb348a786ae9">More...</a><br /></td></tr>
<tr class="separator:a2938b3543ae68e23f0f2eb348a786ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7151c7b74ff657fc17ff09c0ab114a07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7151c7b74ff657fc17ff09c0ab114a07">pvr::utils::isFormatDepthStencil</a> (pvrvk::Format format)</td></tr>
<tr class="memdesc:a7151c7b74ff657fc17ff09c0ab114a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the format is a depth stencil format  <a href="namespacepvr_1_1utils.html#a7151c7b74ff657fc17ff09c0ab114a07">More...</a><br /></td></tr>
<tr class="separator:a7151c7b74ff657fc17ff09c0ab114a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59222cc49624a76fab4d4f65e3337ac3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a59222cc49624a76fab4d4f65e3337ac3">pvr::utils::isImageUsageSupportedBySurface</a> (const pvrvk::SurfaceCapabilitiesKHR &amp;surfaceCapabilities, pvrvk::ImageUsageFlags imageUsage)</td></tr>
<tr class="memdesc:a59222cc49624a76fab4d4f65e3337ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function used to determine whether the SurfaceCapabilitiesKHR supportedUsageFlags member contains the specified image usage and therefore can be used in the intended way.  <a href="namespacepvr_1_1utils.html#a59222cc49624a76fab4d4f65e3337ac3">More...</a><br /></td></tr>
<tr class="separator:a59222cc49624a76fab4d4f65e3337ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab777db50d44d55cca94123e7cdcb1d7e"><td class="memItemLeft" align="right" valign="top"><a id="ab777db50d44d55cca94123e7cdcb1d7e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pvr::utils::isSupportedDepthStencilFormat</b> (const pvrvk::Device &amp;device, pvrvk::Format format)</td></tr>
<tr class="separator:ab777db50d44d55cca94123e7cdcb1d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370ec57dd60df6f8d8327619a8a90178"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a370ec57dd60df6f8d8327619a8a90178">pvr::utils::loadAndUploadImage</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator stagingBufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a370ec57dd60df6f8d8327619a8a90178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#a370ec57dd60df6f8d8327619a8a90178">More...</a><br /></td></tr>
<tr class="separator:a370ec57dd60df6f8d8327619a8a90178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138104e7cebf7941707336c0418bc3c8"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a138104e7cebf7941707336c0418bc3c8">pvr::utils::loadAndUploadImage</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator stagingBufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a138104e7cebf7941707336c0418bc3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#a138104e7cebf7941707336c0418bc3c8">More...</a><br /></td></tr>
<tr class="separator:a138104e7cebf7941707336c0418bc3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7751d185a203ad3f8d19fc1bb5eb6e2"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae7751d185a203ad3f8d19fc1bb5eb6e2">pvr::utils::loadAndUploadImage</a> (pvrvk::Device &amp;device, const std::string &amp;fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator stagingBufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ae7751d185a203ad3f8d19fc1bb5eb6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#ae7751d185a203ad3f8d19fc1bb5eb6e2">More...</a><br /></td></tr>
<tr class="separator:ae7751d185a203ad3f8d19fc1bb5eb6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868fafd2e077cfc7281c45c64677e47a"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a868fafd2e077cfc7281c45c64677e47a">pvr::utils::loadAndUploadImageAndView</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator stagingBufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a868fafd2e077cfc7281c45c64677e47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#a868fafd2e077cfc7281c45c64677e47a">More...</a><br /></td></tr>
<tr class="separator:a868fafd2e077cfc7281c45c64677e47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a49bb33bec83289c2620a84afd9c2a"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af9a49bb33bec83289c2620a84afd9c2a">pvr::utils::loadAndUploadImageAndView</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, vma::Allocator stagingBufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:af9a49bb33bec83289c2620a84afd9c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#af9a49bb33bec83289c2620a84afd9c2a">More...</a><br /></td></tr>
<tr class="separator:af9a49bb33bec83289c2620a84afd9c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbbbd1665449ea70d772de63595c806"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1cbbbd1665449ea70d772de63595c806">pvr::utils::logMessageDebugReportCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</td></tr>
<tr class="memdesc:a1cbbbd1665449ea70d772de63595c806"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugReportCallback function providing logging for various events.  <a href="namespacepvr_1_1utils.html#a1cbbbd1665449ea70d772de63595c806">More...</a><br /></td></tr>
<tr class="separator:a1cbbbd1665449ea70d772de63595c806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5e37e4f2f8723d81f2f60ff7c9ffebdf">pvr::utils::logMessageDebugUtilsMessengerCallback</a> (VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData)</td></tr>
<tr class="memdesc:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugUtilsMessengerCallback function providing logging for various events.  <a href="namespacepvr_1_1utils.html#a5e37e4f2f8723d81f2f60ff7c9ffebdf">More...</a><br /></td></tr>
<tr class="separator:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee21903727c73558ad8e3cf936917344"><td class="memItemLeft" align="right" valign="top">LogLevel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aee21903727c73558ad8e3cf936917344">pvr::utils::mapDebugReportFlagsToLogLevel</a> (pvrvk::DebugReportFlagsEXT flags)</td></tr>
<tr class="memdesc:aee21903727c73558ad8e3cf936917344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a set of DebugReportFlagsEXT to a particular type of log message.  <a href="namespacepvr_1_1utils.html#aee21903727c73558ad8e3cf936917344">More...</a><br /></td></tr>
<tr class="separator:aee21903727c73558ad8e3cf936917344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd1f30f49a0d36c9d932437e902d2bb"><td class="memItemLeft" align="right" valign="top">LogLevel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#abbd1f30f49a0d36c9d932437e902d2bb">pvr::utils::mapDebugUtilsMessageSeverityFlagsToLogLevel</a> (pvrvk::DebugUtilsMessageSeverityFlagsEXT flags)</td></tr>
<tr class="memdesc:abbd1f30f49a0d36c9d932437e902d2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a set of DebugUtilsMessageSeverityFlagsEXT to a particular type of log message.  <a href="namespacepvr_1_1utils.html#abbd1f30f49a0d36c9d932437e902d2bb">More...</a><br /></td></tr>
<tr class="separator:abbd1f30f49a0d36c9d932437e902d2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a98e4ac9990af6eaf6b9bf0928f2bd07d">pvr::utils::populateClearValues</a> (const pvrvk::RenderPass &amp;renderpass, const pvrvk::ClearValue &amp;clearColor, const pvrvk::ClearValue &amp;clearDepthStencilValue, pvrvk::ClearValue *outClearValues)</td></tr>
<tr class="memdesc:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate color and depthstencil clear values  <a href="namespacepvr_1_1utils.html#a98e4ac9990af6eaf6b9bf0928f2bd07d">More...</a><br /></td></tr>
<tr class="separator:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae0c2fd1a13ff3b5e9086e13ea4608c43">pvr::utils::populateInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const VertexBindings *bindingMap, uint16_t numBindings, pvrvk::PipelineVertexInputStateCreateInfo &amp;vertexCreateInfo, pvrvk::PipelineInputAssemblerStateCreateInfo &amp;inputAssemblerCreateInfo, uint16_t *numOutBuffers=nullptr)</td></tr>
<tr class="memdesc:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a>.  <a href="namespacepvr_1_1utils.html#ae0c2fd1a13ff3b5e9086e13ea4608c43">More...</a><br /></td></tr>
<tr class="separator:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c295af45dc688c117ebf5993e55373"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a94c295af45dc688c117ebf5993e55373">pvr::utils::populateInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const VertexBindings_Name *bindingMap, uint32_t numBindings, pvrvk::PipelineVertexInputStateCreateInfo &amp;vertexCreateInfo, pvrvk::PipelineInputAssemblerStateCreateInfo &amp;inputAssemblerCreateInfo, uint32_t *numOutBuffers=nullptr)</td></tr>
<tr class="memdesc:a94c295af45dc688c117ebf5993e55373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html" title="Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name.">VertexBindings_Name</a>.  <a href="namespacepvr_1_1utils.html#a94c295af45dc688c117ebf5993e55373">More...</a><br /></td></tr>
<tr class="separator:a94c295af45dc688c117ebf5993e55373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1e9a18d03439c5efe7d88dbb3c16b783">pvr::utils::populateViewportStateCreateInfo</a> (const pvrvk::Framebuffer &amp;framebuffer, pvrvk::PipelineViewportStateCreateInfo &amp;outCreateInfo)</td></tr>
<tr class="memdesc:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out a pvrvk::ViewportStateCreateInfo structure setting parameters for a 'default' viewport and scissor based on the specified frame buffer dimensions.  <a href="namespacepvr_1_1utils.html#a1e9a18d03439c5efe7d88dbb3c16b783">More...</a><br /></td></tr>
<tr class="separator:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee378b23390266dcaa61b724e0a29808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aee378b23390266dcaa61b724e0a29808">pvr::utils::saveImage</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Image &amp;image, const pvrvk::ImageLayout imageInitialLayout, const pvrvk::ImageLayout imageFinalLayout, const std::string &amp;filename, vma::Allocator bufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr, const uint32_t screenshotScale=1)</td></tr>
<tr class="memdesc:aee378b23390266dcaa61b724e0a29808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the input image as a TGA file with the filename specified. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set.  <a href="namespacepvr_1_1utils.html#aee378b23390266dcaa61b724e0a29808">More...</a><br /></td></tr>
<tr class="separator:aee378b23390266dcaa61b724e0a29808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076fe31eafd575f7f2a10f27f6130935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a076fe31eafd575f7f2a10f27f6130935">pvr::utils::setImageLayout</a> (pvrvk::Image &amp;image, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::CommandBufferBase transitionCmdBuffer)</td></tr>
<tr class="memdesc:a076fe31eafd575f7f2a10f27f6130935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set image layout  <a href="namespacepvr_1_1utils.html#a076fe31eafd575f7f2a10f27f6130935">More...</a><br /></td></tr>
<tr class="separator:a076fe31eafd575f7f2a10f27f6130935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f7af5558e7afc812edc1e8899d8f50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a19f7af5558e7afc812edc1e8899d8f50">pvr::utils::setImageLayoutAndQueueFamilyOwnership</a> (pvrvk::CommandBufferBase srccmd, pvrvk::CommandBufferBase dstcmd, uint32_t srcQueueFamily, uint32_t dstQueueFamily, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::Image &amp;image, uint32_t baseMipLevel, uint32_t numMipLevels, uint32_t baseArrayLayer, uint32_t numArrayLayers, pvrvk::ImageAspectFlags aspect)</td></tr>
<tr class="memdesc:a19f7af5558e7afc812edc1e8899d8f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set image layout and queue family ownership  <a href="namespacepvr_1_1utils.html#a19f7af5558e7afc812edc1e8899d8f50">More...</a><br /></td></tr>
<tr class="separator:a19f7af5558e7afc812edc1e8899d8f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc7d04620963f299874921f6fd18fb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a0dc7d04620963f299874921f6fd18fb8">pvr::utils::takeScreenshot</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Swapchain &amp;swapchain, const uint32_t swapIndex, const std::string &amp;screenshotFileName, vma::Allocator bufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr, const uint32_t screenshotScale=1)</td></tr>
<tr class="memdesc:a0dc7d04620963f299874921f6fd18fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a particular swapchain image corresponding to the swapchain image at index swapIndex for the swapchain.  <a href="namespacepvr_1_1utils.html#a0dc7d04620963f299874921f6fd18fb8">More...</a><br /></td></tr>
<tr class="separator:a0dc7d04620963f299874921f6fd18fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2bb511b50d2c11ddc7377a60714ad"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a54f2bb511b50d2c11ddc7377a60714ad">pvr::utils::throwOnErrorDebugReportCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</td></tr>
<tr class="memdesc:a54f2bb511b50d2c11ddc7377a60714ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugReportCallback function providing logging for various events. The callback will also throw an exception when VkDebugReportFlagsEXT includes the VK_DEBUG_REPORT_ERROR_BIT_EXT.  <a href="namespacepvr_1_1utils.html#a54f2bb511b50d2c11ddc7377a60714ad">More...</a><br /></td></tr>
<tr class="separator:a54f2bb511b50d2c11ddc7377a60714ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3d187bfb119271fea887f28268699a"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aaf3d187bfb119271fea887f28268699a">pvr::utils::throwOnErrorDebugUtilsMessengerCallback</a> (VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData)</td></tr>
<tr class="memdesc:aaf3d187bfb119271fea887f28268699a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugUtilsMessengerCallback function providing logging for various events. The callback will also throw an exception when VkDebugUtilsMessageSeverityFlagBitsEXT includes the VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT.  <a href="namespacepvr_1_1utils.html#aaf3d187bfb119271fea887f28268699a">More...</a><br /></td></tr>
<tr class="separator:aaf3d187bfb119271fea887f28268699a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a791a9c8914a9bf3b74db574b0c842"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac4a791a9c8914a9bf3b74db574b0c842">pvr::utils::updateBufferUsingStagingBuffer</a> (pvrvk::Device &amp;device, pvrvk::Buffer &amp;buffer, pvrvk::CommandBufferBase uploadCmdBuffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, vma::Allocator stagingBufferAllocator=nullptr)</td></tr>
<tr class="memdesc:ac4a791a9c8914a9bf3b74db574b0c842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update a buffer's data via an indirect copy from a temporary staging buffer. Updating memory via the use of a staging buffer is necessary when using memory without e_HOST_VISIBLE_BIT memory property flags meaning the buffer itself cannot be mapped to host memory.  <a href="namespacepvr_1_1utils.html#ac4a791a9c8914a9bf3b74db574b0c842">More...</a><br /></td></tr>
<tr class="separator:ac4a791a9c8914a9bf3b74db574b0c842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">pvr::utils::updateHostVisibleBuffer</a> (pvrvk::Buffer &amp;buffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, bool flushMemory=false)</td></tr>
<tr class="memdesc:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update a buffer's data. This function maps and unmap the buffer only if the buffer is not already mapped.  <a href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">More...</a><br /></td></tr>
<tr class="separator:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4a3a0c8eb6662f51128ce8a3b78a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a0f4a3a0c8eb6662f51128ce8a3b78a9f">pvr::utils::updateImage</a> (pvrvk::Device &amp;device, pvrvk::CommandBufferBase transferCommandBuffer, ImageUpdateInfo *updateInfos, uint32_t numUpdateInfos, pvrvk::Format format, pvrvk::ImageLayout layout, bool isCubeMap, pvrvk::Image &amp;image, vma::Allocator bufferAllocator=nullptr)</td></tr>
<tr class="memdesc:a0f4a3a0c8eb6662f51128ce8a3b78a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update an image's data. This function will record the update of the image in the supplied command buffer but NOT submit the command buffer, hence allowing the user to submit it at his own time. IMPORTANT. Assumes image layout is pvrvk::ImageLayout::e_DST_OPTIMAL IMPORTANT. The cleanup object that is the return value of the function must be kept alive as long until the moment that the relevant command buffer submission is finished. Then it can be destroyed (or the cleanup function be called) to free any relevant resources.  <a href="namespacepvr_1_1utils.html#a0f4a3a0c8eb6662f51128ce8a3b78a9f">More...</a><br /></td></tr>
<tr class="separator:a0f4a3a0c8eb6662f51128ce8a3b78a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff24a1e7c47775943d761eaa3f7f555e"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aff24a1e7c47775943d761eaa3f7f555e">pvr::utils::uploadImage</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator stagingBufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:aff24a1e7c47775943d761eaa3f7f555e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#aff24a1e7c47775943d761eaa3f7f555e">More...</a><br /></td></tr>
<tr class="separator:aff24a1e7c47775943d761eaa3f7f555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d35fcf1b7758225738b98830816d4e"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac4d35fcf1b7758225738b98830816d4e">pvr::utils::uploadImageAndView</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator stagingBufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ac4d35fcf1b7758225738b98830816d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#ac4d35fcf1b7758225738b98830816d4e">More...</a><br /></td></tr>
<tr class="separator:ac4d35fcf1b7758225738b98830816d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbafa4f264dcddf481f21ad03027d97"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7fbafa4f264dcddf481f21ad03027d97">pvr::utils::uploadImageAndView</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator stagingBufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a7fbafa4f264dcddf481f21ad03027d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads an image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#a7fbafa4f264dcddf481f21ad03027d97">More...</a><br /></td></tr>
<tr class="separator:a7fbafa4f264dcddf481f21ad03027d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d376caf410d6a539eb713d8886ebee"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac3d376caf410d6a539eb713d8886ebee">pvr::utils::uploadImageAndViewSubmit</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandPool &amp;commandPool, pvrvk::Queue &amp;queue, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, vma::Allocator stagingBufferAllocator=nullptr, vma::Allocator imageAllocator=nullptr, vma::AllocationCreateFlags imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ac3d376caf410d6a539eb713d8886ebee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads an image to GPU memory and returns the created image view and associated image.  <a href="namespacepvr_1_1utils.html#ac3d376caf410d6a539eb713d8886ebee">More...</a><br /></td></tr>
<tr class="separator:ac3d376caf410d6a539eb713d8886ebee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a97e337b41359e776b8c93796d23d4977"><td class="memItemLeft" align="right" valign="top"><a id="a97e337b41359e776b8c93796d23d4977"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pvr::utils::PVRUtils_Throw_On_Validation_Error</b></td></tr>
<tr class="separator:a97e337b41359e776b8c93796d23d4977"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains helper functions for several common complicated Vulkan tasks, such as swapchain creation and texture uploading. </p>
<dl class="section author"><dt>Author</dt><dd>PowerVR by Imagination, Developer Technology Team </dd></dl>
<dl class="section user"><dt>Copyright:\n Copyright (c) Imagination Technologies Limited.</dt><dd></dd></dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="20%" height="20%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
