<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PVRUtils: pvr::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="80%" height="80%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRUtils</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace for the PVRUtils Library  
<a href="namespacepvr_1_1utils.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_acceleration_structure_wrapper.html">AccelerationStructureWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for an acceleration structure for the Vulkan Khronos Ray Tracing extension.  <a href="classpvr_1_1utils_1_1_acceleration_structure_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_a_s_vertex_format.html">ASVertexFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex format of the acceleration primitive elements, in the future this vertex information wil be customizable.  <a href="structpvr_1_1utils_1_1_a_s_vertex_format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_create_swapchain_parameters.html">CreateSwapchainParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter object for the createSwapchainRenderpassFramebuffers call. Defaults are sensible and immediately usable, can be used, but it is recommended to pass the Vulkan Memory Allocator if one is used in the application.  <a href="structpvr_1_1utils_1_1_create_swapchain_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">DebugUtilsCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple wrapper structure which provides a more abstract representation of a set of debug utils messengers or debug callbacks when using either VK_EXT_debug_utils or VK_EXT_debug_report respectively.  <a href="structpvr_1_1utils_1_1_debug_utils_callbacks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of device extensions to be used for initiailising a device using the helper function 'createDeviceAndQueues'.  <a href="structpvr_1_1utils_1_1_device_extensions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_image_api_async_uploader.html">ImageApiAsyncUploader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class wraps a worker thread that uploads texture to the GPU asynchronously and returns futures to them. This class would normally be used with Texture Futures as well, in order to do both of the operations asynchronously.  <a href="classpvr_1_1utils_1_1_image_api_async_uploader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_image_update_info.html">ImageUpdateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_image_update_info.html" title="The ImageUpdateInfo struct.">ImageUpdateInfo</a> struct.  <a href="structpvr_1_1utils_1_1_image_update_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_image_upload_future__.html">ImageUploadFuture_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a wrapper for a Image upload future  <a href="structpvr_1_1utils_1_1_image_upload_future__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of instance extensions to be used for initiailising an instance using the helper function 'createInstanceAndSurface'.  <a href="structpvr_1_1utils_1_1_instance_extensions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for a list of instance layers to be used for initiailising an instance using the helper function 'createInstanceAndSurface'.  <a href="structpvr_1_1utils_1_1_instance_layers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_model_gles.html">ModelGles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1utils_1_1_model_gles.html" title="The ModelGles class provides the functionality for creating all of the buffers (vbos and ibos) and te...">ModelGles</a> class provides the functionality for creating all of the buffers (vbos and ibos) and textures required for basic rendering of a pvr::assets::Model using OpenGL ES.  <a href="classpvr_1_1utils_1_1_model_gles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_on_screen_objects.html">OnScreenObjects</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packaging for Swapchain, on screen Framebuffers, Renderpass, Attachments. Returned by createSwapchainRenderpassFramebuffers  <a href="structpvr_1_1utils_1_1_on_screen_objects.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html">QueueAccessInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating the family id and queue id of a particular queue retrieved via the helper function 'createDeviceAndQueues'. The family id corresponds to the family id the queue was retrieved from. The queue id corresponds to the particular queue index for the retrieved queue.  <a href="structpvr_1_1utils_1_1_queue_access_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html">QueuePopulateInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure encapsulating the set of queue flags required for a particular queue retrieved via the helper function 'createDeviceAndQueues'. Optionally additionally providing a surface will indicate that the queue must support presentation via the provided surface.  <a href="structpvr_1_1utils_1_1_queue_populate_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_r_t_instance.html">RTInstance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about each scene element that can be ray traced at high level (instance).  <a href="structpvr_1_1utils_1_1_r_t_instance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_r_t_model_info.html">RTModelInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information per bottom level acceleration structure element.  <a href="structpvr_1_1utils_1_1_r_t_model_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_scene_description.html">SceneDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to store scene instance elements information, will be copied to a GPU buffer.  <a href="structpvr_1_1utils_1_1_scene_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html">StructuredBufferView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structured buffer view is a class that can be used to define an explicit structure to an object that is usually accessed as raw memory. For example, a GPU-side buffer is mapped to a void pointer, but a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a> can be used to create a runtime structure for it, and set its entries one by one. Example usage for accessing a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view.html" title="A structured buffer view is a class that can be used to define an explicit structure to an object tha...">StructuredBufferView</a> defined for the buffer bonesUbo defined below: struct Bone{ highp mat4 boneMatrix; highp mat3 boneMatrixIT; }; layout(std140, binding = i) uniform bonesUbo { mediump int BoneCount; // a name or index can be used to retrieve a particular element Bone bones[]; // elementArrayIndex is used to index into an arrays of elements } boneBuffer; getElementByName("BoneCount") = boneBuffer.BoneCount getElementByName("bones") = boneBuffer.Bone[0] getElementByName("bones", 1) = boneBuffer.Bone[1]  <a href="classpvr_1_1utils_1_1_structured_buffer_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view_element.html">StructuredBufferViewElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view_element.html" title="Defines a StructuredBufferViewElement. A StructuredBufferViewElement handles the public interface use...">StructuredBufferViewElement</a>. A <a class="el" href="classpvr_1_1utils_1_1_structured_buffer_view_element.html" title="Defines a StructuredBufferViewElement. A StructuredBufferViewElement handles the public interface use...">StructuredBufferViewElement</a> handles the public interface used for working with a <a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html" title="Defines a StructuredMemoryEntry element. A StructuredMemoryEntry defines an actual element entry in a...">StructuredMemoryEntry</a>.  <a href="classpvr_1_1utils_1_1_structured_buffer_view_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_memory_description.html">StructuredMemoryDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a memory element description. The element will be provided with a name, type and number of array elements. The element itself may also contain child memory elements  <a href="classpvr_1_1utils_1_1_structured_memory_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html">StructuredMemoryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a <a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html" title="Defines a StructuredMemoryEntry element. A StructuredMemoryEntry defines an actual element entry in a...">StructuredMemoryEntry</a> element. A <a class="el" href="classpvr_1_1utils_1_1_structured_memory_entry.html" title="Defines a StructuredMemoryEntry element. A StructuredMemoryEntry defines an actual element entry in a...">StructuredMemoryEntry</a> defines an actual element entry in a structured buffer view. WARNING: Arrays of size 1 not supported - they are considered non-arrays. WARNING: Due to pointers to parents, no reallocations must <em>ever</em> happen. Once initialized, the lists must be final. WARNING: THE ENTIRE PUBLIC INTERFACE OF THIS CLASS EXCEPT FOR INIT, IS CONST. WARNING: IT IS NOT INTENDED FOR THIS CLASS TO BE EVER MODIFIABLE.  <a href="classpvr_1_1utils_1_1_structured_memory_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html">TextureUploadResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> structure provides the results for texture upload functions in a simple to use structure  <a href="structpvr_1_1utils_1_1_texture_upload_results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_attribute_info.html">VertexAttributeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a full description of a Vertex Attribute: Index, format, number of elements, offset in the buffer, optionally name. All values (except attributeName) must be set explicitly.  <a href="structpvr_1_1utils_1_1_vertex_attribute_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_attribute_info_with_binding.html">VertexAttributeInfoWithBinding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container struct carrying Vertex Attribute information (vertex layout, plus binding point)  <a href="structpvr_1_1utils_1_1_vertex_attribute_info_with_binding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.  <a href="structpvr_1_1utils_1_1_vertex_bindings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name.  <a href="structpvr_1_1utils_1_1_vertex_bindings___name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_input_binding_info.html">VertexInputBindingInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a Buffer binding: Binding index, stride, (instance) step rate.  <a href="structpvr_1_1utils_1_1_vertex_input_binding_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html" title="The VulkanVersion structure provides an easy mechanism for constructing the Vulkan version for use wh...">VulkanVersion</a> structure provides an easy mechanism for constructing the Vulkan version for use when creating a Vulkan instance.  <a href="structpvr_1_1utils_1_1_vulkan_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a990a2454c0ddfb8bf5383a11262a76ec"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; async::IFrameworkAsyncResult&lt; pvrvk::ImageView &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a990a2454c0ddfb8bf5383a11262a76ec">AsyncApiTexture</a></td></tr>
<tr class="memdesc:a990a2454c0ddfb8bf5383a11262a76ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference counted pointer to a IFrameworkAsyncResult specialised by an ImageView which will be used as the main interface for using API specific asynchronous textures.  <a href="namespacepvr_1_1utils.html#a990a2454c0ddfb8bf5383a11262a76ec">More...</a><br /></td></tr>
<tr class="separator:a990a2454c0ddfb8bf5383a11262a76ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bd78a7c682d6b8161db1db04f1f910"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; async::IFrameworkAsyncResult&lt; <a class="el" href="namespacepvr_1_1utils.html#adbd0dc78bf662b222b9e01a5efb6c778">TexturePtr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a54bd78a7c682d6b8161db1db04f1f910">AsyncTexture</a></td></tr>
<tr class="memdesc:a54bd78a7c682d6b8161db1db04f1f910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference counted pointer to a IFrameworkAsyncResult specialised by a TexturePtr which will be used as the main interface for using API agnostic asynchronous textures.  <a href="namespacepvr_1_1utils.html#a54bd78a7c682d6b8161db1db04f1f910">More...</a><br /></td></tr>
<tr class="separator:a54bd78a7c682d6b8161db1db04f1f910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab251744ba4295771d35ea8f3ee497e0f"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="structpvr_1_1utils_1_1_image_upload_future__.html">ImageUploadFuture_</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab251744ba4295771d35ea8f3ee497e0f">ImageUploadFuture</a></td></tr>
<tr class="memdesc:ab251744ba4295771d35ea8f3ee497e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ref-counted pointer to a Future of an Image Upload: A class that wraps the texture that "is being uploaded on a separate thread", together with functions to "query if the upload is yet complete" and to "block until the upload is complete, if necessary, and return the result"  <a href="namespacepvr_1_1utils.html#ab251744ba4295771d35ea8f3ee497e0f">More...</a><br /></td></tr>
<tr class="separator:ab251744ba4295771d35ea8f3ee497e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd0dc78bf662b222b9e01a5efb6c778"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; Texture &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#adbd0dc78bf662b222b9e01a5efb6c778">TexturePtr</a></td></tr>
<tr class="memdesc:adbd0dc78bf662b222b9e01a5efb6c778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference counted pointer to a pvr::Texture which will be used for loading API agnostic texture data to disk.  <a href="namespacepvr_1_1utils.html#adbd0dc78bf662b222b9e01a5efb6c778">More...</a><br /></td></tr>
<tr class="separator:adbd0dc78bf662b222b9e01a5efb6c778"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a100ef068316423d649e18a3a2168aacb"><td class="memTemplParams" colspan="2">template&lt;typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:a100ef068316423d649e18a3a2168aacb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a100ef068316423d649e18a3a2168aacb">appendSingleBuffersFromModel</a> (pvrvk::Device &amp;device, const assets::Model &amp;model, VboContainer_ &amp;vbos, IboContainer_ &amp;ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> bufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a100ef068316423d649e18a3a2168aacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user.  <a href="namespacepvr_1_1utils.html#a100ef068316423d649e18a3a2168aacb">More...</a><br /></td></tr>
<tr class="separator:a100ef068316423d649e18a3a2168aacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab62f121a7b8a9d790ca4e4e3dfcff0aa">beginCommandBufferDebugLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.  <a href="namespacepvr_1_1utils.html#ab62f121a7b8a9d790ca4e4e3dfcff0aa">More...</a><br /></td></tr>
<tr class="separator:ab62f121a7b8a9d790ca4e4e3dfcff0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f241ba112200732fffaeb2906b6ed4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">beginCommandBufferDebugLabel</a> (pvrvk::CommandBufferBase commandBufferBase, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a3f241ba112200732fffaeb2906b6ed4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.  <a href="namespacepvr_1_1utils.html#a3f241ba112200732fffaeb2906b6ed4b">More...</a><br /></td></tr>
<tr class="separator:a3f241ba112200732fffaeb2906b6ed4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dc67a22e33dc6bf735edc27a1432ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a45dc67a22e33dc6bf735edc27a1432ef">beginCommandBufferDebugLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a45dc67a22e33dc6bf735edc27a1432ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this secondary command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.  <a href="namespacepvr_1_1utils.html#a45dc67a22e33dc6bf735edc27a1432ef">More...</a><br /></td></tr>
<tr class="separator:a45dc67a22e33dc6bf735edc27a1432ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaec27096b06e097a3ead372e30c68c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7eaec27096b06e097a3ead372e30c68c">beginQueueDebugLabel</a> (pvrvk::Queue queue, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a7eaec27096b06e097a3ead372e30c68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this queue. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.  <a href="namespacepvr_1_1utils.html#a7eaec27096b06e097a3ead372e30c68c">More...</a><br /></td></tr>
<tr class="separator:a7eaec27096b06e097a3ead372e30c68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f76f7564d0c8100418857026db23840"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4f76f7564d0c8100418857026db23840">captureImageRegion</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Image &amp;image, pvrvk::Offset3D srcOffset=pvrvk::Offset3D(0, 0, 0), pvrvk::Extent3D srcExtent=pvrvk::Extent3D(static_cast&lt; uint32_t &gt;(-1), static_cast&lt; uint32_t &gt;(-1), static_cast&lt; uint32_t &gt;(-1)), pvrvk::Format destinationImageFormat=pvrvk::Format::e_UNDEFINED, pvrvk::ImageLayout imageInitialLayout=pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL, pvrvk::ImageLayout imageFinalLayout=pvrvk::ImageLayout::e_TRANSFER_DST_OPTIMAL, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> bufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr)</td></tr>
<tr class="memdesc:a4f76f7564d0c8100418857026db23840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves and returns the contents of a particular image region. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set.  <a href="namespacepvr_1_1utils.html#a4f76f7564d0c8100418857026db23840">More...</a><br /></td></tr>
<tr class="separator:a4f76f7564d0c8100418857026db23840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafce526b759924e9114572d863b5b8f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aafce526b759924e9114572d863b5b8f6">checkApiError</a> (std::string *errOutStr=NULL)</td></tr>
<tr class="memdesc:aafce526b759924e9114572d863b5b8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and returns api error if appropriate.  <a href="namespacepvr_1_1utils.html#aafce526b759924e9114572d863b5b8f6">More...</a><br /></td></tr>
<tr class="separator:aafce526b759924e9114572d863b5b8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ca18b411c83be99cc9b83137cef4d8"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a20ca18b411c83be99cc9b83137cef4d8">convertToGles</a> (BlendFactor blendFactor)</td></tr>
<tr class="memdesc:a20ca18b411c83be99cc9b83137cef4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl blend factor output.  <a href="namespacepvr_1_1utils.html#a20ca18b411c83be99cc9b83137cef4d8">More...</a><br /></td></tr>
<tr class="separator:a20ca18b411c83be99cc9b83137cef4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe32fb89dfe5e37513af651055cdef15"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#afe32fb89dfe5e37513af651055cdef15">convertToGles</a> (BlendOp blendOp)</td></tr>
<tr class="memdesc:afe32fb89dfe5e37513af651055cdef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl blend op output.  <a href="namespacepvr_1_1utils.html#afe32fb89dfe5e37513af651055cdef15">More...</a><br /></td></tr>
<tr class="separator:afe32fb89dfe5e37513af651055cdef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196375d06b5173798e46037c7b8eb890"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a196375d06b5173798e46037c7b8eb890">convertToGles</a> (CompareOp func)</td></tr>
<tr class="memdesc:a196375d06b5173798e46037c7b8eb890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl comparison mode.  <a href="namespacepvr_1_1utils.html#a196375d06b5173798e46037c7b8eb890">More...</a><br /></td></tr>
<tr class="separator:a196375d06b5173798e46037c7b8eb890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86cd8604c6d3c155b531d7a1784581f"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad86cd8604c6d3c155b531d7a1784581f">convertToGles</a> (DataType dataType)</td></tr>
<tr class="memdesc:ad86cd8604c6d3c155b531d7a1784581f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl data type.  <a href="namespacepvr_1_1utils.html#ad86cd8604c6d3c155b531d7a1784581f">More...</a><br /></td></tr>
<tr class="separator:ad86cd8604c6d3c155b531d7a1784581f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfe42ed26ab9fcb99118de82013eedb"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aabfe42ed26ab9fcb99118de82013eedb">convertToGles</a> (Face face)</td></tr>
<tr class="memdesc:aabfe42ed26ab9fcb99118de82013eedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl face.  <a href="namespacepvr_1_1utils.html#aabfe42ed26ab9fcb99118de82013eedb">More...</a><br /></td></tr>
<tr class="separator:aabfe42ed26ab9fcb99118de82013eedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648788eddea6a26479db4a04cdeedf55"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a648788eddea6a26479db4a04cdeedf55">convertToGles</a> (ImageAspectFlags type)</td></tr>
<tr class="memdesc:a648788eddea6a26479db4a04cdeedf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to an opengl image aspect type.  <a href="namespacepvr_1_1utils.html#a648788eddea6a26479db4a04cdeedf55">More...</a><br /></td></tr>
<tr class="separator:a648788eddea6a26479db4a04cdeedf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d36f28640fc36caaed25f8935a48229"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7d36f28640fc36caaed25f8935a48229">convertToGles</a> (ImageViewType texType)</td></tr>
<tr class="memdesc:a7d36f28640fc36caaed25f8935a48229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl texture type.  <a href="namespacepvr_1_1utils.html#a7d36f28640fc36caaed25f8935a48229">More...</a><br /></td></tr>
<tr class="separator:a7d36f28640fc36caaed25f8935a48229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b92cb613310549a5b748d1f5c4b4557"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7b92cb613310549a5b748d1f5c4b4557">convertToGles</a> (IndexType type)</td></tr>
<tr class="memdesc:a7b92cb613310549a5b748d1f5c4b4557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts from a pvr::IndexType to its OpenGL ES GLenum counterpart.  <a href="namespacepvr_1_1utils.html#a7b92cb613310549a5b748d1f5c4b4557">More...</a><br /></td></tr>
<tr class="separator:a7b92cb613310549a5b748d1f5c4b4557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf730a0573373abb18dcefa9390e840"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2cf730a0573373abb18dcefa9390e840">convertToGles</a> (PolygonWindingOrder windingOrder)</td></tr>
<tr class="memdesc:a2cf730a0573373abb18dcefa9390e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl winding-order.  <a href="namespacepvr_1_1utils.html#a2cf730a0573373abb18dcefa9390e840">More...</a><br /></td></tr>
<tr class="separator:a2cf730a0573373abb18dcefa9390e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4848cd91db829306bc8a1ed929762aad"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4848cd91db829306bc8a1ed929762aad">convertToGles</a> (PrimitiveTopology primitiveType)</td></tr>
<tr class="memdesc:a4848cd91db829306bc8a1ed929762aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl priitive type.  <a href="namespacepvr_1_1utils.html#a4848cd91db829306bc8a1ed929762aad">More...</a><br /></td></tr>
<tr class="separator:a4848cd91db829306bc8a1ed929762aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c41ff094638c4216cb39bf821408fe5"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3c41ff094638c4216cb39bf821408fe5">convertToGles</a> (SamplerAddressMode addressMode)</td></tr>
<tr class="memdesc:a3c41ff094638c4216cb39bf821408fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl sampler wrap.  <a href="namespacepvr_1_1utils.html#a3c41ff094638c4216cb39bf821408fe5">More...</a><br /></td></tr>
<tr class="separator:a3c41ff094638c4216cb39bf821408fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dc4d95376bb577dd85455028527815"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af1dc4d95376bb577dd85455028527815">convertToGles</a> (StencilOp stencilOp)</td></tr>
<tr class="memdesc:af1dc4d95376bb577dd85455028527815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to opengl stencil op output.  <a href="namespacepvr_1_1utils.html#af1dc4d95376bb577dd85455028527815">More...</a><br /></td></tr>
<tr class="separator:af1dc4d95376bb577dd85455028527815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf411047de1c9b93006e248404d156cd"><td class="memItemLeft" align="right" valign="top">pvrvk::PipelineColorBlendAttachmentState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#abf411047de1c9b93006e248404d156cd">convertToPVRVk</a> (const BlendingConfig &amp;config)</td></tr>
<tr class="memdesc:abf411047de1c9b93006e248404d156cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk PipelineColorBlendAttachmentState  <a href="namespacepvr_1_1utils.html#abf411047de1c9b93006e248404d156cd">More...</a><br /></td></tr>
<tr class="separator:abf411047de1c9b93006e248404d156cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1015e60258a9b1ea86213471275c8955"><td class="memItemLeft" align="right" valign="top">pvrvk::Extent2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1015e60258a9b1ea86213471275c8955">convertToPVRVk</a> (const Extent2D &amp;extent)</td></tr>
<tr class="memdesc:a1015e60258a9b1ea86213471275c8955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk Extent2D  <a href="namespacepvr_1_1utils.html#a1015e60258a9b1ea86213471275c8955">More...</a><br /></td></tr>
<tr class="separator:a1015e60258a9b1ea86213471275c8955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5b7760e47f22fd546b6eabfcae3b62"><td class="memItemLeft" align="right" valign="top">pvrvk::Extent3D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3e5b7760e47f22fd546b6eabfcae3b62">convertToPVRVk</a> (const Extent3D &amp;extent)</td></tr>
<tr class="memdesc:a3e5b7760e47f22fd546b6eabfcae3b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk Extent3D  <a href="namespacepvr_1_1utils.html#a3e5b7760e47f22fd546b6eabfcae3b62">More...</a><br /></td></tr>
<tr class="separator:a3e5b7760e47f22fd546b6eabfcae3b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3116f95a85b64265c0b26ce81df895cd"><td class="memItemLeft" align="right" valign="top">pvrvk::Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3116f95a85b64265c0b26ce81df895cd">convertToPVRVk</a> (const ImageDataFormat &amp;format)</td></tr>
<tr class="memdesc:a3116f95a85b64265c0b26ce81df895cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk pixel format  <a href="namespacepvr_1_1utils.html#a3116f95a85b64265c0b26ce81df895cd">More...</a><br /></td></tr>
<tr class="separator:a3116f95a85b64265c0b26ce81df895cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251d0fffcee64a05e2619a02b52b109e"><td class="memItemLeft" align="right" valign="top">pvrvk::Offset2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a251d0fffcee64a05e2619a02b52b109e">convertToPVRVk</a> (const Offset2D &amp;offset)</td></tr>
<tr class="memdesc:a251d0fffcee64a05e2619a02b52b109e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk Offset2D  <a href="namespacepvr_1_1utils.html#a251d0fffcee64a05e2619a02b52b109e">More...</a><br /></td></tr>
<tr class="separator:a251d0fffcee64a05e2619a02b52b109e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6b94f99d8533786ba3eb16f4e694a"><td class="memItemLeft" align="right" valign="top">pvrvk::Offset3D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7ae6b94f99d8533786ba3eb16f4e694a">convertToPVRVk</a> (const Offset3D &amp;offset)</td></tr>
<tr class="memdesc:a7ae6b94f99d8533786ba3eb16f4e694a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk Offset3D  <a href="namespacepvr_1_1utils.html#a7ae6b94f99d8533786ba3eb16f4e694a">More...</a><br /></td></tr>
<tr class="separator:a7ae6b94f99d8533786ba3eb16f4e694a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c490851508a5e8618c5f6e15b3cae0"><td class="memItemLeft" align="right" valign="top">pvrvk::StencilOpState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af9c490851508a5e8618c5f6e15b3cae0">convertToPVRVk</a> (const StencilState &amp;op)</td></tr>
<tr class="memdesc:af9c490851508a5e8618c5f6e15b3cae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk StencilOpState  <a href="namespacepvr_1_1utils.html#af9c490851508a5e8618c5f6e15b3cae0">More...</a><br /></td></tr>
<tr class="separator:af9c490851508a5e8618c5f6e15b3cae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980064e6fd1ed7293c5b04941625bccf"><td class="memItemLeft" align="right" valign="top">pvrvk::VertexInputAttributeDescription&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a980064e6fd1ed7293c5b04941625bccf">convertToPVRVk</a> (const <a class="el" href="structpvr_1_1utils_1_1_vertex_attribute_info.html">VertexAttributeInfo</a> &amp;info, uint32_t binding)</td></tr>
<tr class="memdesc:a980064e6fd1ed7293c5b04941625bccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk VertexInputAttributeDescription  <a href="namespacepvr_1_1utils.html#a980064e6fd1ed7293c5b04941625bccf">More...</a><br /></td></tr>
<tr class="separator:a980064e6fd1ed7293c5b04941625bccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85935527bc9b1766c64a889a5194f405"><td class="memItemLeft" align="right" valign="top">pvrvk::VertexInputBindingDescription&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a85935527bc9b1766c64a889a5194f405">convertToPVRVk</a> (const <a class="el" href="structpvr_1_1utils_1_1_vertex_input_binding_info.html">VertexInputBindingInfo</a> &amp;info)</td></tr>
<tr class="memdesc:a85935527bc9b1766c64a889a5194f405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk VertexInputBindingDescription  <a href="namespacepvr_1_1utils.html#a85935527bc9b1766c64a889a5194f405">More...</a><br /></td></tr>
<tr class="separator:a85935527bc9b1766c64a889a5194f405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8e829e93a104391248c513aeabe8d3"><td class="memItemLeft" align="right" valign="top">pvrvk::DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ada8e829e93a104391248c513aeabe8d3">convertToPVRVk</a> (DataType dataType)</td></tr>
<tr class="memdesc:ada8e829e93a104391248c513aeabe8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk Data type  <a href="namespacepvr_1_1utils.html#ada8e829e93a104391248c513aeabe8d3">More...</a><br /></td></tr>
<tr class="separator:ada8e829e93a104391248c513aeabe8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4535ea5342874964d50833bfa20221c"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageViewType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac4535ea5342874964d50833bfa20221c">convertToPVRVk</a> (ImageViewType texDimemsion)</td></tr>
<tr class="memdesc:ac4535ea5342874964d50833bfa20221c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk image view type  <a href="namespacepvr_1_1utils.html#ac4535ea5342874964d50833bfa20221c">More...</a><br /></td></tr>
<tr class="separator:ac4535ea5342874964d50833bfa20221c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6faa52cbc7bd9bc2ff02b680ca3c869d"><td class="memItemLeft" align="right" valign="top">pvrvk::IndexType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6faa52cbc7bd9bc2ff02b680ca3c869d">convertToPVRVk</a> (IndexType type)</td></tr>
<tr class="memdesc:a6faa52cbc7bd9bc2ff02b680ca3c869d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pvr::IndexType to its Native, Vulkan representation.  <a href="namespacepvr_1_1utils.html#a6faa52cbc7bd9bc2ff02b680ca3c869d">More...</a><br /></td></tr>
<tr class="separator:a6faa52cbc7bd9bc2ff02b680ca3c869d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0492010765906fc6787a7e2498ba57c"><td class="memItemLeft" align="right" valign="top">pvrvk::VertexInputRate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae0492010765906fc6787a7e2498ba57c">convertToPVRVk</a> (StepRate stepRate)</td></tr>
<tr class="memdesc:ae0492010765906fc6787a7e2498ba57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk vertex input rate  <a href="namespacepvr_1_1utils.html#ae0492010765906fc6787a7e2498ba57c">More...</a><br /></td></tr>
<tr class="separator:ae0492010765906fc6787a7e2498ba57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745663053f1f1c98e457ce71a8b0048a"><td class="memItemLeft" align="right" valign="top">pvrvk::SamplerMipmapMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a745663053f1f1c98e457ce71a8b0048a">convertToPVRVkMipmapMode</a> (Filter filter)</td></tr>
<tr class="memdesc:a745663053f1f1c98e457ce71a8b0048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk sampler mip-map mode  <a href="namespacepvr_1_1utils.html#a745663053f1f1c98e457ce71a8b0048a">More...</a><br /></td></tr>
<tr class="separator:a745663053f1f1c98e457ce71a8b0048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6a1fc2c108c439d57cb44f189099aa"><td class="memItemLeft" align="right" valign="top">pvrvk::SampleCountFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acb6a1fc2c108c439d57cb44f189099aa">convertToPVRVkNumSamples</a> (uint8_t numSamples)</td></tr>
<tr class="memdesc:acb6a1fc2c108c439d57cb44f189099aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk sample count  <a href="namespacepvr_1_1utils.html#acb6a1fc2c108c439d57cb44f189099aa">More...</a><br /></td></tr>
<tr class="separator:acb6a1fc2c108c439d57cb44f189099aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d459b2f7cdcedd6fc8ae939064dae1d"><td class="memItemLeft" align="right" valign="top">pvrvk::Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7d459b2f7cdcedd6fc8ae939064dae1d">convertToPVRVkPixelFormat</a> (PixelFormat format, ColorSpace colorSpace, VariableType dataType)</td></tr>
<tr class="memdesc:a7d459b2f7cdcedd6fc8ae939064dae1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk pixel format  <a href="namespacepvr_1_1utils.html#a7d459b2f7cdcedd6fc8ae939064dae1d">More...</a><br /></td></tr>
<tr class="separator:a7d459b2f7cdcedd6fc8ae939064dae1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5985423e5f61cf77204a1157fa4783f1"><td class="memItemLeft" align="right" valign="top">pvrvk::Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5985423e5f61cf77204a1157fa4783f1">convertToPVRVkPixelFormat</a> (PixelFormat format, ColorSpace colorSpace, VariableType dataType, bool &amp;outIsCompressedFormat)</td></tr>
<tr class="memdesc:a5985423e5f61cf77204a1157fa4783f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk pixel format  <a href="namespacepvr_1_1utils.html#a5985423e5f61cf77204a1157fa4783f1">More...</a><br /></td></tr>
<tr class="separator:a5985423e5f61cf77204a1157fa4783f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116badc6ed0a108f3cc8ea515283a458"><td class="memItemLeft" align="right" valign="top">pvrvk::Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a116badc6ed0a108f3cc8ea515283a458">convertToPVRVkVertexInputFormat</a> (DataType dataType, uint8_t width)</td></tr>
<tr class="memdesc:a116badc6ed0a108f3cc8ea515283a458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to pvrvk format  <a href="namespacepvr_1_1utils.html#a116badc6ed0a108f3cc8ea515283a458">More...</a><br /></td></tr>
<tr class="separator:a116badc6ed0a108f3cc8ea515283a458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad0c9ce4267ec635305fc87aba0b9d9c2">create3dPlaneMesh</a> (uint32_t width, uint32_t depth, bool generateTexCoords, bool generateNormalCoords, assets::Mesh &amp;outMesh)</td></tr>
<tr class="memdesc:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3d plane mesh based on the width and depth specified. Texture coordinates and normal coordinates can also optionally be generated based on the generateTexCoords and generateNormalCoords flags respectively. The generated mesh will be returned as a pvr::assets::Mesh.  <a href="namespacepvr_1_1utils.html#ad0c9ce4267ec635305fc87aba0b9d9c2">More...</a><br /></td></tr>
<tr class="separator:ad0c9ce4267ec635305fc87aba0b9d9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4933d5feabd4336b9023ba4b7fcd50f5"><td class="memItemLeft" align="right" valign="top">pvrvk::Buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4933d5feabd4336b9023ba4b7fcd50f5">createBuffer</a> (const pvrvk::Device &amp;device, const pvrvk::BufferCreateInfo &amp;createInfo, pvrvk::MemoryPropertyFlags requiredMemoryFlags, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, const <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> &amp;bufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT, pvrvk::MemoryAllocateFlags memoryAllocateFlags=pvrvk::MemoryAllocateFlags::e_NONE)</td></tr>
<tr class="memdesc:a4933d5feabd4336b9023ba4b7fcd50f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer object and (optionally) allocate and bind memory for it  <a href="namespacepvr_1_1utils.html#a4933d5feabd4336b9023ba4b7fcd50f5">More...</a><br /></td></tr>
<tr class="separator:a4933d5feabd4336b9023ba4b7fcd50f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af92cf8d09982258386f5cc4e6f2f80"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7af92cf8d09982258386f5cc4e6f2f80">createComputeShaderProgram</a> (IAssetProvider &amp;app, const char *compShaderFilename, const char *const *defines=0, uint32_t numDefines=0)</td></tr>
<tr class="memdesc:a7af92cf8d09982258386f5cc4e6f2f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a native shader program from a compute shader  <a href="namespacepvr_1_1utils.html#a7af92cf8d09982258386f5cc4e6f2f80">More...</a><br /></td></tr>
<tr class="separator:a7af92cf8d09982258386f5cc4e6f2f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">DebugUtilsCallbacks</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3c7a82ad08f5f77c574a75fc1c4eca9a">createDebugUtilsCallbacks</a> (pvrvk::Instance &amp;instance)</td></tr>
<tr class="memdesc:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a default set of debug utils messengers or debug callbacks using either VK_EXT_debug_utils or VK_EXT_debug_report respectively. The first callback will trigger an exception to be thrown when an error message is returned. The second callback will Log a message for errors and warnings.  <a href="namespacepvr_1_1utils.html#a3c7a82ad08f5f77c574a75fc1c4eca9a">More...</a><br /></td></tr>
<tr class="separator:a3c7a82ad08f5f77c574a75fc1c4eca9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9424bfa72230f6de076797e8a9c018"><td class="memItemLeft" align="right" valign="top">std::vector&lt; pvrvk::ImageView &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5f9424bfa72230f6de076797e8a9c018">createDepthStencilImageAndViews</a> (const pvrvk::Device &amp;device, int32_t imageCount, pvrvk::Format depthFormat, const pvrvk::Extent2D &amp;imageExtent, const pvrvk::ImageUsageFlags &amp;imageUsageFlags=pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT, pvrvk::SampleCountFlags sampleCount=pvrvk::SampleCountFlags::e_1_BIT, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> dsImageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> dsImageAllocationCreateFlags=vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT)</td></tr>
<tr class="memdesc:a5f9424bfa72230f6de076797e8a9c018"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED. Use createAttachmentImages instead  <a href="namespacepvr_1_1utils.html#a5f9424bfa72230f6de076797e8a9c018">More...</a><br /></td></tr>
<tr class="separator:a5f9424bfa72230f6de076797e8a9c018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34226196d1cd435e8f19abecc2d3b0eb"><td class="memItemLeft" align="right" valign="top">pvrvk::Device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a34226196d1cd435e8f19abecc2d3b0eb">createDeviceAndQueues</a> (pvrvk::PhysicalDevice physicalDevice, const <a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html">QueuePopulateInfo</a> *queueCreateInfos, uint32_t numQueueCreateInfos, <a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html">QueueAccessInfo</a> *outAccessInfo, const <a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a> &amp;deviceExtensions=<a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a>())</td></tr>
<tr class="memdesc:a34226196d1cd435e8f19abecc2d3b0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the pvrvk::Device and the queues  <a href="namespacepvr_1_1utils.html#a34226196d1cd435e8f19abecc2d3b0eb">More...</a><br /></td></tr>
<tr class="separator:a34226196d1cd435e8f19abecc2d3b0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadbbd98fbeac18389e58b089db81e73"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aeadbbd98fbeac18389e58b089db81e73">createImage</a> (const pvrvk::Device &amp;device, const pvrvk::ImageCreateInfo &amp;createInfo, pvrvk::MemoryPropertyFlags requiredMemoryFlags=pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT, pvrvk::MemoryPropertyFlags optimalMemoryFlags=pvrvk::MemoryPropertyFlags::e_NONE, const <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> &amp;imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:aeadbbd98fbeac18389e58b089db81e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new Image(sparse or with memory backing, depending on <em>flags</em> . The user should not call bindMemory on the image if sparse flags are used. <em>requiredMemoryFlags</em>  is ignored if <em>flags</em>  contains sparse binding flags.  <a href="namespacepvr_1_1utils.html#aeadbbd98fbeac18389e58b089db81e73">More...</a><br /></td></tr>
<tr class="separator:aeadbbd98fbeac18389e58b089db81e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680ef5943947e565f7d14aa9ff0393d9"><td class="memItemLeft" align="right" valign="top">pvrvk::Instance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a680ef5943947e565f7d14aa9ff0393d9">createInstance</a> (const std::string &amp;applicationName, <a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a> apiVersion=<a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a>(), const <a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a> &amp;instanceExtensions=<a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a>(), const <a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a> &amp;instanceLayers=<a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a>())</td></tr>
<tr class="memdesc:a680ef5943947e565f7d14aa9ff0393d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for creating a Vulkan instance and supported physical devices using the appropriately set parameters.  <a href="namespacepvr_1_1utils.html#a680ef5943947e565f7d14aa9ff0393d9">More...</a><br /></td></tr>
<tr class="separator:a680ef5943947e565f7d14aa9ff0393d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0791bbf3f9ee51623e57639997a3238c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a0791bbf3f9ee51623e57639997a3238c">createMultipleBuffersFromMesh</a> (pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, std::vector&lt; pvrvk::Buffer &gt; &amp;outVbos, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> bufferAllocator, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a0791bbf3f9ee51623e57639997a3238c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh.  <a href="namespacepvr_1_1utils.html#a0791bbf3f9ee51623e57639997a3238c">More...</a><br /></td></tr>
<tr class="separator:a0791bbf3f9ee51623e57639997a3238c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada646be2dd95421863b51714591825cf"><td class="memItemLeft" align="right" valign="top">pvrvk::RenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ada646be2dd95421863b51714591825cf">createOnscreenFramebufferAndRenderPass</a> (const pvrvk::Swapchain &amp;swapchain, pvrvk::ImageView *depthStencilImages, <a class="el" href="classpvr_1_1_multi.html">Multi</a>&lt; pvrvk::Framebuffer &gt; &amp;outFramebuffers, pvrvk::ImageLayout initialSwapchainLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::AttachmentLoadOp colorLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp colorStoreOp=pvrvk::AttachmentStoreOp::e_STORE, pvrvk::AttachmentLoadOp depthStencilLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp depthStencilStoreOp=pvrvk::AttachmentStoreOp::e_DONT_CARE)</td></tr>
<tr class="memdesc:ada646be2dd95421863b51714591825cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED  <a href="namespacepvr_1_1utils.html#ada646be2dd95421863b51714591825cf">More...</a><br /></td></tr>
<tr class="separator:ada646be2dd95421863b51714591825cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba79655d85e1b12e2fa33fe431533cb"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:aaba79655d85e1b12e2fa33fe431533cb"><td class="memTemplItemLeft" align="right" valign="top">ContainerType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aaba79655d85e1b12e2fa33fe431533cb">createOnscreenFramebuffers</a> (const pvrvk::Swapchain &amp;swapchain, const pvrvk::RenderPass &amp;renderPass, const pvrvk::ImageView *depthStencilImages, pvrvk::ImageView *colorMultisampledImages, pvrvk::ImageView *depthStencilMultisampledImages)</td></tr>
<tr class="separator:aaba79655d85e1b12e2fa33fe431533cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0324a015a6d6d4df8b7caa525416ff89"><td class="memItemLeft" align="right" valign="top">pvrvk::RenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a0324a015a6d6d4df8b7caa525416ff89">createOnScreenRenderPass</a> (const pvrvk::Swapchain &amp;swapchain, bool hasDepthStencil, const pvrvk::Format depthStencilFormat=pvrvk::Format::e_UNDEFINED, pvrvk::ImageLayout initialSwapchainLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::ImageLayout initialDepthStencilLayout=pvrvk::ImageLayout::e_UNDEFINED, pvrvk::AttachmentLoadOp colorLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp colorStoreOp=pvrvk::AttachmentStoreOp::e_STORE, pvrvk::AttachmentLoadOp depthStencilLoadOp=pvrvk::AttachmentLoadOp::e_CLEAR, pvrvk::AttachmentStoreOp depthStencilStoreOp=pvrvk::AttachmentStoreOp::e_DONT_CARE, pvrvk::SampleCountFlags samples=pvrvk::SampleCountFlags::e_1_BIT)</td></tr>
<tr class="memdesc:a0324a015a6d6d4df8b7caa525416ff89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a renderpass for On-Screen (or other swapchain-based) rendering, based on the information contained in the swapchain. No other objects, (such as framebuffers and attachments) are created.  <a href="namespacepvr_1_1utils.html#a0324a015a6d6d4df8b7caa525416ff89">More...</a><br /></td></tr>
<tr class="separator:a0324a015a6d6d4df8b7caa525416ff89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270a77975b4db20cad82e6974a065a6d"><td class="memItemLeft" align="right" valign="top">pvrvk::ShaderModule&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a270a77975b4db20cad82e6974a065a6d">createShaderModule</a> (pvrvk::Device &amp;device, const Stream &amp;shaderSource, pvrvk::ShaderStageFlags shaderStageFlags, pvrvk::ShaderModuleCreateFlags flags=pvrvk::ShaderModuleCreateFlags::e_NONE, const char *const *defines=nullptr, uint32_t numDefines=0)</td></tr>
<tr class="memdesc:a270a77975b4db20cad82e6974a065a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a ShaderModule from shader source using glslang.  <a href="namespacepvr_1_1utils.html#a270a77975b4db20cad82e6974a065a6d">More...</a><br /></td></tr>
<tr class="separator:a270a77975b4db20cad82e6974a065a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c8c338b47c9a66f58a39feb29c9fbe"><td class="memItemLeft" align="right" valign="top">pvrvk::ShaderModule&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a55c8c338b47c9a66f58a39feb29c9fbe">createShaderModule</a> (pvrvk::Device &amp;device, std::string &amp;shaderSource, pvrvk::ShaderStageFlags shaderStageFlags, pvrvk::ShaderModuleCreateFlags flags=pvrvk::ShaderModuleCreateFlags::e_NONE, const char *const *defines=nullptr, uint32_t numDefines=0)</td></tr>
<tr class="memdesc:a55c8c338b47c9a66f58a39feb29c9fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a ShaderModule from shader source using glslang.  <a href="namespacepvr_1_1utils.html#a55c8c338b47c9a66f58a39feb29c9fbe">More...</a><br /></td></tr>
<tr class="separator:a55c8c338b47c9a66f58a39feb29c9fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af094283fa2ed1a4434130f9eaf16feb6"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af094283fa2ed1a4434130f9eaf16feb6">createShaderProgram</a> (const GLuint pShaders[], uint32_t shadersCount, const char **const attribNames, const uint16_t *attribIndices, uint32_t attribsCount, std::string *infolog=NULL)</td></tr>
<tr class="memdesc:af094283fa2ed1a4434130f9eaf16feb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a native shader program from an array of native shader handles. Will implicitly load on the current context.  <a href="namespacepvr_1_1utils.html#af094283fa2ed1a4434130f9eaf16feb6">More...</a><br /></td></tr>
<tr class="separator:af094283fa2ed1a4434130f9eaf16feb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231b8395183676eeba042c9ee74e7409"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a231b8395183676eeba042c9ee74e7409">createShaderProgram</a> (const IAssetProvider &amp;app, const char *vertShaderFilename, const char *fragShaderFilename, const char **attribNames, const uint16_t *attribIndices, uint32_t numAttribs, const char *const *defines=0, uint32_t numDefines=0)</td></tr>
<tr class="memdesc:a231b8395183676eeba042c9ee74e7409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a native shader program from a vertex and fragment shader  <a href="namespacepvr_1_1utils.html#a231b8395183676eeba042c9ee74e7409">More...</a><br /></td></tr>
<tr class="separator:a231b8395183676eeba042c9ee74e7409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4c1b6200d2dd8d67e20af83e4dc7cf"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a4f4c1b6200d2dd8d67e20af83e4dc7cf">createShaderProgram</a> (const IAssetProvider &amp;app, const char *vertShaderFilename, const char *tessCtrlShaderFilename, const char *tessEvalShaderFilename, const char *geometryShaderFilename, const char *fragShaderFilename, const char **attribNames, const uint16_t *attribIndices, uint32_t numAttribs, const char *const *defines=0, uint32_t numDefines=0)</td></tr>
<tr class="memdesc:a4f4c1b6200d2dd8d67e20af83e4dc7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a native shader program from a vertex, fragment, tessellation control, tessellation evaluation and geometry shader  <a href="namespacepvr_1_1utils.html#a4f4c1b6200d2dd8d67e20af83e4dc7cf">More...</a><br /></td></tr>
<tr class="separator:a4f4c1b6200d2dd8d67e20af83e4dc7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecb636ae6f2c37e90259571ba245f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aeecb636ae6f2c37e90259571ba245f3b">createSingleBuffersFromMesh</a> (pvrvk::Device &amp;device, const assets::Mesh &amp;mesh, pvrvk::Buffer &amp;outVbo, pvrvk::Buffer &amp;outIbo, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> bufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:aeecb636ae6f2c37e90259571ba245f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a single VBO and a single IBO from all the vertex data of a mesh.  <a href="namespacepvr_1_1utils.html#aeecb636ae6f2c37e90259571ba245f3b">More...</a><br /></td></tr>
<tr class="separator:aeecb636ae6f2c37e90259571ba245f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b47e0a1077b70398aad03b73ea46f6c"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:a8b47e0a1077b70398aad03b73ea46f6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8b47e0a1077b70398aad03b73ea46f6c">createSingleBuffersFromMeshes</a> (pvrvk::Device &amp;device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboContainer_ &amp;outVbos, typename VboContainer_::iterator vbos_where, IboContainer_ &amp;outIbos, typename IboContainer_::iterator ibos_where, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> bufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a8b47e0a1077b70398aad03b73ea46f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container.  <a href="namespacepvr_1_1utils.html#a8b47e0a1077b70398aad03b73ea46f6c">More...</a><br /></td></tr>
<tr class="separator:a8b47e0a1077b70398aad03b73ea46f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3726d86dbda8ccaba9ed2c300b1fbe"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a7c3726d86dbda8ccaba9ed2c300b1fbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7c3726d86dbda8ccaba9ed2c300b1fbe">createSingleBuffersFromMeshes</a> (pvrvk::Device &amp;device, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboInsertIterator_ outVbos, IboInsertIterator_ outIbos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> bufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a7c3726d86dbda8ccaba9ed2c300b1fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container.  <a href="namespacepvr_1_1utils.html#a7c3726d86dbda8ccaba9ed2c300b1fbe">More...</a><br /></td></tr>
<tr class="separator:a7c3726d86dbda8ccaba9ed2c300b1fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7710bb6fdcb3e45a8787cb4cc3f64e6c"><td class="memTemplParams" colspan="2">template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a7710bb6fdcb3e45a8787cb4cc3f64e6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7710bb6fdcb3e45a8787cb4cc3f64e6c">createSingleBuffersFromModel</a> (pvrvk::Device &amp;device, const assets::Model &amp;model, VboInsertIterator_ vbos, IboInsertIterator_ ibos, pvrvk::CommandBuffer &amp;uploadCmdBuffer, bool &amp;requiresCommandBufferSubmission, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> bufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> vmaAllocationCreateFlags=vma::AllocationCreateFlags::e_MAPPED_BIT)</td></tr>
<tr class="memdesc:a7710bb6fdcb3e45a8787cb4cc3f64e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters.  <a href="namespacepvr_1_1utils.html#a7710bb6fdcb3e45a8787cb4cc3f64e6c">More...</a><br /></td></tr>
<tr class="separator:a7710bb6fdcb3e45a8787cb4cc3f64e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3530d448cda15aea32f3395ca427957b"><td class="memItemLeft" align="right" valign="top">pvrvk::Surface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a3530d448cda15aea32f3395ca427957b">createSurface</a> (const pvrvk::Instance &amp;instance, const pvrvk::PhysicalDevice &amp;physicalDevice, void *window, void *display, void *connection)</td></tr>
<tr class="memdesc:a3530d448cda15aea32f3395ca427957b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abstract vulkan native platform surface.  <a href="namespacepvr_1_1utils.html#a3530d448cda15aea32f3395ca427957b">More...</a><br /></td></tr>
<tr class="separator:a3530d448cda15aea32f3395ca427957b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbc4fadd267c20f1464ab4d21269bbf"><td class="memItemLeft" align="right" valign="top">pvrvk::Swapchain&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1bbc4fadd267c20f1464ab4d21269bbf">createSwapchain</a> (const pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::ImageUsageFlags swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT, const std::vector&lt; pvrvk::Format &gt; &amp;preferredColorFormats=std::vector&lt; pvrvk::Format &gt;())</td></tr>
<tr class="memdesc:a1bbc4fadd267c20f1464ab4d21269bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface.  <a href="namespacepvr_1_1utils.html#a1bbc4fadd267c20f1464ab4d21269bbf">More...</a><br /></td></tr>
<tr class="separator:a1bbc4fadd267c20f1464ab4d21269bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c374ce16fadf5be9b63e3675e51585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a33c374ce16fadf5be9b63e3675e51585">createSwapchainAndDepthStencilImageAndViews</a> (const pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, pvrvk::Swapchain &amp;outSwapchain, <a class="el" href="classpvr_1_1_multi.html">Multi</a>&lt; pvrvk::ImageView &gt; &amp;outDepthStencilImages, const pvrvk::ImageUsageFlags &amp;swapchainImageUsageFlags=pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT, const pvrvk::ImageUsageFlags &amp;dsImageUsageFlags=pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT, const <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> &amp;imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> dsImageAllocationCreateFlags=vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT)</td></tr>
<tr class="memdesc:a33c374ce16fadf5be9b63e3675e51585"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED. Either use createSwapchainRenderpassFramebuffers, or createSwapchain and createAttachments  <a href="namespacepvr_1_1utils.html#a33c374ce16fadf5be9b63e3675e51585">More...</a><br /></td></tr>
<tr class="separator:a33c374ce16fadf5be9b63e3675e51585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8589ef735f2d2222a14ba470218c02af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_on_screen_objects.html">OnScreenObjects</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8589ef735f2d2222a14ba470218c02af">createSwapchainRenderpassFramebuffers</a> (const pvrvk::Device &amp;device, const pvrvk::Surface &amp;surface, pvr::DisplayAttributes &amp;displayAttributes, const <a class="el" href="structpvr_1_1utils_1_1_create_swapchain_parameters.html">CreateSwapchainParameters</a> &amp;params=<a class="el" href="structpvr_1_1utils_1_1_create_swapchain_parameters.html">CreateSwapchainParameters</a>())</td></tr>
<tr class="memdesc:a8589ef735f2d2222a14ba470218c02af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pvrvk::Framebuffer and RenderPass to use for 'default' rendering to the 'onscreen' color images. Default configuration is as follows. Formats and other configurations can be tweaked through displayAttributes and params. RenderPass: Attachment0: ColorAttachment swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store Attachment1: DepthStencilAttachment finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store If displayAttributes.aaSamples&gt;1 Multisampling will be enabled and the correct resolve attachments for multisampling will be created.  <a href="namespacepvr_1_1utils.html#a8589ef735f2d2222a14ba470218c02af">More...</a><br /></td></tr>
<tr class="separator:a8589ef735f2d2222a14ba470218c02af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da693f264b2b719a77fc84bf0a32ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2da693f264b2b719a77fc84bf0a32ec5">endCommandBufferDebugLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer)</td></tr>
<tr class="memdesc:a2da693f264b2b719a77fc84bf0a32ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this command buffer.  <a href="namespacepvr_1_1utils.html#a2da693f264b2b719a77fc84bf0a32ec5">More...</a><br /></td></tr>
<tr class="separator:a2da693f264b2b719a77fc84bf0a32ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e6adce5bcec23564fd67553c9f4088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">endCommandBufferDebugLabel</a> (pvrvk::CommandBufferBase commandBufferBase)</td></tr>
<tr class="memdesc:a12e6adce5bcec23564fd67553c9f4088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this base command buffer.  <a href="namespacepvr_1_1utils.html#a12e6adce5bcec23564fd67553c9f4088">More...</a><br /></td></tr>
<tr class="separator:a12e6adce5bcec23564fd67553c9f4088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee1c88c7937b7a16127e810b75b2ab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#adee1c88c7937b7a16127e810b75b2ab7">endCommandBufferDebugLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer)</td></tr>
<tr class="memdesc:adee1c88c7937b7a16127e810b75b2ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this secondary command buffer.  <a href="namespacepvr_1_1utils.html#adee1c88c7937b7a16127e810b75b2ab7">More...</a><br /></td></tr>
<tr class="separator:adee1c88c7937b7a16127e810b75b2ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605300322093e44b7cd509533f14b4fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a605300322093e44b7cd509533f14b4fa">endQueueDebugLabel</a> (pvrvk::Queue queue)</td></tr>
<tr class="memdesc:a605300322093e44b7cd509533f14b4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this queue.  <a href="namespacepvr_1_1utils.html#a605300322093e44b7cd509533f14b4fa">More...</a><br /></td></tr>
<tr class="separator:a605300322093e44b7cd509533f14b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bdf9f718d984f14166f6b91b254b4c"><td class="memItemLeft" align="right" valign="top">pvr::Texture&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a12bdf9f718d984f14166f6b91b254b4c">generateCookTorranceBRDFLUT</a> (uint32_t mapDim=256)</td></tr>
<tr class="memdesc:a12bdf9f718d984f14166f6b91b254b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates BRDF lookup table image.  <a href="namespacepvr_1_1utils.html#a12bdf9f718d984f14166f6b91b254b4c">More...</a><br /></td></tr>
<tr class="separator:a12bdf9f718d984f14166f6b91b254b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47a86d6668e712e353dd8aea5e984c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af47a86d6668e712e353dd8aea5e984c2">generateIrradianceMap</a> (GLuint environmentMap, pvr::Texture &amp;outTexture, GLuint &amp;outTextureGles, uint32_t mapSize=64, uint32_t mapNumSamples=128)</td></tr>
<tr class="memdesc:af47a86d6668e712e353dd8aea5e984c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mipmapped diffuse irradiance map.  <a href="namespacepvr_1_1utils.html#af47a86d6668e712e353dd8aea5e984c2">More...</a><br /></td></tr>
<tr class="separator:af47a86d6668e712e353dd8aea5e984c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24c4e93b0c93756506ebd6f2ca1b399"><td class="memItemLeft" align="right" valign="top">Texture&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab24c4e93b0c93756506ebd6f2ca1b399">generateIrradianceMap</a> (pvrvk::Queue queue, pvrvk::ImageView environmentMap, pvr::PixelFormat outputPixelFormat, pvr::VariableType outputVariableType, uint32_t mapSize=64, uint32_t mapNumSamples=16384)</td></tr>
<tr class="memdesc:ab24c4e93b0c93756506ebd6f2ca1b399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a mipmapped diffuse irradiance map.  <a href="namespacepvr_1_1utils.html#ab24c4e93b0c93756506ebd6f2ca1b399">More...</a><br /></td></tr>
<tr class="separator:ab24c4e93b0c93756506ebd6f2ca1b399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8a7f6f6edde3ee63bffd29af44b0e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#afc8a7f6f6edde3ee63bffd29af44b0e8">generatePreFilteredMapMipMapStyle</a> (GLuint environmentMap, pvr::Texture &amp;outTexture, GLuint &amp;outTextureGles, uint32_t mapSize, bool zeroRoughnessIsExternal, int numMipLevelsToDiscard, uint32_t mapNumSamples=65536)</td></tr>
<tr class="memdesc:afc8a7f6f6edde3ee63bffd29af44b0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate specular irradiance map. Each level of the specular mip map gets blurred corresponding to a roughness value from 0 to 1.0.  <a href="namespacepvr_1_1utils.html#afc8a7f6f6edde3ee63bffd29af44b0e8">More...</a><br /></td></tr>
<tr class="separator:afc8a7f6f6edde3ee63bffd29af44b0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b892efb9cd1baa5753d0d180a2d3d94"><td class="memItemLeft" align="right" valign="top">Texture&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8b892efb9cd1baa5753d0d180a2d3d94">generatePreFilteredMapMipmapStyle</a> (pvrvk::Queue queue, pvrvk::ImageView environmentMap, pvr::PixelFormat outputPixelFormat, pvr::VariableType outputVariableType, uint32_t mapSize, bool zeroRoughnessIsExternal, int numMipLevelsToDiscard, uint32_t mapNumSamples=65536)</td></tr>
<tr class="memdesc:a8b892efb9cd1baa5753d0d180a2d3d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate specular irradiance map. Each level of the specular mip map gets blurred corresponding to a roughness value from 0 to 1.0.  <a href="namespacepvr_1_1utils.html#a8b892efb9cd1baa5753d0d180a2d3d94">More...</a><br /></td></tr>
<tr class="separator:a8b892efb9cd1baa5753d0d180a2d3d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af7fff69d5da0331018f68f0d95ba8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a9af7fff69d5da0331018f68f0d95ba8a">generateTextureAtlas</a> (pvrvk::Device &amp;device, const pvrvk::Image *inputImages, pvrvk::Rect2Df *outUVs, uint32_t numImages, pvrvk::ImageLayout inputImageLayout, pvrvk::ImageView *outImageView, TextureHeader *outDescriptor, pvrvk::CommandBufferBase cmdBuffer, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a9af7fff69d5da0331018f68f0d95ba8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for generating a texture atlas based on a set of images.  <a href="namespacepvr_1_1utils.html#a9af7fff69d5da0331018f68f0d95ba8a">More...</a><br /></td></tr>
<tr class="separator:a9af7fff69d5da0331018f68f0d95ba8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ce1f5bcf625224715988176c3519a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a56ce1f5bcf625224715988176c3519a2">getColorBits</a> (pvrvk::Format format, uint32_t &amp;redBits, uint32_t &amp;greenBits, uint32_t &amp;blueBits, uint32_t &amp;alphaBits)</td></tr>
<tr class="memdesc:a56ce1f5bcf625224715988176c3519a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of color bits per pixel for the given pvrvk::Format.  <a href="namespacepvr_1_1utils.html#a56ce1f5bcf625224715988176c3519a2">More...</a><br /></td></tr>
<tr class="separator:a56ce1f5bcf625224715988176c3519a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcac1e9af1869244329d12c291200a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1bcac1e9af1869244329d12c291200a5">getDepthStencilBits</a> (pvrvk::Format format, uint32_t &amp;depthBits, uint32_t &amp;stencilBits)</td></tr>
<tr class="memdesc:a1bcac1e9af1869244329d12c291200a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of depth and stencil bits per pixel for the given pvrvk::Format.  <a href="namespacepvr_1_1utils.html#a1bcac1e9af1869244329d12c291200a5">More...</a><br /></td></tr>
<tr class="separator:a1bcac1e9af1869244329d12c291200a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811320035b806bb4e727d9ffc7f68873"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a811320035b806bb4e727d9ffc7f68873">getGlErrorString</a> (GLuint apiError)</td></tr>
<tr class="memdesc:a811320035b806bb4e727d9ffc7f68873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a string representation of an OpenGLES error code.  <a href="namespacepvr_1_1utils.html#a811320035b806bb4e727d9ffc7f68873">More...</a><br /></td></tr>
<tr class="separator:a811320035b806bb4e727d9ffc7f68873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6bbf98fde377992e9e7e0d23f38a9dcc">getMemoryTypeIndex</a> (const pvrvk::PhysicalDevice &amp;physicalDevice, const uint32_t allowedMemoryTypeBits, const pvrvk::MemoryPropertyFlags requiredMemoryProperties, const pvrvk::MemoryPropertyFlags optimalMemoryProperties, uint32_t &amp;outMemoryTypeIndex, pvrvk::MemoryPropertyFlags &amp;outMemoryPropertyFlags)</td></tr>
<tr class="memdesc:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for retrieving a memory type index for a suitable memory type which supports the memory type bits specified. If the optimal set of memory properties are supported then return the corresponding memory type index otherwise check for availablility of the required set of memory properties. This allows for implementations to optionally request the use of a more optimal set of memory properties whilst still preserving the ability to retrieve the required set of memory properties as a fallback.  <a href="namespacepvr_1_1utils.html#a6bbf98fde377992e9e7e0d23f38a9dcc">More...</a><br /></td></tr>
<tr class="separator:a6bbf98fde377992e9e7e0d23f38a9dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2d4df80d31e3e63923ab1d68152ace"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7b2d4df80d31e3e63923ab1d68152ace">getNumSamplesFromSampleCountFlags</a> (pvrvk::SampleCountFlags sampleCountFlags)</td></tr>
<tr class="memdesc:a7b2d4df80d31e3e63923ab1d68152ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert pvrvk sample count to the number of samples it is equivalent to  <a href="namespacepvr_1_1utils.html#a7b2d4df80d31e3e63923ab1d68152ace">More...</a><br /></td></tr>
<tr class="separator:a7b2d4df80d31e3e63923ab1d68152ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291e4ede9083ee35cc595b7775a6f41c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a291e4ede9083ee35cc595b7775a6f41c">getOpenGLFormat</a> (ImageStorageFormat storageFormat, uint32_t &amp;glInternalFormat, uint32_t &amp;glFormat, uint32_t &amp;glType, uint32_t &amp;glTypeSize, bool &amp;isCompressedFormat)</td></tr>
<tr class="memdesc:a291e4ede9083ee35cc595b7775a6f41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the OpenGL ES texture formats for a texture with the provided ImageStorageFormat.  <a href="namespacepvr_1_1utils.html#a291e4ede9083ee35cc595b7775a6f41c">More...</a><br /></td></tr>
<tr class="separator:a291e4ede9083ee35cc595b7775a6f41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17214254f1b21d40271dac7b2a4b691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ad17214254f1b21d40271dac7b2a4b691">getOpenGLFormat</a> (PixelFormat pixelFormat, ColorSpace colorSpace, VariableType dataType, uint32_t &amp;glInternalFormat, uint32_t &amp;glFormat, uint32_t &amp;glType, uint32_t &amp;glTypeSize, bool &amp;isCompressedFormat)</td></tr>
<tr class="memdesc:ad17214254f1b21d40271dac7b2a4b691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the OpenGL ES texture formats for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.  <a href="namespacepvr_1_1utils.html#ad17214254f1b21d40271dac7b2a4b691">More...</a><br /></td></tr>
<tr class="separator:ad17214254f1b21d40271dac7b2a4b691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a6472c33618ce49ded8e029b463429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a71a6472c33618ce49ded8e029b463429">getOpenGLStorageFormat</a> (ImageStorageFormat storageFormat, GLenum &amp;glInternalFormat)</td></tr>
<tr class="memdesc:a71a6472c33618ce49ded8e029b463429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the internal OpenGL ES texture formats for a texture with the provided ImageStorageFormat.  <a href="namespacepvr_1_1utils.html#a71a6472c33618ce49ded8e029b463429">More...</a><br /></td></tr>
<tr class="separator:a71a6472c33618ce49ded8e029b463429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faeae4c6a35b0080b0b6031151e53e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a9faeae4c6a35b0080b0b6031151e53e2">getOpenGLStorageFormat</a> (PixelFormat pixelFormat, ColorSpace colorSpace, VariableType dataType, GLenum &amp;glInternalFormat)</td></tr>
<tr class="memdesc:a9faeae4c6a35b0080b0b6031151e53e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the internal OpenGL ES texture format for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.  <a href="namespacepvr_1_1utils.html#a9faeae4c6a35b0080b0b6031151e53e2">More...</a><br /></td></tr>
<tr class="separator:a9faeae4c6a35b0080b0b6031151e53e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e3ce8540f44d3ab8649a7c4487234b"><td class="memItemLeft" align="right" valign="top"><a id="ad3e3ce8540f44d3ab8649a7c4487234b"></a>
pvrvk::Format&#160;</td><td class="memItemRight" valign="bottom"><b>getSupportedDepthStencilFormat</b> (const pvrvk::Device &amp;device, pvr::DisplayAttributes &amp;displayAttributes, std::vector&lt; pvrvk::Format &gt; preferredDepthFormats={})</td></tr>
<tr class="separator:ad3e3ce8540f44d3ab8649a7c4487234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb45f4b332ee2574510ef0155a590b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aeb45f4b332ee2574510ef0155a590b8f">imageUploadAsyncWorker</a> (<a class="el" href="namespacepvr_1_1utils.html#ab251744ba4295771d35ea8f3ee497e0f">ImageUploadFuture</a> uploadFuture)</td></tr>
<tr class="memdesc:aeb45f4b332ee2574510ef0155a590b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a mechanism for kicking an asynchronous image upload worker  <a href="namespacepvr_1_1utils.html#aeb45f4b332ee2574510ef0155a590b8f">More...</a><br /></td></tr>
<tr class="separator:aeb45f4b332ee2574510ef0155a590b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93735fa36d5aedc03cf746dfa208a4b5"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageAspectFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a93735fa36d5aedc03cf746dfa208a4b5">inferAspectFromFormat</a> (pvrvk::Format format)</td></tr>
<tr class="memdesc:a93735fa36d5aedc03cf746dfa208a4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infers the pvrvk::ImageAspectFlags from the pvrvk::Format.  <a href="namespacepvr_1_1utils.html#a93735fa36d5aedc03cf746dfa208a4b5">More...</a><br /></td></tr>
<tr class="separator:a93735fa36d5aedc03cf746dfa208a4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab77d5528ee9f9dc1f4dda381175b89eb">insertDebugUtilsLabel</a> (pvrvk::CommandBuffer &amp;commandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time.  <a href="namespacepvr_1_1utils.html#ab77d5528ee9f9dc1f4dda381175b89eb">More...</a><br /></td></tr>
<tr class="separator:ab77d5528ee9f9dc1f4dda381175b89eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3adba7320aa2b924adc48cfa5e043ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">insertDebugUtilsLabel</a> (pvrvk::CommandBufferBase commandBufferBase, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:ae3adba7320aa2b924adc48cfa5e043ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time.  <a href="namespacepvr_1_1utils.html#ae3adba7320aa2b924adc48cfa5e043ed">More...</a><br /></td></tr>
<tr class="separator:ae3adba7320aa2b924adc48cfa5e043ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2938b3543ae68e23f0f2eb348a786ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2938b3543ae68e23f0f2eb348a786ae9">insertDebugUtilsLabel</a> (pvrvk::SecondaryCommandBuffer &amp;secondaryCommandBuffer, const pvrvk::DebugUtilsLabel &amp;labelInfo)</td></tr>
<tr class="memdesc:a2938b3543ae68e23f0f2eb348a786ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time.  <a href="namespacepvr_1_1utils.html#a2938b3543ae68e23f0f2eb348a786ae9">More...</a><br /></td></tr>
<tr class="separator:a2938b3543ae68e23f0f2eb348a786ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7151c7b74ff657fc17ff09c0ab114a07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7151c7b74ff657fc17ff09c0ab114a07">isFormatDepthStencil</a> (pvrvk::Format format)</td></tr>
<tr class="memdesc:a7151c7b74ff657fc17ff09c0ab114a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the format is a depth stencil format  <a href="namespacepvr_1_1utils.html#a7151c7b74ff657fc17ff09c0ab114a07">More...</a><br /></td></tr>
<tr class="separator:a7151c7b74ff657fc17ff09c0ab114a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59222cc49624a76fab4d4f65e3337ac3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a59222cc49624a76fab4d4f65e3337ac3">isImageUsageSupportedBySurface</a> (const pvrvk::SurfaceCapabilitiesKHR &amp;surfaceCapabilities, pvrvk::ImageUsageFlags imageUsage)</td></tr>
<tr class="memdesc:a59222cc49624a76fab4d4f65e3337ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function used to determine whether the SurfaceCapabilitiesKHR supportedUsageFlags member contains the specified image usage and therefore can be used in the intended way.  <a href="namespacepvr_1_1utils.html#a59222cc49624a76fab4d4f65e3337ac3">More...</a><br /></td></tr>
<tr class="separator:a59222cc49624a76fab4d4f65e3337ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab777db50d44d55cca94123e7cdcb1d7e"><td class="memItemLeft" align="right" valign="top"><a id="ab777db50d44d55cca94123e7cdcb1d7e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSupportedDepthStencilFormat</b> (const pvrvk::Device &amp;device, pvrvk::Format format)</td></tr>
<tr class="separator:ab777db50d44d55cca94123e7cdcb1d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370ec57dd60df6f8d8327619a8a90178"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a370ec57dd60df6f8d8327619a8a90178">loadAndUploadImage</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> stagingBufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a370ec57dd60df6f8d8327619a8a90178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#a370ec57dd60df6f8d8327619a8a90178">More...</a><br /></td></tr>
<tr class="separator:a370ec57dd60df6f8d8327619a8a90178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138104e7cebf7941707336c0418bc3c8"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a138104e7cebf7941707336c0418bc3c8">loadAndUploadImage</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> stagingBufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a138104e7cebf7941707336c0418bc3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#a138104e7cebf7941707336c0418bc3c8">More...</a><br /></td></tr>
<tr class="separator:a138104e7cebf7941707336c0418bc3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7751d185a203ad3f8d19fc1bb5eb6e2"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae7751d185a203ad3f8d19fc1bb5eb6e2">loadAndUploadImage</a> (pvrvk::Device &amp;device, const std::string &amp;fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> stagingBufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ae7751d185a203ad3f8d19fc1bb5eb6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#ae7751d185a203ad3f8d19fc1bb5eb6e2">More...</a><br /></td></tr>
<tr class="separator:ae7751d185a203ad3f8d19fc1bb5eb6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868fafd2e077cfc7281c45c64677e47a"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a868fafd2e077cfc7281c45c64677e47a">loadAndUploadImageAndView</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> stagingBufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a868fafd2e077cfc7281c45c64677e47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#a868fafd2e077cfc7281c45c64677e47a">More...</a><br /></td></tr>
<tr class="separator:a868fafd2e077cfc7281c45c64677e47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a49bb33bec83289c2620a84afd9c2a"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af9a49bb33bec83289c2620a84afd9c2a">loadAndUploadImageAndView</a> (pvrvk::Device &amp;device, const char *fileName, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, IAssetProvider &amp;assetProvider, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, Texture *outAssetTexture=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> stagingBufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:af9a49bb33bec83289c2620a84afd9c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#af9a49bb33bec83289c2620a84afd9c2a">More...</a><br /></td></tr>
<tr class="separator:af9a49bb33bec83289c2620a84afd9c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb2e88f9124d29c4a2498783cf4e1c9"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8cb2e88f9124d29c4a2498783cf4e1c9">loadShader</a> (const std::string &amp;shaderSource, ShaderType shaderType, const char *const *defines, uint32_t numDefines)</td></tr>
<tr class="memdesc:a8cb2e88f9124d29c4a2498783cf4e1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load shader from shader source. Will implicitly load on the current context.  <a href="namespacepvr_1_1utils.html#a8cb2e88f9124d29c4a2498783cf4e1c9">More...</a><br /></td></tr>
<tr class="separator:a8cb2e88f9124d29c4a2498783cf4e1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6587db0405c15cfceeb768f0a740dca"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ab6587db0405c15cfceeb768f0a740dca">loadShader</a> (const Stream &amp;shaderSource, ShaderType shaderType, const char *const *defines, uint32_t numDefines)</td></tr>
<tr class="memdesc:ab6587db0405c15cfceeb768f0a740dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load shader from shader source. Will implicitly load on the current context.  <a href="namespacepvr_1_1utils.html#ab6587db0405c15cfceeb768f0a740dca">More...</a><br /></td></tr>
<tr class="separator:ab6587db0405c15cfceeb768f0a740dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbbbd1665449ea70d772de63595c806"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1cbbbd1665449ea70d772de63595c806">logMessageDebugReportCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</td></tr>
<tr class="memdesc:a1cbbbd1665449ea70d772de63595c806"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugReportCallback function providing logging for various events.  <a href="namespacepvr_1_1utils.html#a1cbbbd1665449ea70d772de63595c806">More...</a><br /></td></tr>
<tr class="separator:a1cbbbd1665449ea70d772de63595c806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a5e37e4f2f8723d81f2f60ff7c9ffebdf">logMessageDebugUtilsMessengerCallback</a> (VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData)</td></tr>
<tr class="memdesc:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugUtilsMessengerCallback function providing logging for various events.  <a href="namespacepvr_1_1utils.html#a5e37e4f2f8723d81f2f60ff7c9ffebdf">More...</a><br /></td></tr>
<tr class="separator:a5e37e4f2f8723d81f2f60ff7c9ffebdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee21903727c73558ad8e3cf936917344"><td class="memItemLeft" align="right" valign="top">LogLevel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aee21903727c73558ad8e3cf936917344">mapDebugReportFlagsToLogLevel</a> (pvrvk::DebugReportFlagsEXT flags)</td></tr>
<tr class="memdesc:aee21903727c73558ad8e3cf936917344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a set of DebugReportFlagsEXT to a particular type of log message.  <a href="namespacepvr_1_1utils.html#aee21903727c73558ad8e3cf936917344">More...</a><br /></td></tr>
<tr class="separator:aee21903727c73558ad8e3cf936917344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd1f30f49a0d36c9d932437e902d2bb"><td class="memItemLeft" align="right" valign="top">LogLevel&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#abbd1f30f49a0d36c9d932437e902d2bb">mapDebugUtilsMessageSeverityFlagsToLogLevel</a> (pvrvk::DebugUtilsMessageSeverityFlagsEXT flags)</td></tr>
<tr class="memdesc:abbd1f30f49a0d36c9d932437e902d2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a set of DebugUtilsMessageSeverityFlagsEXT to a particular type of log message.  <a href="namespacepvr_1_1utils.html#abbd1f30f49a0d36c9d932437e902d2bb">More...</a><br /></td></tr>
<tr class="separator:abbd1f30f49a0d36c9d932437e902d2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4821411be60c23284522f13f481f1a8b"><td class="memItemLeft" align="right" valign="top"><a id="a4821411be60c23284522f13f481f1a8b"></a>
ModelGles::Flags&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (ModelGles::Flags lhs, ModelGles::Flags rhs)</td></tr>
<tr class="separator:a4821411be60c23284522f13f481f1a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76574b8bc15aa840b13f08bdc8608de"><td class="memItemLeft" align="right" valign="top"><a id="af76574b8bc15aa840b13f08bdc8608de"></a>
ModelGles::Flags &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;=</b> (ModelGles::Flags &amp;lhs, ModelGles::Flags rhs)</td></tr>
<tr class="separator:af76574b8bc15aa840b13f08bdc8608de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0f97c0778b3d71e0a48fc7e695c232"><td class="memItemLeft" align="right" valign="top"><a id="aae0f97c0778b3d71e0a48fc7e695c232"></a>
ModelGles::Flags&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (ModelGles::Flags lhs, ModelGles::Flags rhs)</td></tr>
<tr class="separator:aae0f97c0778b3d71e0a48fc7e695c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063e69979f95db0bea16c9956cad446f"><td class="memItemLeft" align="right" valign="top"><a id="a063e69979f95db0bea16c9956cad446f"></a>
ModelGles::Flags &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator|=</b> (ModelGles::Flags &amp;lhs, ModelGles::Flags rhs)</td></tr>
<tr class="separator:a063e69979f95db0bea16c9956cad446f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0c12df7c704cd669d4bef29942555e"><td class="memItemLeft" align="right" valign="top">PackedSamplerFilter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a9c0c12df7c704cd669d4bef29942555e">packSamplerFilter</a> (pvrvk::Filter mini, pvrvk::Filter magni, pvrvk::SamplerMipmapMode mip)</td></tr>
<tr class="memdesc:a9c0c12df7c704cd669d4bef29942555e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Created a packed sampler filter  <a href="namespacepvr_1_1utils.html#a9c0c12df7c704cd669d4bef29942555e">More...</a><br /></td></tr>
<tr class="separator:a9c0c12df7c704cd669d4bef29942555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a98e4ac9990af6eaf6b9bf0928f2bd07d">populateClearValues</a> (const pvrvk::RenderPass &amp;renderpass, const pvrvk::ClearValue &amp;clearColor, const pvrvk::ClearValue &amp;clearDepthStencilValue, pvrvk::ClearValue *outClearValues)</td></tr>
<tr class="memdesc:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate color and depthstencil clear values  <a href="namespacepvr_1_1utils.html#a98e4ac9990af6eaf6b9bf0928f2bd07d">More...</a><br /></td></tr>
<tr class="separator:a98e4ac9990af6eaf6b9bf0928f2bd07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae0c2fd1a13ff3b5e9086e13ea4608c43">populateInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a> *bindingMap, uint16_t numBindings, pvrvk::PipelineVertexInputStateCreateInfo &amp;vertexCreateInfo, pvrvk::PipelineInputAssemblerStateCreateInfo &amp;inputAssemblerCreateInfo, uint16_t *numOutBuffers=nullptr)</td></tr>
<tr class="memdesc:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a>.  <a href="namespacepvr_1_1utils.html#ae0c2fd1a13ff3b5e9086e13ea4608c43">More...</a><br /></td></tr>
<tr class="separator:ae0c2fd1a13ff3b5e9086e13ea4608c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c295af45dc688c117ebf5993e55373"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a94c295af45dc688c117ebf5993e55373">populateInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a> *bindingMap, uint32_t numBindings, pvrvk::PipelineVertexInputStateCreateInfo &amp;vertexCreateInfo, pvrvk::PipelineInputAssemblerStateCreateInfo &amp;inputAssemblerCreateInfo, uint32_t *numOutBuffers=nullptr)</td></tr>
<tr class="memdesc:a94c295af45dc688c117ebf5993e55373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html" title="Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name.">VertexBindings_Name</a>.  <a href="namespacepvr_1_1utils.html#a94c295af45dc688c117ebf5993e55373">More...</a><br /></td></tr>
<tr class="separator:a94c295af45dc688c117ebf5993e55373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a1e9a18d03439c5efe7d88dbb3c16b783">populateViewportStateCreateInfo</a> (const pvrvk::Framebuffer &amp;framebuffer, pvrvk::PipelineViewportStateCreateInfo &amp;outCreateInfo)</td></tr>
<tr class="memdesc:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills out a pvrvk::ViewportStateCreateInfo structure setting parameters for a 'default' viewport and scissor based on the specified frame buffer dimensions.  <a href="namespacepvr_1_1utils.html#a1e9a18d03439c5efe7d88dbb3c16b783">More...</a><br /></td></tr>
<tr class="separator:a1e9a18d03439c5efe7d88dbb3c16b783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee378b23390266dcaa61b724e0a29808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aee378b23390266dcaa61b724e0a29808">saveImage</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Image &amp;image, const pvrvk::ImageLayout imageInitialLayout, const pvrvk::ImageLayout imageFinalLayout, const std::string &amp;filename, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> bufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, const uint32_t screenshotScale=1)</td></tr>
<tr class="memdesc:aee378b23390266dcaa61b724e0a29808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the input image as a TGA file with the filename specified. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set.  <a href="namespacepvr_1_1utils.html#aee378b23390266dcaa61b724e0a29808">More...</a><br /></td></tr>
<tr class="separator:aee378b23390266dcaa61b724e0a29808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076fe31eafd575f7f2a10f27f6130935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a076fe31eafd575f7f2a10f27f6130935">setImageLayout</a> (pvrvk::Image &amp;image, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::CommandBufferBase transitionCmdBuffer)</td></tr>
<tr class="memdesc:a076fe31eafd575f7f2a10f27f6130935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set image layout  <a href="namespacepvr_1_1utils.html#a076fe31eafd575f7f2a10f27f6130935">More...</a><br /></td></tr>
<tr class="separator:a076fe31eafd575f7f2a10f27f6130935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f7af5558e7afc812edc1e8899d8f50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a19f7af5558e7afc812edc1e8899d8f50">setImageLayoutAndQueueFamilyOwnership</a> (pvrvk::CommandBufferBase srccmd, pvrvk::CommandBufferBase dstcmd, uint32_t srcQueueFamily, uint32_t dstQueueFamily, pvrvk::ImageLayout oldLayout, pvrvk::ImageLayout newLayout, pvrvk::Image &amp;image, uint32_t baseMipLevel, uint32_t numMipLevels, uint32_t baseArrayLayer, uint32_t numArrayLayers, pvrvk::ImageAspectFlags aspect)</td></tr>
<tr class="memdesc:a19f7af5558e7afc812edc1e8899d8f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set image layout and queue family ownership  <a href="namespacepvr_1_1utils.html#a19f7af5558e7afc812edc1e8899d8f50">More...</a><br /></td></tr>
<tr class="separator:a19f7af5558e7afc812edc1e8899d8f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc7d04620963f299874921f6fd18fb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a0dc7d04620963f299874921f6fd18fb8">takeScreenshot</a> (pvrvk::Queue &amp;queue, pvrvk::CommandPool &amp;commandPool, pvrvk::Swapchain &amp;swapchain, const uint32_t swapIndex, const std::string &amp;screenshotFileName, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> bufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, const uint32_t screenshotScale=1)</td></tr>
<tr class="memdesc:a0dc7d04620963f299874921f6fd18fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a particular swapchain image corresponding to the swapchain image at index swapIndex for the swapchain.  <a href="namespacepvr_1_1utils.html#a0dc7d04620963f299874921f6fd18fb8">More...</a><br /></td></tr>
<tr class="separator:a0dc7d04620963f299874921f6fd18fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac9f0af2d041d5efe3f668f87c6932b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html">TextureUploadResults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#adac9f0af2d041d5efe3f668f87c6932b">textureUpload</a> (const Texture &amp;texture, bool isEs2, bool allowDecompress)</td></tr>
<tr class="memdesc:adac9f0af2d041d5efe3f668f87c6932b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload a texture to the GPU on the current context, and return it as part of the <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> structure.  <a href="namespacepvr_1_1utils.html#adac9f0af2d041d5efe3f668f87c6932b">More...</a><br /></td></tr>
<tr class="separator:adac9f0af2d041d5efe3f668f87c6932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f2bb511b50d2c11ddc7377a60714ad"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a54f2bb511b50d2c11ddc7377a60714ad">throwOnErrorDebugReportCallback</a> (VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage, void *pUserData)</td></tr>
<tr class="memdesc:a54f2bb511b50d2c11ddc7377a60714ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugReportCallback function providing logging for various events. The callback will also throw an exception when VkDebugReportFlagsEXT includes the VK_DEBUG_REPORT_ERROR_BIT_EXT.  <a href="namespacepvr_1_1utils.html#a54f2bb511b50d2c11ddc7377a60714ad">More...</a><br /></td></tr>
<tr class="separator:a54f2bb511b50d2c11ddc7377a60714ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3d187bfb119271fea887f28268699a"><td class="memItemLeft" align="right" valign="top">VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aaf3d187bfb119271fea887f28268699a">throwOnErrorDebugUtilsMessengerCallback</a> (VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData)</td></tr>
<tr class="memdesc:aaf3d187bfb119271fea887f28268699a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An application DebugUtilsMessengerCallback function providing logging for various events. The callback will also throw an exception when VkDebugUtilsMessageSeverityFlagBitsEXT includes the VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT.  <a href="namespacepvr_1_1utils.html#aaf3d187bfb119271fea887f28268699a">More...</a><br /></td></tr>
<tr class="separator:aaf3d187bfb119271fea887f28268699a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd40d1ab877a6c2ddf9c53ad02d8960f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#afd40d1ab877a6c2ddf9c53ad02d8960f">throwOnGlError</a> (const char *note)</td></tr>
<tr class="memdesc:afd40d1ab877a6c2ddf9c53ad02d8960f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and logs api errors if appropriate.  <a href="namespacepvr_1_1utils.html#afd40d1ab877a6c2ddf9c53ad02d8960f">More...</a><br /></td></tr>
<tr class="separator:afd40d1ab877a6c2ddf9c53ad02d8960f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf553ba402ff80bc721c72d3a831a703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#abf553ba402ff80bc721c72d3a831a703">unpackSamplerFilter</a> (PackedSamplerFilter packed, pvrvk::Filter &amp;mini, pvrvk::Filter &amp;magni, pvrvk::SamplerMipmapMode &amp;mip)</td></tr>
<tr class="memdesc:abf553ba402ff80bc721c72d3a831a703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a packed sampler filter  <a href="namespacepvr_1_1utils.html#abf553ba402ff80bc721c72d3a831a703">More...</a><br /></td></tr>
<tr class="separator:abf553ba402ff80bc721c72d3a831a703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a791a9c8914a9bf3b74db574b0c842"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac4a791a9c8914a9bf3b74db574b0c842">updateBufferUsingStagingBuffer</a> (pvrvk::Device &amp;device, pvrvk::Buffer &amp;buffer, pvrvk::CommandBufferBase uploadCmdBuffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> stagingBufferAllocator=nullptr)</td></tr>
<tr class="memdesc:ac4a791a9c8914a9bf3b74db574b0c842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update a buffer's data via an indirect copy from a temporary staging buffer. Updating memory via the use of a staging buffer is necessary when using memory without e_HOST_VISIBLE_BIT memory property flags meaning the buffer itself cannot be mapped to host memory.  <a href="namespacepvr_1_1utils.html#ac4a791a9c8914a9bf3b74db574b0c842">More...</a><br /></td></tr>
<tr class="separator:ac4a791a9c8914a9bf3b74db574b0c842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">updateHostVisibleBuffer</a> (pvrvk::Buffer &amp;buffer, const void *data, VkDeviceSize offset=0, VkDeviceSize size=VK_WHOLE_SIZE, bool flushMemory=false)</td></tr>
<tr class="memdesc:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update a buffer's data. This function maps and unmap the buffer only if the buffer is not already mapped.  <a href="namespacepvr_1_1utils.html#a618e4160bd8c24d9e0d394dc9511f4a3">More...</a><br /></td></tr>
<tr class="separator:a618e4160bd8c24d9e0d394dc9511f4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4a3a0c8eb6662f51128ce8a3b78a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a0f4a3a0c8eb6662f51128ce8a3b78a9f">updateImage</a> (pvrvk::Device &amp;device, pvrvk::CommandBufferBase transferCommandBuffer, <a class="el" href="structpvr_1_1utils_1_1_image_update_info.html">ImageUpdateInfo</a> *updateInfos, uint32_t numUpdateInfos, pvrvk::Format format, pvrvk::ImageLayout layout, bool isCubeMap, pvrvk::Image &amp;image, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> bufferAllocator=nullptr)</td></tr>
<tr class="memdesc:a0f4a3a0c8eb6662f51128ce8a3b78a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to update an image's data. This function will record the update of the image in the supplied command buffer but NOT submit the command buffer, hence allowing the user to submit it at his own time. IMPORTANT. Assumes image layout is pvrvk::ImageLayout::e_DST_OPTIMAL IMPORTANT. The cleanup object that is the return value of the function must be kept alive as long until the moment that the relevant command buffer submission is finished. Then it can be destroyed (or the cleanup function be called) to free any relevant resources.  <a href="namespacepvr_1_1utils.html#a0f4a3a0c8eb6662f51128ce8a3b78a9f">More...</a><br /></td></tr>
<tr class="separator:a0f4a3a0c8eb6662f51128ce8a3b78a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff24a1e7c47775943d761eaa3f7f555e"><td class="memItemLeft" align="right" valign="top">pvrvk::Image&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#aff24a1e7c47775943d761eaa3f7f555e">uploadImage</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> stagingBufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:aff24a1e7c47775943d761eaa3f7f555e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#aff24a1e7c47775943d761eaa3f7f555e">More...</a><br /></td></tr>
<tr class="separator:aff24a1e7c47775943d761eaa3f7f555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d35fcf1b7758225738b98830816d4e"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac4d35fcf1b7758225738b98830816d4e">uploadImageAndView</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> stagingBufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ac4d35fcf1b7758225738b98830816d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#ac4d35fcf1b7758225738b98830816d4e">More...</a><br /></td></tr>
<tr class="separator:ac4d35fcf1b7758225738b98830816d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbafa4f264dcddf481f21ad03027d97"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a7fbafa4f264dcddf481f21ad03027d97">uploadImageAndView</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::SecondaryCommandBuffer &amp;commandBuffer, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> stagingBufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:a7fbafa4f264dcddf481f21ad03027d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads an image to gpu. The upload command and staging buffers are recorded in the commandbuffer.  <a href="namespacepvr_1_1utils.html#a7fbafa4f264dcddf481f21ad03027d97">More...</a><br /></td></tr>
<tr class="separator:a7fbafa4f264dcddf481f21ad03027d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d376caf410d6a539eb713d8886ebee"><td class="memItemLeft" align="right" valign="top">pvrvk::ImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac3d376caf410d6a539eb713d8886ebee">uploadImageAndViewSubmit</a> (pvrvk::Device &amp;device, const Texture &amp;texture, bool allowDecompress, pvrvk::CommandPool &amp;commandPool, pvrvk::Queue &amp;queue, pvrvk::ImageUsageFlags usageFlags=pvrvk::ImageUsageFlags::e_SAMPLED_BIT, pvrvk::ImageLayout finalLayout=pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> stagingBufferAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> imageAllocator=nullptr, <a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a> imageAllocationCreateFlags=vma::AllocationCreateFlags::e_NONE)</td></tr>
<tr class="memdesc:ac3d376caf410d6a539eb713d8886ebee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads an image to GPU memory and returns the created image view and associated image.  <a href="namespacepvr_1_1utils.html#ac3d376caf410d6a539eb713d8886ebee">More...</a><br /></td></tr>
<tr class="separator:ac3d376caf410d6a539eb713d8886ebee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a97e337b41359e776b8c93796d23d4977"><td class="memItemLeft" align="right" valign="top"><a id="a97e337b41359e776b8c93796d23d4977"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>PVRUtils_Throw_On_Validation_Error</b></td></tr>
<tr class="separator:a97e337b41359e776b8c93796d23d4977"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace for the PVRUtils Library </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a990a2454c0ddfb8bf5383a11262a76ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990a2454c0ddfb8bf5383a11262a76ec">&#9670;&nbsp;</a></span>AsyncApiTexture</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;async::IFrameworkAsyncResult&lt;pvrvk::ImageView&gt; &gt; <a class="el" href="namespacepvr_1_1utils.html#a990a2454c0ddfb8bf5383a11262a76ec">pvr::utils::AsyncApiTexture</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a reference counted pointer to a IFrameworkAsyncResult specialised by an ImageView which will be used as the main interface for using API specific asynchronous textures. </p>

</div>
</div>
<a id="a54bd78a7c682d6b8161db1db04f1f910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bd78a7c682d6b8161db1db04f1f910">&#9670;&nbsp;</a></span>AsyncTexture</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;async::IFrameworkAsyncResult&lt;<a class="el" href="namespacepvr_1_1utils.html#adbd0dc78bf662b222b9e01a5efb6c778">TexturePtr</a>&gt; &gt; <a class="el" href="namespacepvr_1_1utils.html#a54bd78a7c682d6b8161db1db04f1f910">pvr::utils::AsyncTexture</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a reference counted pointer to a IFrameworkAsyncResult specialised by a TexturePtr which will be used as the main interface for using API agnostic asynchronous textures. </p>

</div>
</div>
<a id="ab251744ba4295771d35ea8f3ee497e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab251744ba4295771d35ea8f3ee497e0f">&#9670;&nbsp;</a></span>ImageUploadFuture</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="structpvr_1_1utils_1_1_image_upload_future__.html">ImageUploadFuture_</a>&gt; <a class="el" href="namespacepvr_1_1utils.html#ab251744ba4295771d35ea8f3ee497e0f">pvr::utils::ImageUploadFuture</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A ref-counted pointer to a Future of an Image Upload: A class that wraps the texture that "is being uploaded on a separate thread", together with functions to "query if the upload is yet complete" and to "block until the upload is complete, if necessary, and return the result" </p>

</div>
</div>
<a id="adbd0dc78bf662b222b9e01a5efb6c778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd0dc78bf662b222b9e01a5efb6c778">&#9670;&nbsp;</a></span>TexturePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;Texture&gt; <a class="el" href="namespacepvr_1_1utils.html#adbd0dc78bf662b222b9e01a5efb6c778">pvr::utils::TexturePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a reference counted pointer to a pvr::Texture which will be used for loading API agnostic texture data to disk. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a100ef068316423d649e18a3a2168aacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100ef068316423d649e18a3a2168aacb">&#9670;&nbsp;</a></span>appendSingleBuffersFromModel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VboContainer_ , typename IboContainer_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::appendSingleBuffersFromModel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>vbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>ibos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">model</td><td>The model whose meshes will be used to generate the Buffers</td></tr>
    <tr><td class="paramname">vbos</td><td>A container of pvrvk::Buffer handles. The VBOs will be inserted at the end of this container.</td></tr>
    <tr><td class="paramname">ibos</td><td>A container of pvrvk::Buffer handles. The IBOs will be inserted at the end of this container.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the VBO. It is usually preferred for meshes meshes containing a single set of interleaved data. If multiple data elements (i.e. sets of interleaved data), each block will be successively placed after the other.</p>

</div>
</div>
<a id="ab62f121a7b8a9d790ca4e4e3dfcff0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62f121a7b8a9d790ca4e4e3dfcff0aa">&#9670;&nbsp;</a></span>beginCommandBufferDebugLabel() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::beginCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The command buffer to which the debug label region should be opened</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to open</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f241ba112200732fffaeb2906b6ed4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f241ba112200732fffaeb2906b6ed4b">&#9670;&nbsp;</a></span>beginCommandBufferDebugLabel() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::beginCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>commandBufferBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBufferBase</td><td>The command buffer base to which the debug label region should be opened</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to open</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45dc67a22e33dc6bf735edc27a1432ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dc67a22e33dc6bf735edc27a1432ef">&#9670;&nbsp;</a></span>beginCommandBufferDebugLabel() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::beginCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>secondaryCommandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins identifying a region of work submitted to this secondary command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondaryCommandBuffer</td><td>The secondary command buffer to which the debug label region should be opened</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to open</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eaec27096b06e097a3ead372e30c68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaec27096b06e097a3ead372e30c68c">&#9670;&nbsp;</a></span>beginQueueDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::beginQueueDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins identifying a region of work submitted to this queue. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to which the debug label region should be opened</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to open</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f76f7564d0c8100418857026db23840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f76f7564d0c8100418857026db23840">&#9670;&nbsp;</a></span>captureImageRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned char&gt; pvr::utils::captureImageRegion </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandPool &amp;&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Offset3D&#160;</td>
          <td class="paramname"><em>srcOffset</em> = <code>pvrvk::Offset3D(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Extent3D&#160;</td>
          <td class="paramname"><em>srcExtent</em> = <code>pvrvk::Extent3D(static_cast&lt;&#160;uint32_t&#160;&gt;(-1),&#160;static_cast&lt;&#160;uint32_t&#160;&gt;(-1),&#160;static_cast&lt;&#160;uint32_t&#160;&gt;(-1))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>destinationImageFormat</em> = <code>pvrvk::Format::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>imageInitialLayout</em> = <code>pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>imageFinalLayout</em> = <code>pvrvk::ImageLayout::e_TRANSFER_DST_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves and returns the contents of a particular image region. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set. </p>
<p>SCREENSHOTS ////////////////////////</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A queue to submit the generated command buffer to. This queue must be compatible with the command pool provided.</td></tr>
    <tr><td class="paramname">commandPool</td><td>A command pool from which to allocate a temporary command buffer to carry out the transfer operations.</td></tr>
    <tr><td class="paramname">image</td><td>The image from which the specified region will be retrieved.</td></tr>
    <tr><td class="paramname">srcOffset</td><td>The offset into the specified image from which to begin the region to capture.</td></tr>
    <tr><td class="paramname">srcExtent</td><td>The extent of the region to capture.</td></tr>
    <tr><td class="paramname">destinationImageFormat</td><td>The format to use for the saved image. Valid format conversions will be applied using vkCmdBlitImage.</td></tr>
    <tr><td class="paramname">imageInitialLayout</td><td>The initial layout of the image from which a transition will be made to pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL.</td></tr>
    <tr><td class="paramname">imageFinalLayout</td><td>The final layout of the image to which a transition will be made.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created the buffer used as the target of an imageToBufferCopy.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the retrieved image data</dd></dl>

</div>
</div>
<a id="aafce526b759924e9114572d863b5b8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafce526b759924e9114572d863b5b8f6">&#9670;&nbsp;</a></span>checkApiError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pvr::utils::checkApiError </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errOutStr</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks and returns api error if appropriate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errOutStr</td><td>error std::string to be output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>api error code</dd></dl>

</div>
</div>
<a id="a20ca18b411c83be99cc9b83137cef4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ca18b411c83be99cc9b83137cef4d8">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">BlendFactor&#160;</td>
          <td class="paramname"><em>blendFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl blend factor output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blendFactor</td><td>A BlendFactor enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a BlendFactor (GL_ZERO, GL_SRC_COLOR, GL_ONE_MINUS_SRC_ALPHA etc)</dd></dl>

</div>
</div>
<a id="afe32fb89dfe5e37513af651055cdef15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe32fb89dfe5e37513af651055cdef15">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">BlendOp&#160;</td>
          <td class="paramname"><em>blendOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl blend op output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blendOp</td><td>A BlendOp enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a Blend Operation (GL_FUNC_ADD, GL_MIN etc)</dd></dl>

</div>
</div>
<a id="a196375d06b5173798e46037c7b8eb890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196375d06b5173798e46037c7b8eb890">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">CompareOp&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl comparison mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>A ComparisonMode enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a ComparisonMode (GL_LESS, GL_EQUAL etc)</dd></dl>

</div>
</div>
<a id="ad86cd8604c6d3c155b531d7a1784581f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86cd8604c6d3c155b531d7a1784581f">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>A DataType enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a DataType (GL_FLOAT, GL_UNSIGNED_BYTE etc)</dd></dl>

</div>
</div>
<a id="aabfe42ed26ab9fcb99118de82013eedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfe42ed26ab9fcb99118de82013eedb">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">Face&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A Face enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a face (GL_FRONT, GL_BACK, GL_FRONT_AND_BACK, GL_NONE)</dd></dl>

</div>
</div>
<a id="a648788eddea6a26479db4a04cdeedf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648788eddea6a26479db4a04cdeedf55">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">ImageAspectFlags&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to an opengl image aspect type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>An ImageAspectFlags enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing the ImageAspectFlags</dd></dl>

</div>
</div>
<a id="a7d36f28640fc36caaed25f8935a48229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d36f28640fc36caaed25f8935a48229">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">ImageViewType&#160;</td>
          <td class="paramname"><em>texType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl texture type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texType</td><td>A TextureDimension enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a texture dimension (GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_2D_ARRAY)</dd></dl>

</div>
</div>
<a id="a7b92cb613310549a5b748d1f5c4b4557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b92cb613310549a5b748d1f5c4b4557">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts from a pvr::IndexType to its OpenGL ES GLenum counterpart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The pvr::IndexType to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The OpenGL ES GLenum counterpart to a pvr::IndexType.</dd></dl>

</div>
</div>
<a id="a2cf730a0573373abb18dcefa9390e840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf730a0573373abb18dcefa9390e840">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">PolygonWindingOrder&#160;</td>
          <td class="paramname"><em>windingOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl winding-order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windingOrder</td><td>A PolygonWindingOrder enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a winding order (GL_CW, GL_CCW)</dd></dl>

</div>
</div>
<a id="a4848cd91db829306bc8a1ed929762aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4848cd91db829306bc8a1ed929762aad">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">PrimitiveTopology&#160;</td>
          <td class="paramname"><em>primitiveType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl priitive type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitiveType</td><td>a PrimitiveTopology enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a primitive type (GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_POINTS etc)</dd></dl>

</div>
</div>
<a id="a3c41ff094638c4216cb39bf821408fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c41ff094638c4216cb39bf821408fe5">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">SamplerAddressMode&#160;</td>
          <td class="paramname"><em>addressMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl sampler wrap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressMode</td><td>A SamplerAddressMode enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a Sampler Wrap mode (GL_CLAMP_TO_EDGE, GL_REPEAT etc)</dd></dl>

</div>
</div>
<a id="af1dc4d95376bb577dd85455028527815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dc4d95376bb577dd85455028527815">&#9670;&nbsp;</a></span>convertToGles() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum pvr::utils::convertToGles </td>
          <td>(</td>
          <td class="paramtype">StencilOp&#160;</td>
          <td class="paramname"><em>stencilOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to opengl stencil op output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stencilOp</td><td>A StencilOp enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A GLenum representing a Stencil Operation (GL_INC_WRAP, GL_ZERO etc)</dd></dl>

</div>
</div>
<a id="abf411047de1c9b93006e248404d156cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf411047de1c9b93006e248404d156cd">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::PipelineColorBlendAttachmentState pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const BlendingConfig &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk PipelineColorBlendAttachmentState </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The pvr::BlendingConfig to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::PipelineColorBlendAttachmentState representing the BlendingConfig</dd></dl>

</div>
</div>
<a id="a1015e60258a9b1ea86213471275c8955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1015e60258a9b1ea86213471275c8955">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Extent2D pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const Extent2D &amp;&#160;</td>
          <td class="paramname"><em>extent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk Extent2D </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>The pvr::Extent2D to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Extent2D representing the Extent2D</dd></dl>

</div>
</div>
<a id="a3e5b7760e47f22fd546b6eabfcae3b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5b7760e47f22fd546b6eabfcae3b62">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Extent3D pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const Extent3D &amp;&#160;</td>
          <td class="paramname"><em>extent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk Extent3D </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>The pvr::Extent3D to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Extent3D representing the Extent3D</dd></dl>

</div>
</div>
<a id="a3116f95a85b64265c0b26ce81df895cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3116f95a85b64265c0b26ce81df895cd">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Format pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const ImageDataFormat &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk pixel format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Image Data format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Format representing the pixel format</dd></dl>

</div>
</div>
<a id="a251d0fffcee64a05e2619a02b52b109e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251d0fffcee64a05e2619a02b52b109e">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Offset2D pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const Offset2D &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk Offset2D </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The pvr::Offset2D to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Offset2D representing the Offset2D</dd></dl>

</div>
</div>
<a id="a7ae6b94f99d8533786ba3eb16f4e694a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae6b94f99d8533786ba3eb16f4e694a">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Offset3D pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const Offset3D &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk Offset3D </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The pvr::Offset3D to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Offset3D representing the Offset3D</dd></dl>

</div>
</div>
<a id="af9c490851508a5e8618c5f6e15b3cae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c490851508a5e8618c5f6e15b3cae0">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::StencilOpState pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const StencilState &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk StencilOpState </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The pvr::StencilState to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::StencilOpState representing the StencilState</dd></dl>

</div>
</div>
<a id="a980064e6fd1ed7293c5b04941625bccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980064e6fd1ed7293c5b04941625bccf">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::VertexInputAttributeDescription pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1utils_1_1_vertex_attribute_info.html">VertexAttributeInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>binding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk VertexInputAttributeDescription </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The pvr::VertexAttributeInfo to convert</td></tr>
    <tr><td class="paramname">binding</td><td>The binding index to use as part of the pvrvk::VertexInputAttributeDescription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::VertexInputAttributeDescription representing the <a class="el" href="structpvr_1_1utils_1_1_vertex_attribute_info.html" title="Contains a full description of a Vertex Attribute: Index, format, number of elements,...">VertexAttributeInfo</a> with corresponding binding index</dd></dl>

</div>
</div>
<a id="a85935527bc9b1766c64a889a5194f405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85935527bc9b1766c64a889a5194f405">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::VertexInputBindingDescription pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1utils_1_1_vertex_input_binding_info.html">VertexInputBindingInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk VertexInputBindingDescription </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The pvr::VertexInputBindingInfo to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::VertexInputBindingDescription representing the <a class="el" href="structpvr_1_1utils_1_1_vertex_input_binding_info.html" title="Information about a Buffer binding: Binding index, stride, (instance) step rate.">VertexInputBindingInfo</a></dd></dl>

</div>
</div>
<a id="ada8e829e93a104391248c513aeabe8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8e829e93a104391248c513aeabe8d3">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::DataType pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>dataType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk Data type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>The pvr::DataType to convert to Vulkan type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::DataType</dd></dl>

</div>
</div>
<a id="ac4535ea5342874964d50833bfa20221c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4535ea5342874964d50833bfa20221c">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageViewType pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">ImageViewType&#160;</td>
          <td class="paramname"><em>texDimemsion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk image view type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texDimemsion</td><td>Texture dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::ImageViewType (pvrvk::ImageViewType::e_1D, pvrvk::ImageViewType::e_2D etc)</dd></dl>

</div>
</div>
<a id="a6faa52cbc7bd9bc2ff02b680ca3c869d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6faa52cbc7bd9bc2ff02b680ca3c869d">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::IndexType pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a pvr::IndexType to its Native, Vulkan representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>A pvr::IndexType to convert to its Vulkan representation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::IndexType corresponding to the pvr::IndexType</dd></dl>

</div>
</div>
<a id="ae0492010765906fc6787a7e2498ba57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0492010765906fc6787a7e2498ba57c">&#9670;&nbsp;</a></span>convertToPVRVk() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::VertexInputRate pvr::utils::convertToPVRVk </td>
          <td>(</td>
          <td class="paramtype">StepRate&#160;</td>
          <td class="paramname"><em>stepRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk vertex input rate </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stepRate</td><td>The step rate of the vertex input(Vertex, Instance)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::VertexInputRate (pvrvk::VertexInputRate::e_VERTEX, pvrvk::VertexInputRate::e_INSTANCE)</dd></dl>

</div>
</div>
<a id="a745663053f1f1c98e457ce71a8b0048a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745663053f1f1c98e457ce71a8b0048a">&#9670;&nbsp;</a></span>convertToPVRVkMipmapMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::SamplerMipmapMode pvr::utils::convertToPVRVkMipmapMode </td>
          <td>(</td>
          <td class="paramtype">Filter&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk sampler mip-map mode </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>Mip map sampler filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::SamplerMipmapMode (pvrvk::SamplerMipmapMode::e_NEAREST, pvrvk::SamplerMipmapMode::e_LINEAR)</dd></dl>

</div>
</div>
<a id="acb6a1fc2c108c439d57cb44f189099aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6a1fc2c108c439d57cb44f189099aa">&#9670;&nbsp;</a></span>convertToPVRVkNumSamples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::SampleCountFlags pvr::utils::convertToPVRVkNumSamples </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numSamples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk sample count </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numSamples</td><td>Number of samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::SampleCountFlags (pvrvk::SampleCountFlags::e_1_BIT, pvrvk::SampleCountFlags::e_2_BIT, etc)</dd></dl>

</div>
</div>
<a id="a7d459b2f7cdcedd6fc8ae939064dae1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d459b2f7cdcedd6fc8ae939064dae1d">&#9670;&nbsp;</a></span>convertToPVRVkPixelFormat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Format pvr::utils::convertToPVRVkPixelFormat </td>
          <td>(</td>
          <td class="paramtype">PixelFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorSpace&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>dataType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk pixel format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Pixel format</td></tr>
    <tr><td class="paramname">colorSpace</td><td>Color space of the format (lRGB, sRGB)</td></tr>
    <tr><td class="paramname">dataType</td><td>Type of the data (SignedByte, SignedInteger etc)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Format representing the pixel format</dd></dl>

</div>
</div>
<a id="a5985423e5f61cf77204a1157fa4783f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5985423e5f61cf77204a1157fa4783f1">&#9670;&nbsp;</a></span>convertToPVRVkPixelFormat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Format pvr::utils::convertToPVRVkPixelFormat </td>
          <td>(</td>
          <td class="paramtype">PixelFormat&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorSpace&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>outIsCompressedFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk pixel format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Pixel format</td></tr>
    <tr><td class="paramname">colorSpace</td><td>Color space of the format (lRGB, sRGB)</td></tr>
    <tr><td class="paramname">dataType</td><td>TYpe of the data (SignedByte, SignedInteger etc)</td></tr>
    <tr><td class="paramname">outIsCompressedFormat</td><td>Return if its a compressed format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Format representing the pixel format</dd></dl>

</div>
</div>
<a id="a116badc6ed0a108f3cc8ea515283a458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116badc6ed0a108f3cc8ea515283a458">&#9670;&nbsp;</a></span>convertToPVRVkVertexInputFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Format pvr::utils::convertToPVRVkVertexInputFormat </td>
          <td>(</td>
          <td class="paramtype">DataType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to pvrvk format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>Type of the data(Float32, Int32 etc)</td></tr>
    <tr><td class="paramname">width</td><td>The Width of the data type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pvrvk::Format (pvrvk::Format::e_R32_SFLOAT, pvrvk::Format::e_R32G32_SFLOAT etc)</dd></dl>

</div>
</div>
<a id="ad0c9ce4267ec635305fc87aba0b9d9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c9ce4267ec635305fc87aba0b9d9c2">&#9670;&nbsp;</a></span>create3dPlaneMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::create3dPlaneMesh </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateTexCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateNormalCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>outMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 3d plane mesh based on the width and depth specified. Texture coordinates and normal coordinates can also optionally be generated based on the generateTexCoords and generateNormalCoords flags respectively. The generated mesh will be returned as a pvr::assets::Mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the plane to generate.</td></tr>
    <tr><td class="paramname">depth</td><td>The depth of the plane to generate.</td></tr>
    <tr><td class="paramname">generateTexCoords</td><td>Specifies whether to generate texture coordinates for the plane.</td></tr>
    <tr><td class="paramname">generateNormalCoords</td><td>Specifies whether to generate normal coordinates for the plane.</td></tr>
    <tr><td class="paramname">outMesh</td><td>The generated pvr::assets::Mesh.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4933d5feabd4336b9023ba4b7fcd50f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4933d5feabd4336b9023ba4b7fcd50f5">&#9670;&nbsp;</a></span>createBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Buffer pvr::utils::createBuffer </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::BufferCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>requiredMemoryFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>optimalMemoryFlags</em> = <code>pvrvk::MemoryPropertyFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryAllocateFlags&#160;</td>
          <td class="paramname"><em>memoryAllocateFlags</em> = <code>pvrvk::MemoryAllocateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new buffer object and (optionally) allocate and bind memory for it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device on which to create the buffer</td></tr>
    <tr><td class="paramname">createInfo</td><td>A pvrvk::BufferCreateInfo structure controlling how the buffer will be created.</td></tr>
    <tr><td class="paramname">requiredMemoryFlags</td><td>The minimal set of memory property flags which are required for the PVRVk buffer to be created. If pvrvk::MemoryPropertyFlags::e_NONE is passed, no memory will be allocated for this buffer.</td></tr>
    <tr><td class="paramname">optimalMemoryFlags</td><td>The most optimal set of memory property flags which could be used by the memory backing the returned PVRVk buffer. If pvrvk::MemoryPropertyFlags::e_NONE is passed optimalMemoryFlags will be set to match requiredMemoryFlags.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
    <tr><td class="paramname">memoryAllocateFlags</td><td>A bitmask of pvrvk::MemoryAllocateFlagBits controlling the allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a valid object if success</dd></dl>
<p>. </p>

</div>
</div>
<a id="a7af92cf8d09982258386f5cc4e6f2f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af92cf8d09982258386f5cc4e6f2f80">&#9670;&nbsp;</a></span>createComputeShaderProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::createComputeShaderProgram </td>
          <td>(</td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>app</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>compShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a native shader program from a compute shader </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td>An AssetProvider to use for loading shaders from memory</td></tr>
    <tr><td class="paramname">compShaderFilename</td><td>The filename of a compute shader</td></tr>
    <tr><td class="paramname">defines</td><td>A list of defines to be added to the shaders</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines to be added to the shaders</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The program object</dd></dl>

</div>
</div>
<a id="a3c7a82ad08f5f77c574a75fc1c4eca9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7a82ad08f5f77c574a75fc1c4eca9a">&#9670;&nbsp;</a></span>createDebugUtilsCallbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html">DebugUtilsCallbacks</a> pvr::utils::createDebugUtilsCallbacks </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Instance &amp;&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a default set of debug utils messengers or debug callbacks using either VK_EXT_debug_utils or VK_EXT_debug_report respectively. The first callback will trigger an exception to be thrown when an error message is returned. The second callback will Log a message for errors and warnings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance from which the debug utils messengers or debug callbacks will be created depending on support for VK_EXT_debug_utils or VK_EXT_debug_report respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structpvr_1_1utils_1_1_debug_utils_callbacks.html" title="A simple wrapper structure which provides a more abstract representation of a set of debug utils mess...">pvr::utils::DebugUtilsCallbacks</a> structure which keeps alive the debug utils callbacks created.</dd></dl>

</div>
</div>
<a id="a5f9424bfa72230f6de076797e8a9c018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9424bfa72230f6de076797e8a9c018">&#9670;&nbsp;</a></span>createDepthStencilImageAndViews()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;pvrvk::ImageView&gt; pvr::utils::createDepthStencilImageAndViews </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>imageCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>depthFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Extent2D &amp;&#160;</td>
          <td class="paramname"><em>imageExtent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>imageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT&#160;|&#160;pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SampleCountFlags&#160;</td>
          <td class="paramname"><em>sampleCount</em> = <code>pvrvk::SampleCountFlags::e_1_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>dsImageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>dsImageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED. Use createAttachmentImages instead </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>DEPRECATED.</td></tr>
    <tr><td class="paramname">imageCount</td><td>DEPRECATED.</td></tr>
    <tr><td class="paramname">depthFormat</td><td>DEPRECATED.</td></tr>
    <tr><td class="paramname">imageExtent</td><td>DEPRECATED.</td></tr>
    <tr><td class="paramname">imageUsageFlags</td><td>DEPRECATED.</td></tr>
    <tr><td class="paramname">sampleCount</td><td>DEPRECATED.</td></tr>
    <tr><td class="paramname">dsImageAllocator</td><td>DEPRECATED.</td></tr>
    <tr><td class="paramname">dsImageAllocationCreateFlags</td><td>DEPRECATED.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DEPRECATED.&lt;/return&gt; </dd></dl>

</div>
</div>
<a id="a34226196d1cd435e8f19abecc2d3b0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34226196d1cd435e8f19abecc2d3b0eb">&#9670;&nbsp;</a></span>createDeviceAndQueues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Device pvr::utils::createDeviceAndQueues </td>
          <td>(</td>
          <td class="paramtype">pvrvk::PhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html">QueuePopulateInfo</a> *&#160;</td>
          <td class="paramname"><em>queueCreateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numQueueCreateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html">QueueAccessInfo</a> *&#160;</td>
          <td class="paramname"><em>outAccessInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceExtensions</em> = <code><a class="el" href="structpvr_1_1utils_1_1_device_extensions.html">DeviceExtensions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the pvrvk::Device and the queues </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physicalDevice</td><td>A physical device to use for creating the logical device.</td></tr>
    <tr><td class="paramname">queueCreateInfos</td><td>A pointer to a list of <a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html" title="A structure encapsulating the set of queue flags required for a particular queue retrieved via the he...">QueuePopulateInfo</a> structures specifying the required properties for each of the queues retrieved.</td></tr>
    <tr><td class="paramname">numQueueCreateInfos</td><td>The number of <a class="el" href="structpvr_1_1utils_1_1_queue_populate_info.html" title="A structure encapsulating the set of queue flags required for a particular queue retrieved via the he...">QueuePopulateInfo</a> structures provided.</td></tr>
    <tr><td class="paramname">outAccessInfo</td><td>A pointer to a list of <a class="el" href="structpvr_1_1utils_1_1_queue_access_info.html" title="A structure encapsulating the family id and queue id of a particular queue retrieved via the helper f...">QueueAccessInfo</a> structures specifying the properties for each of the queues retrieved.</td></tr>
    <tr><td class="paramname">deviceExtensions</td><td>A <a class="el" href="structpvr_1_1utils_1_1_device_extensions.html" title="Container for a list of device extensions to be used for initiailising a device using the helper func...">DeviceExtensions</a> structure which specifyies a list device extensions to try to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the created device</dd></dl>

</div>
</div>
<a id="aeadbbd98fbeac18389e58b089db81e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadbbd98fbeac18389e58b089db81e73">&#9670;&nbsp;</a></span>createImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::createImage </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>createInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>requiredMemoryFlags</em> = <code>pvrvk::MemoryPropertyFlags::e_DEVICE_LOCAL_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>optimalMemoryFlags</em> = <code>pvrvk::MemoryPropertyFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> &amp;&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new Image(sparse or with memory backing, depending on <em>flags</em> . The user should not call bindMemory on the image if sparse flags are used. <em>requiredMemoryFlags</em>  is ignored if <em>flags</em>  contains sparse binding flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device on which to create the image</td></tr>
    <tr><td class="paramname">createInfo</td><td>A pvrvk::ImageCreateInfo structure controlling how the image will be created.</td></tr>
    <tr><td class="paramname">requiredMemoryFlags</td><td>The minimal set of memory property flags which are required for the PVRVk Image to be created. If pvrvk::MemoryPropertyFlags::e_NONE is passed, no memory will be allocated for this Image.</td></tr>
    <tr><td class="paramname">optimalMemoryFlags</td><td>The most optimal set of memory property flags which could be used by the memory backing the returned PVRVk Image. If pvrvk::MemoryPropertyFlags::e_NONE is passed optimalMemoryFlags will be set to match requiredMemoryFlags.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created Imageobject on success, null Image on failure</dd></dl>

</div>
</div>
<a id="a680ef5943947e565f7d14aa9ff0393d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680ef5943947e565f7d14aa9ff0393d9">&#9670;&nbsp;</a></span>createInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Instance pvr::utils::createInstance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>applicationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a>&#160;</td>
          <td class="paramname"><em>apiVersion</em> = <code><a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html">VulkanVersion</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a> &amp;&#160;</td>
          <td class="paramname"><em>instanceExtensions</em> = <code><a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html">InstanceExtensions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a> &amp;&#160;</td>
          <td class="paramname"><em>instanceLayers</em> = <code><a class="el" href="structpvr_1_1utils_1_1_instance_layers.html">InstanceLayers</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for creating a Vulkan instance and supported physical devices using the appropriately set parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">applicationName</td><td>Used for setting the pApplicationName of the pvrvk::ApplicationInfo structure used when calling vkCreateInstance.</td></tr>
    <tr><td class="paramname">apiVersion</td><td>A <a class="el" href="structpvr_1_1utils_1_1_vulkan_version.html" title="The VulkanVersion structure provides an easy mechanism for constructing the Vulkan version for use wh...">VulkanVersion</a> structure used for setting the apiVersion of the pvrvk::ApplicationInfo structure used when creating the Vulkan instance.</td></tr>
    <tr><td class="paramname">instanceExtensions</td><td>An <a class="el" href="structpvr_1_1utils_1_1_instance_extensions.html" title="Container for a list of instance extensions to be used for initiailising an instance using the helper...">InstanceExtensions</a> structure which holds a list of instance extensions which will be checked for compatibility with the current Vulkan implementation before setting as the ppEnabledExtensionNames member of the pvrvk::InstanceCreateInfo used when creating the Vulkan instance.</td></tr>
    <tr><td class="paramname">instanceLayers</td><td>An <a class="el" href="structpvr_1_1utils_1_1_instance_layers.html" title="Container for a list of instance layers to be used for initiailising an instance using the helper fun...">InstanceLayers</a> structure which holds a list of instance layers which will be checked for compatibility with the current Vulkan implementation before setting as the ppEnabledLayerNames member of the pvrvk::InstanceCreateInfo used when creating the Vulkan instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created Instance.</dd></dl>

</div>
</div>
<a id="a0791bbf3f9ee51623e57639997a3238c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0791bbf3f9ee51623e57639997a3238c">&#9670;&nbsp;</a></span>createMultipleBuffersFromMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createMultipleBuffersFromMesh </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; pvrvk::Buffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outIbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>bufferAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh whose data will populate the buffers</td></tr>
    <tr><td class="paramname">outVbos</td><td>Reference to a std::vector of VBO handles where the data will be put. Buffers will be appended at the end.</td></tr>
    <tr><td class="paramname">outIbo</td><td>The IBO handle where the data will be put. No buffer needs to have been created on the handle. If no face data is present on the mesh, the handle will be null.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the mesh and create one pvrvk::Buffer for each data element (block of interleaved data) in the mesh. It is thus commonly used for for meshes containing multiple sets of interleaved data (for example, a VBO with static and a VBO with streaming data).</p>

</div>
</div>
<a id="ada646be2dd95421863b51714591825cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada646be2dd95421863b51714591825cf">&#9670;&nbsp;</a></span>createOnscreenFramebufferAndRenderPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::RenderPass pvr::utils::createOnscreenFramebufferAndRenderPass </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>swapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView *&#160;</td>
          <td class="paramname"><em>depthStencilImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_multi.html">Multi</a>&lt; pvrvk::Framebuffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>outFramebuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialSwapchainLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialDepthStencilLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentLoadOp&#160;</td>
          <td class="paramname"><em>colorLoadOp</em> = <code>pvrvk::AttachmentLoadOp::e_CLEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentStoreOp&#160;</td>
          <td class="paramname"><em>colorStoreOp</em> = <code>pvrvk::AttachmentStoreOp::e_STORE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentLoadOp&#160;</td>
          <td class="paramname"><em>depthStencilLoadOp</em> = <code>pvrvk::AttachmentLoadOp::e_CLEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentStoreOp&#160;</td>
          <td class="paramname"><em>depthStencilStoreOp</em> = <code>pvrvk::AttachmentStoreOp::e_DONT_CARE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outFramebuffers</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">swapchain</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">depthStencilImages</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">outRenderPass</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">initialSwapchainLayout</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">initialDepthStencilLayout</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">colorLoadOp</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">colorStoreOp</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">depthStencilLoadOp</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">depthStencilStoreOp</td><td>DEPRECATED</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba79655d85e1b12e2fa33fe431533cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba79655d85e1b12e2fa33fe431533cb">&#9670;&nbsp;</a></span>createOnscreenFramebuffers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ContainerType pvr::utils::createOnscreenFramebuffers </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>swapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::RenderPass &amp;&#160;</td>
          <td class="paramname"><em>renderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageView *&#160;</td>
          <td class="paramname"><em>depthStencilImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView *&#160;</td>
          <td class="paramname"><em>colorMultisampledImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView *&#160;</td>
          <td class="paramname"><em>depthStencilMultisampledImages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>&lt;sumary&gt;Creates a collection of Framebuffer objects, the same number of images as the Swapchain images. Will take into consideration properties of the swapchain and the renderpass to infer sizes, formats, multisampling etc., and also ensure all parameters are consistently passed. &lt;tparam name="ContainerType"&gt; The type of container to create the framebuffers. Must support resize() and indexing [].&lt;/tparam&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapchain</td><td>The swapchain for which framebuffers will be created. The swapchain images will used as Color attachments. If multisampled, they will be used as Color Resolve attachments instead.</td></tr>
    <tr><td class="paramname">renderPass</td><td>The renderpass for which the framebuffers will be created. Must of course be compatible with the swapchain images.</td></tr>
    <tr><td class="paramname">depthStencilImages</td><td>If the renderPass requires a depth buffer, MUST contain an array of Images compatible with the RenderPass definition. Will be used as Depth attachments. If multisampled, will be used as Depth Resolve attachments instead.</td></tr>
    <tr><td class="paramname">colorMultisampledImages</td><td>If the renderPass is multisampled, MUST contain an array of Multisampling Images to be used as Color attachments. Otherwise, MUST be null</td></tr>
    <tr><td class="paramname">depthMultisampledImages</td><td>If the renderPass is multisampled AND depthStencilImages is not null, MUST contain an array of Multisampling Images to be used as Depth attachments. Otherwise, MUST be null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A ContainerType containing the framebuffer objects created.</dd></dl>

</div>
</div>
<a id="a0324a015a6d6d4df8b7caa525416ff89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0324a015a6d6d4df8b7caa525416ff89">&#9670;&nbsp;</a></span>createOnScreenRenderPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::RenderPass pvr::utils::createOnScreenRenderPass </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>swapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasDepthStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Format&#160;</td>
          <td class="paramname"><em>depthStencilFormat</em> = <code>pvrvk::Format::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialSwapchainLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>initialDepthStencilLayout</em> = <code>pvrvk::ImageLayout::e_UNDEFINED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentLoadOp&#160;</td>
          <td class="paramname"><em>colorLoadOp</em> = <code>pvrvk::AttachmentLoadOp::e_CLEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentStoreOp&#160;</td>
          <td class="paramname"><em>colorStoreOp</em> = <code>pvrvk::AttachmentStoreOp::e_STORE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentLoadOp&#160;</td>
          <td class="paramname"><em>depthStencilLoadOp</em> = <code>pvrvk::AttachmentLoadOp::e_CLEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::AttachmentStoreOp&#160;</td>
          <td class="paramname"><em>depthStencilStoreOp</em> = <code>pvrvk::AttachmentStoreOp::e_DONT_CARE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SampleCountFlags&#160;</td>
          <td class="paramname"><em>samples</em> = <code>pvrvk::SampleCountFlags::e_1_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a renderpass for On-Screen (or other swapchain-based) rendering, based on the information contained in the swapchain. No other objects, (such as framebuffers and attachments) are created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">swapchain</td><td>A swapchain object. The data of the swapchain object will be used to ensure the renderpass created is compatible with this swapchain object</td></tr>
    <tr><td class="paramname">hasDepthStencil</td><td>CHANGED API v5.5. Pass "true" if the renderpass will be used for a framebuffer with depth or stencil. To port from the 5.3 code, please pass "true" if the old depthStencilImages parameter would not have been null.</td></tr>
    <tr><td class="paramname">depthStencilFormat</td><td>CHANGED API v5.5. If "hasDepthStencil" is true, pass the depth stencil format here. To port from the 5.4 code, retrieve the format from the first member of the old depthStencilImages array</td></tr>
    <tr><td class="paramname">initialSwapchainLayout</td><td>This is the layout with which the swapchain images will be in, in the beginning the renderpass.</td></tr>
    <tr><td class="paramname">initialDepthStencilLayout</td><td>This is the layout with which the depth/stencil images, if present, will be in, in the beginning the renderpass.</td></tr>
    <tr><td class="paramname">colorLoadOp</td><td>This is the LOAD op for the swapchain images, the operation performed on them when beginning the renderpass. Strongly prefer e_CLEAR if possible as it improves performance considerably compared to e_LOAD. For a multisampled renderpass, this is actually the load op for the Color Attachment, as the Color Resolve attachment is automatically e_DONT_CARE since it is always completely overwritten.</td></tr>
    <tr><td class="paramname">colorStoreOp</td><td>This is the STORE op for the swapchain images, the operation performed on the swapchain images at the end of the renderpass. This normally has to be e_STORE in order to render the images on screen. For a multisampled renderpass, this is actually the load op for the Color Resolve Attachment, as the Color attachment is automatically e_DONT_CARE since it cannot be used elsewhere since it is multisampled.</td></tr>
    <tr><td class="paramname">depthStencilLoadOp</td><td>This is the LOAD op for the depth/stencil images, the operation performed on the depth/stencil images images when beginning the renderpass. Normally has to be (and should be preferred for performance) e_CLEAR For a multisampled renderpass, this is actually the load op for the Depth Attachment, as the Depth Resolve attachment is automatically e_DONT_CARE since it is always completely overwritten.</td></tr>
    <tr><td class="paramname">colorStoreOp</td><td>This is the STORE op for the depth/stencil images, the operation performed on the depth/stencil images at the end of the renderpass. Strongly prefer e_DONT_CARE as the depth buffer almost never needs to be preserved between frames, and this can have a strong performance impact as it could even elide memory allocation for it. For a multisampled renderpass, this is actually the store op for the Depth Resolve Attachment, as the Depth attachment is automatically e_DONT_CARE since it cannot be used elsewhere since it is multisampled.</td></tr>
    <tr><td class="paramname">samples</td><td>The number of samples (if greater then e_1_BIT, the renderpass will be multisampled, so correct color and depth resolve items will be assumed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a270a77975b4db20cad82e6974a065a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270a77975b4db20cad82e6974a065a6d">&#9670;&nbsp;</a></span>createShaderModule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ShaderModule pvr::utils::createShaderModule </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Stream &amp;&#160;</td>
          <td class="paramname"><em>shaderSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ShaderStageFlags&#160;</td>
          <td class="paramname"><em>shaderStageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ShaderModuleCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>pvrvk::ShaderModuleCreateFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a ShaderModule from shader source using glslang. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A device from which to create the ShaderModule</td></tr>
    <tr><td class="paramname">shaderSource</td><td>A stream containing the shader source text data</td></tr>
    <tr><td class="paramname">shaderStageFlags</td><td>The type (stage) of the shader (vertex, fragment...)</td></tr>
    <tr><td class="paramname">flags</td><td>A set of pvrvk::ShaderModuleCreateFlags controlling how the ShaderModule will be created</td></tr>
    <tr><td class="paramname">defines</td><td>A number of preprocessor definitions that will be passed to the shader</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created ShaderModule object</dd></dl>

</div>
</div>
<a id="a55c8c338b47c9a66f58a39feb29c9fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c8c338b47c9a66f58a39feb29c9fbe">&#9670;&nbsp;</a></span>createShaderModule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ShaderModule pvr::utils::createShaderModule </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>shaderSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ShaderStageFlags&#160;</td>
          <td class="paramname"><em>shaderStageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ShaderModuleCreateFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>pvrvk::ShaderModuleCreateFlags::e_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a ShaderModule from shader source using glslang. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A device from which to create the ShaderModule</td></tr>
    <tr><td class="paramname">shaderSource</td><td>A string containing the shader source text data</td></tr>
    <tr><td class="paramname">shaderStageFlags</td><td>The type (stage) of the shader (vertex, fragment...)</td></tr>
    <tr><td class="paramname">flags</td><td>A set of pvrvk::ShaderModuleCreateFlags controlling how the ShaderModule will be created</td></tr>
    <tr><td class="paramname">defines</td><td>A number of preprocessor definitions that will be passed to the shader</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created ShaderModule object</dd></dl>

</div>
</div>
<a id="af094283fa2ed1a4434130f9eaf16feb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af094283fa2ed1a4434130f9eaf16feb6">&#9670;&nbsp;</a></span>createShaderProgram() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::createShaderProgram </td>
          <td>(</td>
          <td class="paramtype">const GLuint&#160;</td>
          <td class="paramname"><em>pShaders</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shadersCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **const&#160;</td>
          <td class="paramname"><em>attribNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>attribIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>attribsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>infolog</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a native shader program from an array of native shader handles. Will implicitly load on the current context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pShaders</td><td>An array of shaders</td></tr>
    <tr><td class="paramname">shadersCount</td><td>The number shaders in <em>pShaders</em> pShaders</td></tr>
    <tr><td class="paramname">attribNames</td><td>The list of names of the attributes in the shader, as a c-style array of c-style strings</td></tr>
    <tr><td class="paramname">attribIndices</td><td>The list of attribute binding indices, corresponding to <em>attribNames</em> attribNames</td></tr>
    <tr><td class="paramname">attribsCount</td><td>Number of attributes in <em>attribNames</em> attribNames and <em>attribIndices</em> attribIndices.</td></tr>
    <tr><td class="paramname">infolog</td><td>OPTIONAL Output, the infolog of the shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The program object</dd></dl>

</div>
</div>
<a id="a231b8395183676eeba042c9ee74e7409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231b8395183676eeba042c9ee74e7409">&#9670;&nbsp;</a></span>createShaderProgram() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::createShaderProgram </td>
          <td>(</td>
          <td class="paramtype">const IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>app</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vertShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fragShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>attribNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>attribIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numAttribs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a native shader program from a vertex and fragment shader </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td>An AssetProvider to use for loading shaders from memory</td></tr>
    <tr><td class="paramname">vertShaderFilename</td><td>The filename of a vertex shader</td></tr>
    <tr><td class="paramname">fragShaderFilename</td><td>The filename of a fragment shader</td></tr>
    <tr><td class="paramname">attribNames</td><td>The list of names of the attributes in the shader, as a c-style array of c-style strings</td></tr>
    <tr><td class="paramname">attribIndices</td><td>The list of attribute binding indices, corresponding to <em>attribNames</em> attribNames</td></tr>
    <tr><td class="paramname">numAttribs</td><td>Number of attributes in <em>attribNames</em> attribNames and <em>attribIndices</em> attribIndices.</td></tr>
    <tr><td class="paramname">defines</td><td>A list of defines to be added to the shaders</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines to be added to the shaders</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The program object</dd></dl>

</div>
</div>
<a id="a4f4c1b6200d2dd8d67e20af83e4dc7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4c1b6200d2dd8d67e20af83e4dc7cf">&#9670;&nbsp;</a></span>createShaderProgram() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::createShaderProgram </td>
          <td>(</td>
          <td class="paramtype">const IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>app</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vertShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tessCtrlShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tessEvalShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>geometryShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fragShaderFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>attribNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t *&#160;</td>
          <td class="paramname"><em>attribIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numAttribs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a native shader program from a vertex, fragment, tessellation control, tessellation evaluation and geometry shader </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">app</td><td>An AssetProvider to use for loading shaders from memory</td></tr>
    <tr><td class="paramname">vertShaderFilename</td><td>The filename of a vertex shader</td></tr>
    <tr><td class="paramname">tessCtrlShaderFilename</td><td>The filename of a tessellation control shader</td></tr>
    <tr><td class="paramname">tessEvalShaderFilename</td><td>The filename of a tessellation evaluation shader</td></tr>
    <tr><td class="paramname">geometryShaderFilename</td><td>The filename of a geometry shader</td></tr>
    <tr><td class="paramname">fragShaderFilename</td><td>The filename of a fragment shader</td></tr>
    <tr><td class="paramname">attribNames</td><td>The list of names of the attributes in the shader, as a c-style array of c-style strings</td></tr>
    <tr><td class="paramname">attribIndices</td><td>The list of attribute binding indices, corresponding to <em>attribNames</em> attribNames</td></tr>
    <tr><td class="paramname">numAttribs</td><td>Number of attributes in <em>attribNames</em> attribNames and <em>attribIndices</em> attribIndices.</td></tr>
    <tr><td class="paramname">defines</td><td>A list of defines to be added to the shaders</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines to be added to the shaders</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The program object</dd></dl>

</div>
</div>
<a id="aeecb636ae6f2c37e90259571ba245f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecb636ae6f2c37e90259571ba245f3b">&#9670;&nbsp;</a></span>createSingleBuffersFromMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMesh </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outVbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outIbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a single VBO and a single IBO from all the vertex data of a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh whose data will populate the buffers</td></tr>
    <tr><td class="paramname">outVbo</td><td>The VBO handle where the data will be put.</td></tr>
    <tr><td class="paramname">outIbo</td><td>The IBO handle where the data will be put. If no face data is present on the mesh, the handle will be null.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data. If data are not interleaved, they will be packed on the same VBO, each interleaved block (Data element on the mesh) will be appended at the end of the buffer, and the offsets will need to be calculated by the user when binding the buffer.</p>

</div>
</div>
<a id="a8b47e0a1077b70398aad03b73ea46f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b47e0a1077b70398aad03b73ea46f6c">&#9670;&nbsp;</a></span>createSingleBuffersFromMeshes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMeshes </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename VboContainer_::iterator&#160;</td>
          <td class="paramname"><em>vbos_where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>outIbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IboContainer_::iterator&#160;</td>
          <td class="paramname"><em>ibos_where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">meshIter</td><td>Iterator for a collection of meshes.</td></tr>
    <tr><td class="paramname">meshIterEnd</td><td>End Iterator for meshIter.</td></tr>
    <tr><td class="paramname">outVbos</td><td>Collection of pvrvk::Buffer handles. It will be used to insert one VBO per mesh.</td></tr>
    <tr><td class="paramname">outIbos</td><td>Collection of pvrvk::Buffer handles. It will be used to insert one IBO per mesh. If face data is not present on the mesh, a null handle will be inserted.</td></tr>
    <tr><td class="paramname">vbos_where</td><td>Iterator on outVbos - the position where the insertion will happen.</td></tr>
    <tr><td class="paramname">ibos_where</td><td>Iterator on outIbos - the position where the insertion will happen.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data (mesh.getNumDataElements() == 1). If more data elements are present (i.e. more than a single interleaved data element) , they will be packed in the sameVBO, with each interleaved block (Data element ) appended at the end of the buffer. It is then the user's responsibility to use the buffer correctly with the API (for example use bindbufferbase and similar) with the correct offsets.</p>

</div>
</div>
<a id="a7c3726d86dbda8ccaba9ed2c300b1fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3726d86dbda8ccaba9ed2c300b1fbe">&#9670;&nbsp;</a></span>createSingleBuffersFromMeshes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMeshes </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboInsertIterator_&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboInsertIterator_&#160;</td>
          <td class="paramname"><em>outIbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">meshIter</td><td>Iterator for a collection of meshes.</td></tr>
    <tr><td class="paramname">meshIterEnd</td><td>End Iterator for meshIter.</td></tr>
    <tr><td class="paramname">outVbos</td><td>std::inserter for a collection of pvrvk::Buffer handles. It will be used to insert one VBO per mesh.</td></tr>
    <tr><td class="paramname">outIbos</td><td>std::inserter for a collection of pvrvk::Buffer handles. It will be used to insert one IBO per mesh. If face data is not present on the mesh, a null handle will be inserted.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data (mesh.getNumDataElements() == 1). If more data elements are present (i.e. more than a single interleaved data element) , they will be packed in the sameVBO, with each interleaved block (Data element ) appended at the end of the buffer. It is then the user's responsibility to use the buffer correctly with the API (for example use bindbufferbase and similar) with the correct offsets. The std::inserter this function requires can be created from any container with an insert() function with (for example, for insertion at the end of a vector) std::inserter(std::vector, std::vector::end()) .</p>

</div>
</div>
<a id="a7710bb6fdcb3e45a8787cb4cc3f64e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7710bb6fdcb3e45a8787cb4cc3f64e6c">&#9670;&nbsp;</a></span>createSingleBuffersFromModel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromModel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboInsertIterator_&#160;</td>
          <td class="paramname"><em>vbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboInsertIterator_&#160;</td>
          <td class="paramname"><em>ibos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>requiresCommandBufferSubmission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>vmaAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_MAPPED_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device device where the buffers will be generated on</td></tr>
    <tr><td class="paramname">model</td><td>The model whose meshes will be used to generate the Buffers</td></tr>
    <tr><td class="paramname">vbos</td><td>An insert iterator to a std::pvrvk::Buffer container for the VBOs. Vbos will be inserted using this iterator.</td></tr>
    <tr><td class="paramname">ibos</td><td>An insert iterator to an std::pvrvk::Buffer container for the IBOs. Ibos will be inserted using this iterator.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands may be recorded for uploading mesh data to the created buffers. This command buffer will only be used when memory without e_HOST_VISIBLE_BIT memory property flags was allocated for the vbos or ibos.</td></tr>
    <tr><td class="paramname">requiresCommandBufferSubmission</td><td>Indicates whether commands have been recorded into the given command buffer.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
    <tr><td class="paramname">vmaAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively. The default vma::AllocationCreateFlags::e_MAPPED_BIT is valid even if HOST_VISIBLE is not used - these flags will be ignored in this case.</td></tr>
  </table>
  </dd>
</dl>
<p>This utility function will read all vertex data from the VBO. It is usually preferred for meshes meshes containing a single set of interleaved data. If multiple data elements (i.e. sets of interleaved data), each block will be successively placed after the other. The std::inserter this function requires can be created from any container with an insert() function with (for example, for insertion at the end of a vector) std::inserter(std::vector, std::vector::end()) .</p>

</div>
</div>
<a id="a3530d448cda15aea32f3395ca427957b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3530d448cda15aea32f3395ca427957b">&#9670;&nbsp;</a></span>createSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Surface pvr::utils::createSurface </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Instance &amp;&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::PhysicalDevice &amp;&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an abstract vulkan native platform surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The instance from which to create the native platform surface.</td></tr>
    <tr><td class="paramname">physicalDevice</td><td>A physical device from which to create the native platform surface.</td></tr>
    <tr><td class="paramname">window</td><td>A pointer to a NativeWindow used to create the windowing surface.</td></tr>
    <tr><td class="paramname">display</td><td>A pointer to a NativeDisplay used to create the windowing surface.</td></tr>
    <tr><td class="paramname">connection</td><td>A pointer to a NativeConnection used to create the windowing surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an abstract vulkan native platform surface.</dd></dl>

</div>
</div>
<a id="a1bbc4fadd267c20f1464ab4d21269bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbc4fadd267c20f1464ab4d21269bbf">&#9670;&nbsp;</a></span>createSwapchain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Swapchain pvr::utils::createSwapchain </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Surface &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>displayAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>swapchainImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; pvrvk::Format &gt; &amp;&#160;</td>
          <td class="paramname"><em>preferredColorFormats</em> = <code>std::vector&lt;&#160;pvrvk::Format&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pvrvk::Swapchain using a pre-initialised pvrvk::Device and pvrvk::Surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device to use for creating the pvrvk::Swapchain.</td></tr>
    <tr><td class="paramname">surface</td><td>A pvrvk::Surface from which surface capabilities, supported formats and presentation modes will be derived.</td></tr>
    <tr><td class="paramname">displayAttributes</td><td>A set of display attributes from which certain properties will be taken such as width, height, vsync mode and preferences for the number of pixels per channel.</td></tr>
    <tr><td class="paramname">swapchainImageUsageFlags</td><td>Specifies for what the swapchain images can be used for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the created pvrvk::Swapchain</dd></dl>

</div>
</div>
<a id="a33c374ce16fadf5be9b63e3675e51585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c374ce16fadf5be9b63e3675e51585">&#9670;&nbsp;</a></span>createSwapchainAndDepthStencilImageAndViews()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSwapchainAndDepthStencilImageAndViews </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Surface &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>displayAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>outSwapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_multi.html">Multi</a>&lt; pvrvk::ImageView &gt; &amp;&#160;</td>
          <td class="paramname"><em>outDepthStencilImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>swapchainImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_COLOR_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageUsageFlags &amp;&#160;</td>
          <td class="paramname"><em>dsImageUsageFlags</em> = <code>pvrvk::ImageUsageFlags::e_DEPTH_STENCIL_ATTACHMENT_BIT|pvrvk::ImageUsageFlags::e_TRANSIENT_ATTACHMENT_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a> &amp;&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>dsImageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_DEDICATED_MEMORY_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED. Either use createSwapchainRenderpassFramebuffers, or createSwapchain and createAttachments </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">surface</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">displayAttributes</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">outSwapchain</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">outDepthStencilImages</td><td></td></tr>
    <tr><td class="paramname">swapchainImageUsageFlags</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">dsImageUsageFlags</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">dsImageAllocator</td><td>DEPRECATED</td></tr>
    <tr><td class="paramname">dsImageAllocationCreateFlags</td><td>DEPRECATED</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8589ef735f2d2222a14ba470218c02af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8589ef735f2d2222a14ba470218c02af">&#9670;&nbsp;</a></span>createSwapchainRenderpassFramebuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_on_screen_objects.html">OnScreenObjects</a> pvr::utils::createSwapchainRenderpassFramebuffers </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Surface &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::DisplayAttributes &amp;&#160;</td>
          <td class="paramname"><em>displayAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1utils_1_1_create_swapchain_parameters.html">CreateSwapchainParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code><a class="el" href="structpvr_1_1utils_1_1_create_swapchain_parameters.html">CreateSwapchainParameters</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pvrvk::Framebuffer and RenderPass to use for 'default' rendering to the 'onscreen' color images. Default configuration is as follows. Formats and other configurations can be tweaked through displayAttributes and params. RenderPass: Attachment0: ColorAttachment swapchain image, finalLayout - PresentSrcKHR LoadOp - Clear StoreOp - Store Attachment1: DepthStencilAttachment finalLayout - DepthStencilAttachmentOptimal LoadOp - Clear StoreOp - Store If displayAttributes.aaSamples&gt;1 Multisampling will be enabled and the correct resolve attachments for multisampling will be created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device</td></tr>
    <tr><td class="paramname">surface</td><td>The surface for which the swapchain will be created.</td></tr>
    <tr><td class="paramname">displayAttributes</td><td>A configuration object for the requested objects. Can be retrieved from pvr::Shell, or just as easily populated manually.</td></tr>
    <tr><td class="paramname">params</td><td>A parameter object containing various different configurations to request for the created framebuffers etc. See the <a class="el" href="structpvr_1_1utils_1_1_create_swapchain_parameters.html" title="Parameter object for the createSwapchainRenderpassFramebuffers call. Defaults are sensible and immedi...">CreateSwapchainParameters</a> struct documentation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object containing the Swapchain, the Renderpass, the collection of created Framebuffers, and all the created attachments (depth/stencil/resolve).</dd></dl>

</div>
</div>
<a id="a2da693f264b2b719a77fc84bf0a32ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da693f264b2b719a77fc84bf0a32ec5">&#9670;&nbsp;</a></span>endCommandBufferDebugLabel() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::endCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a label region of work submitted to this command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The command buffer to which the debug label region should be ended</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12e6adce5bcec23564fd67553c9f4088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e6adce5bcec23564fd67553c9f4088">&#9670;&nbsp;</a></span>endCommandBufferDebugLabel() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::endCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>commandBufferBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a label region of work submitted to this base command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBufferBase</td><td>The command buffer base to which the debug label region should be ended</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adee1c88c7937b7a16127e810b75b2ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee1c88c7937b7a16127e810b75b2ab7">&#9670;&nbsp;</a></span>endCommandBufferDebugLabel() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::endCommandBufferDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>secondaryCommandBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a label region of work submitted to this secondary command buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondaryCommandBuffer</td><td>The secondary command buffer to which the debug label region should be ended</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a605300322093e44b7cd509533f14b4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605300322093e44b7cd509533f14b4fa">&#9670;&nbsp;</a></span>endQueueDebugLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::endQueueDebugLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a label region of work submitted to this queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The queue to which the debug label region should be ended</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12bdf9f718d984f14166f6b91b254b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12bdf9f718d984f14166f6b91b254b4c">&#9670;&nbsp;</a></span>generateCookTorranceBRDFLUT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::Texture pvr::utils::generateCookTorranceBRDFLUT </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapDim</em> = <code>256</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates BRDF lookup table image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapDim</td><td>Out put image size. Default 256</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generated texture containing a Cook Torrance BRDF Lookup table</dd></dl>

</div>
</div>
<a id="af47a86d6668e712e353dd8aea5e984c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47a86d6668e712e353dd8aea5e984c2">&#9670;&nbsp;</a></span>generateIrradianceMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::generateIrradianceMap </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>environmentMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::Texture &amp;&#160;</td>
          <td class="paramname"><em>outTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint &amp;&#160;</td>
          <td class="paramname"><em>outTextureGles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSize</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapNumSamples</em> = <code>128</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mipmapped diffuse irradiance map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">environmentMap</td><td>The OpenGL ES texture to use as the source for the diffuse irradiance map.</td></tr>
    <tr><td class="paramname">outTexture</td><td>a pvr::Texture to use for the output diffuse irradiance map.</td></tr>
    <tr><td class="paramname">outTextureGles</td><td>An OpenGL ES texture to use as the output for the diffuse irradiance map.</td></tr>
    <tr><td class="paramname">mapSize</td><td>The size of the prefiltered environment map</td></tr>
    <tr><td class="paramname">mapNumSamples</td><td>The number of samples to use when generating the diffuse irradiance map</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24c4e93b0c93756506ebd6f2ca1b399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24c4e93b0c93756506ebd6f2ca1b399">&#9670;&nbsp;</a></span>generateIrradianceMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Texture pvr::utils::generateIrradianceMap </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView&#160;</td>
          <td class="paramname"><em>environmentMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::PixelFormat&#160;</td>
          <td class="paramname"><em>outputPixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::VariableType&#160;</td>
          <td class="paramname"><em>outputVariableType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSize</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapNumSamples</em> = <code>16384</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a mipmapped diffuse irradiance map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A queue to which command buffers containing commands for generating the diffuse irradiance map will be added.</td></tr>
    <tr><td class="paramname">environmentMap</td><td>The source environment map to use in the generation</td></tr>
    <tr><td class="paramname">outputPixelFormat</td><td>The format to use for the diffuse irradiance map generated using this function.</td></tr>
    <tr><td class="paramname">outputVariableType</td><td>The variable type to use for the generated irradiance map generated using this function.</td></tr>
    <tr><td class="paramname">mapSize</td><td>The size of the map to generate</td></tr>
    <tr><td class="paramname">mapNumSamples</td><td>The number of samples to use when generating the diffuse irradiance map</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pvr::Texture generated</dd></dl>

</div>
</div>
<a id="afc8a7f6f6edde3ee63bffd29af44b0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8a7f6f6edde3ee63bffd29af44b0e8">&#9670;&nbsp;</a></span>generatePreFilteredMapMipMapStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::generatePreFilteredMapMipMapStyle </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>environmentMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::Texture &amp;&#160;</td>
          <td class="paramname"><em>outTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint &amp;&#160;</td>
          <td class="paramname"><em>outTextureGles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroRoughnessIsExternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMipLevelsToDiscard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapNumSamples</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate specular irradiance map. Each level of the specular mip map gets blurred corresponding to a roughness value from 0 to 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">environmentMap</td><td>The OpenGL ES texture to use as the source for the prefiltered environment map.</td></tr>
    <tr><td class="paramname">outTexture</td><td>a pvr::Texture to use for the output prefiltered environment map.</td></tr>
    <tr><td class="paramname">outTextureGles</td><td>An OpenGL ES texture to use as the output for the prefiltered environment map.</td></tr>
    <tr><td class="paramname">mapSize</td><td>The size of the prefiltered environment map</td></tr>
    <tr><td class="paramname">zeroRoughnessIsExternal</td><td>Denotes that the source environment map itself will be used for the prefiltered environment map mip map level corresponding to a roughness of 0.</td></tr>
    <tr><td class="paramname">numMipLevelsToDiscard</td><td>Denotes the number of mip map levels to discard from the bottom of the chain. Generally using the last n mip maps may introduce artifacts.</td></tr>
    <tr><td class="paramname">mapNumSamples</td><td>The number of samples to use when generating the prefiltered environment map</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b892efb9cd1baa5753d0d180a2d3d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b892efb9cd1baa5753d0d180a2d3d94">&#9670;&nbsp;</a></span>generatePreFilteredMapMipmapStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Texture pvr::utils::generatePreFilteredMapMipmapStyle </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView&#160;</td>
          <td class="paramname"><em>environmentMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::PixelFormat&#160;</td>
          <td class="paramname"><em>outputPixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::VariableType&#160;</td>
          <td class="paramname"><em>outputVariableType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zeroRoughnessIsExternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numMipLevelsToDiscard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mapNumSamples</em> = <code>65536</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate specular irradiance map. Each level of the specular mip map gets blurred corresponding to a roughness value from 0 to 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A queue to which command buffers containing commands for generating the diffuse irradiance map will be added.</td></tr>
    <tr><td class="paramname">environmentMap</td><td>The source environment map to use in the generation</td></tr>
    <tr><td class="paramname">outputPixelFormat</td><td>The format to use for the diffuse irradiance map generated using this function.</td></tr>
    <tr><td class="paramname">outputVariableType</td><td>The variable type to use for the generated irradiance map generated using this function</td></tr>
    <tr><td class="paramname">mapSize</td><td>The size of the map to generate</td></tr>
    <tr><td class="paramname">zeroRoughnessIsExternal</td><td>Denotes that the source environment map itself will be used for the prefiltered environment map mip map level corresponding to a roughness of 0.</td></tr>
    <tr><td class="paramname">numMipLevelsToDiscard</td><td>Denotes the number of mip map levels to discard from the bottom of the chain. Generally using the last n mip maps may introduce artifacts.</td></tr>
    <tr><td class="paramname">mapNumSamples</td><td>The number of samples to use when generating the prefiltered environment map</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pvr::Texture generated</dd></dl>

</div>
</div>
<a id="a9af7fff69d5da0331018f68f0d95ba8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af7fff69d5da0331018f68f0d95ba8a">&#9670;&nbsp;</a></span>generateTextureAtlas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::generateTextureAtlas </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::Image *&#160;</td>
          <td class="paramname"><em>inputImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Rect2Df *&#160;</td>
          <td class="paramname"><em>outUVs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>inputImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageView *&#160;</td>
          <td class="paramname"><em>outImageView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TextureHeader *&#160;</td>
          <td class="paramname"><em>outDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>cmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for generating a texture atlas based on a set of images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device used to create the texture atlas.</td></tr>
    <tr><td class="paramname">inputImages</td><td>A list of input images used to generate the texture atlas from.</td></tr>
    <tr><td class="paramname">outUVs</td><td>A pointer to a set of UVs corresponding to the position of the images within the generated texture atlas.</td></tr>
    <tr><td class="paramname">numImages</td><td>The number of textures used for generating the texture atlas.</td></tr>
    <tr><td class="paramname">inputImageLayout</td><td>The current layout of the input images. All input images must be in the layout specified.</td></tr>
    <tr><td class="paramname">outImageView</td><td>The generated texture atlas returned by the function</td></tr>
    <tr><td class="paramname">outDescriptor</td><td>The texture header for the generated texture atlas</td></tr>
    <tr><td class="paramname">cmdBuffer</td><td>A previously constructured command buffer which will be used by the utility function for various operations such as creating images.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true if success</dd></dl>

</div>
</div>
<a id="a56ce1f5bcf625224715988176c3519a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ce1f5bcf625224715988176c3519a2">&#9670;&nbsp;</a></span>getColorBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getColorBits </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>redBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>greenBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>blueBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>alphaBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the number of color bits per pixel for the given pvrvk::Format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A format to calculate the number of bits for</td></tr>
    <tr><td class="paramname">redBits</td><td>The number of red bits per pixel</td></tr>
    <tr><td class="paramname">greenBits</td><td>The number of green bits per pixel</td></tr>
    <tr><td class="paramname">blueBits</td><td>The number of blue bits per pixel</td></tr>
    <tr><td class="paramname">alphaBits</td><td>The number of alpha channel bits per pixel</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bcac1e9af1869244329d12c291200a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcac1e9af1869244329d12c291200a5">&#9670;&nbsp;</a></span>getDepthStencilBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getDepthStencilBits </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>depthBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>stencilBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the number of depth and stencil bits per pixel for the given pvrvk::Format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A format to calculate the number of bits for</td></tr>
    <tr><td class="paramname">depthBits</td><td>The number of depth bits per pixel</td></tr>
    <tr><td class="paramname">stencilBits</td><td>The number of stencil bits per pixel</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a811320035b806bb4e727d9ffc7f68873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811320035b806bb4e727d9ffc7f68873">&#9670;&nbsp;</a></span>getGlErrorString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* pvr::utils::getGlErrorString </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>apiError</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a string representation of an OpenGLES error code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apiError</td><td>The OpenGLES error code to stringify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the given OpenGLES error code.</dd></dl>

</div>
</div>
<a id="a6bbf98fde377992e9e7e0d23f38a9dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbf98fde377992e9e7e0d23f38a9dcc">&#9670;&nbsp;</a></span>getMemoryTypeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getMemoryTypeIndex </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::PhysicalDevice &amp;&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>allowedMemoryTypeBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>requiredMemoryProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::MemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>optimalMemoryProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>outMemoryTypeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::MemoryPropertyFlags &amp;&#160;</td>
          <td class="paramname"><em>outMemoryPropertyFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function for retrieving a memory type index for a suitable memory type which supports the memory type bits specified. If the optimal set of memory properties are supported then return the corresponding memory type index otherwise check for availablility of the required set of memory properties. This allows for implementations to optionally request the use of a more optimal set of memory properties whilst still preserving the ability to retrieve the required set of memory properties as a fallback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physicalDevice</td><td>The physical device whose set of pvrvk::PhysicalDeviceMemoryProperties will be used to determine support for the requested memory properties.</td></tr>
    <tr><td class="paramname">allowedMemoryTypeBits</td><td>The memory type bits allowed. The required memory type chosen must be one of those allowed.</td></tr>
    <tr><td class="paramname">optimalMemoryProperties</td><td>A set of optimal memory properties which may be preferred by the application.</td></tr>
    <tr><td class="paramname">requiredMemoryProperties</td><td>The set of memory properties which must be present.</td></tr>
    <tr><td class="paramname">outMemoryTypeIndex</td><td>The returned memory type index.</td></tr>
    <tr><td class="paramname">outMemoryPropertyFlags</td><td>The returned set of memory property flags.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b2d4df80d31e3e63923ab1d68152ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2d4df80d31e3e63923ab1d68152ace">&#9670;&nbsp;</a></span>getNumSamplesFromSampleCountFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t pvr::utils::getNumSamplesFromSampleCountFlags </td>
          <td>(</td>
          <td class="paramtype">pvrvk::SampleCountFlags&#160;</td>
          <td class="paramname"><em>sampleCountFlags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert pvrvk sample count to the number of samples it is equivalent to </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampleCountFlags</td><td>The pvrvk sample count to determine the number of samples for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of samples equivalent to the pvrvk sample count flags</dd></dl>

</div>
</div>
<a id="a291e4ede9083ee35cc595b7775a6f41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291e4ede9083ee35cc595b7775a6f41c">&#9670;&nbsp;</a></span>getOpenGLFormat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLFormat </td>
          <td>(</td>
          <td class="paramtype">ImageStorageFormat&#160;</td>
          <td class="paramname"><em>storageFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glTypeSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isCompressedFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the OpenGL ES texture formats for a texture with the provided ImageStorageFormat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storageFormat</td><td>The pvr::ImageStorageFormat to retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">glFormat</td><td>The OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">glType</td><td>The OpenGL ES type corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">glTypeSize</td><td>The OpenGL ES type size corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
    <tr><td class="paramname">isCompressedFormat</td><td>Specifies whether the OpenGL ES format retrieved is a compressed format.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad17214254f1b21d40271dac7b2a4b691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17214254f1b21d40271dac7b2a4b691">&#9670;&nbsp;</a></span>getOpenGLFormat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLFormat </td>
          <td>(</td>
          <td class="paramtype">PixelFormat&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorSpace&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>glTypeSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isCompressedFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the OpenGL ES texture formats for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>The pvr::PixelFormat to retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">colorSpace</td><td>The pvr::ColorSpace to retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">dataType</td><td>The pvr::VariableTypeto retrieve a corresponding set of OpenGL ES texture formats for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">glFormat</td><td>The OpenGL ES format corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">glType</td><td>The OpenGL ES type corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">glTypeSize</td><td>The OpenGL ES type size corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType.</td></tr>
    <tr><td class="paramname">isCompressedFormat</td><td>Specifies whether the OpenGL ES format retrieved is a compressed format.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71a6472c33618ce49ded8e029b463429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a6472c33618ce49ded8e029b463429">&#9670;&nbsp;</a></span>getOpenGLStorageFormat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLStorageFormat </td>
          <td>(</td>
          <td class="paramtype">ImageStorageFormat&#160;</td>
          <td class="paramname"><em>storageFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the internal OpenGL ES texture formats for a texture with the provided ImageStorageFormat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storageFormat</td><td>The pvr::ImageStorageFormat to retrieve a the internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 'True' if the utility function was able to successfully determin the internal OpenGL ES format corresponding to the provided pvr::ImageStorageFormat storageFormat.</dd></dl>

</div>
</div>
<a id="a9faeae4c6a35b0080b0b6031151e53e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faeae4c6a35b0080b0b6031151e53e2">&#9670;&nbsp;</a></span>getOpenGLStorageFormat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::getOpenGLStorageFormat </td>
          <td>(</td>
          <td class="paramtype">PixelFormat&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ColorSpace&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableType&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum &amp;&#160;</td>
          <td class="paramname"><em>glInternalFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the internal OpenGL ES texture format for a texture with pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>The pvr::PixelFormat to retrieve a corresponding internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">colorSpace</td><td>The pvr::ColorSpace to retrieve a corresponding internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">dataType</td><td>The pvr::VariableTypeto retrieve a corresponding internal OpenGL ES texture format for.</td></tr>
    <tr><td class="paramname">glInternalFormat</td><td>The internal OpenGL ES format corresponding to the provided pvr::PixelFormat pixelFormat, pvr::ColorSpace colorSpace and pvr::VariableType dataType</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb45f4b332ee2574510ef0155a590b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb45f4b332ee2574510ef0155a590b8f">&#9670;&nbsp;</a></span>imageUploadAsyncWorker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::imageUploadAsyncWorker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1utils.html#ab251744ba4295771d35ea8f3ee497e0f">ImageUploadFuture</a>&#160;</td>
          <td class="paramname"><em>uploadFuture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a mechanism for kicking an asynchronous image upload worker </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uploadFuture</td><td>An image upload future to be uploaded on a separate thread.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93735fa36d5aedc03cf746dfa208a4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93735fa36d5aedc03cf746dfa208a4b5">&#9670;&nbsp;</a></span>inferAspectFromFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageAspectFlags pvr::utils::inferAspectFromFormat </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infers the pvrvk::ImageAspectFlags from the pvrvk::Format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>A format to infer pvrvk::ImageAspectFlags from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pvrvk::ImageAspectFlags inferred based on the pvrvk::Format provided</dd></dl>

</div>
</div>
<a id="ab77d5528ee9f9dc1f4dda381175b89eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77d5528ee9f9dc1f4dda381175b89eb">&#9670;&nbsp;</a></span>insertDebugUtilsLabel() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::insertDebugUtilsLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a single debug label any time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The command buffer to which the debug label should be inserted</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to insert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3adba7320aa2b924adc48cfa5e043ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3adba7320aa2b924adc48cfa5e043ed">&#9670;&nbsp;</a></span>insertDebugUtilsLabel() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::insertDebugUtilsLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>commandBufferBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a single debug label any time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBufferBase</td><td>The base command buffer to which the debug label should be inserted</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to insert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2938b3543ae68e23f0f2eb348a786ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2938b3543ae68e23f0f2eb348a786ae9">&#9670;&nbsp;</a></span>insertDebugUtilsLabel() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::insertDebugUtilsLabel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>secondaryCommandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::DebugUtilsLabel &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a single debug label any time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondaryCommandBuffer</td><td>The secondary command buffer to which the debug label should be inserted</td></tr>
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to insert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7151c7b74ff657fc17ff09c0ab114a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7151c7b74ff657fc17ff09c0ab114a07">&#9670;&nbsp;</a></span>isFormatDepthStencil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::isFormatDepthStencil </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the format is a depth stencil format </p>
<p>SIMPLE CALCULATIONS ///////////////////</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Format to querry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the pvrvk::Format specified is a depth or stencil format</dd></dl>

</div>
</div>
<a id="a59222cc49624a76fab4d4f65e3337ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59222cc49624a76fab4d4f65e3337ac3">&#9670;&nbsp;</a></span>isImageUsageSupportedBySurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::isImageUsageSupportedBySurface </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::SurfaceCapabilitiesKHR &amp;&#160;</td>
          <td class="paramname"><em>surfaceCapabilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>imageUsage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function used to determine whether the SurfaceCapabilitiesKHR supportedUsageFlags member contains the specified image usage and therefore can be used in the intended way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceCapabilities</td><td>A SurfaceCapabilitiesKHR structure returned via a call to PhysicalDevice-&gt;getSurfaceCapabilities().</td></tr>
    <tr><td class="paramname">imageUsage</td><td>A set of image usage flags which should be checked for support.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"true" if the supportedUsageFlags member of the SurfaceCapabilitiesKHR structure contains the specified imageUsage flag bits.</dd></dl>

</div>
</div>
<a id="a370ec57dd60df6f8d8327619a8a90178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370ec57dd60df6f8d8327619a8a90178">&#9670;&nbsp;</a></span>loadAndUploadImage() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::loadAndUploadImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a id="a138104e7cebf7941707336c0418bc3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138104e7cebf7941707336c0418bc3c8">&#9670;&nbsp;</a></span>loadAndUploadImage() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::loadAndUploadImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A secondary command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a id="ae7751d185a203ad3f8d19fc1bb5eb6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7751d185a203ad3f8d19fc1bb5eb6e2">&#9670;&nbsp;</a></span>loadAndUploadImage() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::loadAndUploadImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a id="a868fafd2e077cfc7281c45c64677e47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868fafd2e077cfc7281c45c64677e47a">&#9670;&nbsp;</a></span>loadAndUploadImageAndView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::loadAndUploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a id="af9a49bb33bec83289c2620a84afd9c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a49bb33bec83289c2620a84afd9c2a">&#9670;&nbsp;</a></span>loadAndUploadImageAndView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::loadAndUploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>assetProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Texture *&#160;</td>
          <td class="paramname"><em>outAssetTexture</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">fileName</td><td>The filename of a source texture from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A secondary command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">assetProvider</td><td>Specifies an asset provider to use for loading the texture from system memory.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>Specifies the usage flags for the image being created.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">outAssetTexture</td><td>A pointer to a created pvr::texture.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Image Object uploaded.</dd></dl>

</div>
</div>
<a id="a8cb2e88f9124d29c4a2498783cf4e1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb2e88f9124d29c4a2498783cf4e1c9">&#9670;&nbsp;</a></span>loadShader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::loadShader </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>shaderSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShaderType&#160;</td>
          <td class="paramname"><em>shaderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load shader from shader source. Will implicitly load on the current context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderSource</td><td>A string containing the shader source text data</td></tr>
    <tr><td class="paramname">shaderType</td><td>The type (stage) of the shader (vertex, fragment...)</td></tr>
    <tr><td class="paramname">defines</td><td>A number of preprocessor definitions that will be passed to the shader</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shader object</dd></dl>

</div>
</div>
<a id="ab6587db0405c15cfceeb768f0a740dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6587db0405c15cfceeb768f0a740dca">&#9670;&nbsp;</a></span>loadShader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint pvr::utils::loadShader </td>
          <td>(</td>
          <td class="paramtype">const Stream &amp;&#160;</td>
          <td class="paramname"><em>shaderSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShaderType&#160;</td>
          <td class="paramname"><em>shaderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>defines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDefines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load shader from shader source. Will implicitly load on the current context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shaderSource</td><td>A stream containing the shader source text data</td></tr>
    <tr><td class="paramname">shaderType</td><td>The type (stage) of the shader (vertex, fragment...)</td></tr>
    <tr><td class="paramname">defines</td><td>A number of preprocessor definitions that will be passed to the shader</td></tr>
    <tr><td class="paramname">numDefines</td><td>The number of defines</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The shader object</dd></dl>

</div>
</div>
<a id="a1cbbbd1665449ea70d772de63595c806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbbbd1665449ea70d772de63595c806">&#9670;&nbsp;</a></span>logMessageDebugReportCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VKAPI_ATTR VkBool32 VKAPI_CALL pvr::utils::logMessageDebugReportCallback </td>
          <td>(</td>
          <td class="paramtype">VkDebugReportFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDebugReportObjectTypeEXT&#160;</td>
          <td class="paramname"><em>objectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>messageCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pLayerPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application DebugReportCallback function providing logging for various events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Indicates the VkDebugReportFlagsEXT triggering the callback.</td></tr>
    <tr><td class="paramname">objectType</td><td>The type of the object being used/created when the event was triggered.</td></tr>
    <tr><td class="paramname">object</td><td>The object where the issue was detected</td></tr>
    <tr><td class="paramname">location</td><td>A component defined value indicating the location of the trigger</td></tr>
    <tr><td class="paramname">messageCode</td><td>A layer defined value indicating the test which triggered the callback</td></tr>
    <tr><td class="paramname">pLayerPrefix</td><td>Abbreviation of the component making the callback</td></tr>
    <tr><td class="paramname">pMessage</td><td>String detailing the trigger conditions</td></tr>
    <tr><td class="paramname">pUserData</td><td>User data given when the callback was created</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an indication to the calling layer as to whether the Vulkan call should be aborted or not. Applications should always return VK_FALSE so that they see the same behavior with and without validation layers enabled.</dd></dl>

</div>
</div>
<a id="a5e37e4f2f8723d81f2f60ff7c9ffebdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e37e4f2f8723d81f2f60ff7c9ffebdf">&#9670;&nbsp;</a></span>logMessageDebugUtilsMessengerCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VKAPI_ATTR VkBool32 VKAPI_CALL pvr::utils::logMessageDebugUtilsMessengerCallback </td>
          <td>(</td>
          <td class="paramtype">VkDebugUtilsMessageSeverityFlagBitsEXT&#160;</td>
          <td class="paramname"><em>messageSeverity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDebugUtilsMessageTypeFlagsEXT&#160;</td>
          <td class="paramname"><em>messageTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDebugUtilsMessengerCallbackDataEXT *&#160;</td>
          <td class="paramname"><em>pCallbackData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application DebugUtilsMessengerCallback function providing logging for various events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageSeverity</td><td>Indicates the VkDebugUtilsMessageSeverityFlagBitsEXT which define the severity of any message.</td></tr>
    <tr><td class="paramname">messageTypes</td><td>A set of VkDebugUtilsMessageTypeFlagsEXT which define the type of the message.</td></tr>
    <tr><td class="paramname">pCallbackData</td><td>Contains all the callback related data in the VkDebugUtilsMessengerCallbackDataEXT structure</td></tr>
    <tr><td class="paramname">pUserData</td><td>The user data provided when the VkDebugUtilsMessengerEXT was created</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an indication to the calling layer as to whether the Vulkan call should be aborted or not. Applications should always return VK_FALSE so that they see the same behavior with and without validation layers enabled.</dd></dl>

</div>
</div>
<a id="aee21903727c73558ad8e3cf936917344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee21903727c73558ad8e3cf936917344">&#9670;&nbsp;</a></span>mapDebugReportFlagsToLogLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogLevel pvr::utils::mapDebugReportFlagsToLogLevel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::DebugReportFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a set of DebugReportFlagsEXT to a particular type of log message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>The DebugReportFlagsEXT to map to a LogLevel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a LogLevel deemed to correspond to the given pvrvk::DebugReportFlagsEXT.</dd></dl>

</div>
</div>
<a id="abbd1f30f49a0d36c9d932437e902d2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd1f30f49a0d36c9d932437e902d2bb">&#9670;&nbsp;</a></span>mapDebugUtilsMessageSeverityFlagsToLogLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogLevel pvr::utils::mapDebugUtilsMessageSeverityFlagsToLogLevel </td>
          <td>(</td>
          <td class="paramtype">pvrvk::DebugUtilsMessageSeverityFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a set of DebugUtilsMessageSeverityFlagsEXT to a particular type of log message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>The DebugUtilsMessageSeverityFlagsEXT to map to a LogLevel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a LogLevel deemed to correspond to the given pvrvk::DebugUtilsMessageSeverityFlagsEXT.</dd></dl>

</div>
</div>
<a id="a9c0c12df7c704cd669d4bef29942555e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0c12df7c704cd669d4bef29942555e">&#9670;&nbsp;</a></span>packSamplerFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PackedSamplerFilter pvr::utils::packSamplerFilter </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Filter&#160;</td>
          <td class="paramname"><em>mini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Filter&#160;</td>
          <td class="paramname"><em>magni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SamplerMipmapMode&#160;</td>
          <td class="paramname"><em>mip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Created a packed sampler filter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mini</td><td>The minification filter</td></tr>
    <tr><td class="paramname">magni</td><td>The magnification filter</td></tr>
    <tr><td class="paramname">mip</td><td>The sampler mipmap mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The packed sampler filter</dd></dl>

</div>
</div>
<a id="a98e4ac9990af6eaf6b9bf0928f2bd07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e4ac9990af6eaf6b9bf0928f2bd07d">&#9670;&nbsp;</a></span>populateClearValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateClearValues </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::RenderPass &amp;&#160;</td>
          <td class="paramname"><em>renderpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ClearValue &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ClearValue &amp;&#160;</td>
          <td class="paramname"><em>clearDepthStencilValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ClearValue *&#160;</td>
          <td class="paramname"><em>outClearValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate color and depthstencil clear values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderpass</td><td>The renderpass is used to determine the number of attachments and their formats from which a decision will be as to whether the provided clearColor or clearDepthStencilValue will be used for the corresponding pvrvk::ClearValue structure for each attachment.</td></tr>
    <tr><td class="paramname">clearColor</td><td>A pvrvk::ClearValue which will be used as the clear color value for the renderpass attachments with color formats</td></tr>
    <tr><td class="paramname">clearDepthStencilValue</td><td>A pvrvk::ClearValue which will be used as the depth stencil value for the renderpass attachments with depth stencil formats</td></tr>
    <tr><td class="paramname">outClearValues</td><td>A pointer to an array of pvrvk::ClearValue structures which should have size greater than or equal to the number of renderpass attachments.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0c2fd1a13ff3b5e9086e13ea4608c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c2fd1a13ff3b5e9086e13ea4608c43">&#9670;&nbsp;</a></span>populateInputAssemblyFromMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a> *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineVertexInputStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>vertexCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineInputAssemblerStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>inputAssemblerCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>numOutBuffers</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh from which to retrieve vertex attributes, vertex buffer strides and primitive topology information from.</td></tr>
    <tr><td class="paramname">bindingMap</td><td>A pointer to an array of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a> structures which specify the semantic names and binding indices of any vertex attributes to retrieve.</td></tr>
    <tr><td class="paramname">numBindings</td><td>Specifies the number of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a> structures in the array pointed to by bindingMap.</td></tr>
    <tr><td class="paramname">vertexCreateInfo</td><td>A pvrvk::PipelineVertexInputStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">inputAssemblerCreateInfo</td><td>A pvrvk::InputAssemblerStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">numOutBuffers</td><td>A pointer to an unsigned integer which will set to specify the number of buffers required to create buffers for to use the mesh vertex attributes.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94c295af45dc688c117ebf5993e55373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c295af45dc688c117ebf5993e55373">&#9670;&nbsp;</a></span>populateInputAssemblyFromMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a> *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineVertexInputStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>vertexCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineInputAssemblerStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>inputAssemblerCreateInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>numOutBuffers</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills out input assembly and vertex input state structures using a mesh and a list of corresponding <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html" title="Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name.">VertexBindings_Name</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh from which to retrieve vertex attributes, vertex buffer strides and primitive topology information from.</td></tr>
    <tr><td class="paramname">bindingMap</td><td>A pointer to an array of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html" title="Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name.">VertexBindings_Name</a> structures which specify the semantic and binding names of any vertex attributes to retrieve.</td></tr>
    <tr><td class="paramname">numBindings</td><td>Specifies the number of <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html" title="Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.">VertexBindings</a> structures in the array pointed to by bindingMap.</td></tr>
    <tr><td class="paramname">vertexCreateInfo</td><td>A pvrvk::PipelineVertexInputStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">inputAssemblerCreateInfo</td><td>A pvrvk::InputAssemblerStateCreateInfo structure which will be filled by this utility function.</td></tr>
    <tr><td class="paramname">numOutBuffers</td><td>A pointer to an unsigned integer which will set to specify the number of buffers required to create buffers for to use the mesh vertex attributes.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e9a18d03439c5efe7d88dbb3c16b783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9a18d03439c5efe7d88dbb3c16b783">&#9670;&nbsp;</a></span>populateViewportStateCreateInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::populateViewportStateCreateInfo </td>
          <td>(</td>
          <td class="paramtype">const pvrvk::Framebuffer &amp;&#160;</td>
          <td class="paramname"><em>framebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::PipelineViewportStateCreateInfo &amp;&#160;</td>
          <td class="paramname"><em>outCreateInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills out a pvrvk::ViewportStateCreateInfo structure setting parameters for a 'default' viewport and scissor based on the specified frame buffer dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">framebuffer</td><td>An input Framebuffer object from which to take dimensions used to initialise a pvrvk::ViewportStateCreateInfo structure.</td></tr>
    <tr><td class="paramname">outCreateInfo</td><td>A pvrvk::ViewportStateCreateInfo structure which will have its viewport and scissor members set based on the framebuffers dimensions.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee378b23390266dcaa61b724e0a29808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee378b23390266dcaa61b724e0a29808">&#9670;&nbsp;</a></span>saveImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::saveImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandPool &amp;&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>imageInitialLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>imageFinalLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>screenshotScale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the input image as a TGA file with the filename specified. Note that the image must have been created with the pvrvk::ImageUsageFlags::e_TRANSFER_SRC_BIT set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A queue to submit the generated command buffer to. This queue must be compatible with the command pool provided.</td></tr>
    <tr><td class="paramname">commandPool</td><td>A command pool from which to allocate a temporary command buffer to carry out the transfer operations.</td></tr>
    <tr><td class="paramname">image</td><td>The image to save as a TGA file.</td></tr>
    <tr><td class="paramname">imageInitialLayout</td><td>The initial layout of the image from which a transition will be made to pvrvk::ImageLayout::e_TRANSFER_SRC_OPTIMAL.</td></tr>
    <tr><td class="paramname">imageFinalLayout</td><td>The final layout of the image to which a transition will be made.</td></tr>
    <tr><td class="paramname">filename</td><td>The filename to use for the saved TGA image.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created the buffer used as the target of an imageToBufferCopy.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">screenshotScale</td><td>A scaling factor to use for increasing the size of the saved screenshot.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a076fe31eafd575f7f2a10f27f6130935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076fe31eafd575f7f2a10f27f6130935">&#9670;&nbsp;</a></span>setImageLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::setImageLayout </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>transitionCmdBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set image layout </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>The image to transition</td></tr>
    <tr><td class="paramname">oldLayout</td><td>An old image layout to transition from</td></tr>
    <tr><td class="paramname">newLayout</td><td>A new image layout to transition to</td></tr>
    <tr><td class="paramname">transitionCmdBuffer</td><td>A command buffer to add the pipelineBarrier for the image transition.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19f7af5558e7afc812edc1e8899d8f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f7af5558e7afc812edc1e8899d8f50">&#9670;&nbsp;</a></span>setImageLayoutAndQueueFamilyOwnership()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::setImageLayoutAndQueueFamilyOwnership </td>
          <td>(</td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>srccmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>dstcmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcQueueFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dstQueueFamily</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageAspectFlags&#160;</td>
          <td class="paramname"><em>aspect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set image layout and queue family ownership </p>
<p>IMAGES LAYOUTS AND QUEUES /////////////////</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srccmd</td><td>The source command buffer from which to transition the image from.</td></tr>
    <tr><td class="paramname">dstcmd</td><td>The destination command buffer from which to transition the image to.</td></tr>
    <tr><td class="paramname">srcQueueFamily</td><td>srcQueueFamily is the source queue family for a queue family ownership transfer.</td></tr>
    <tr><td class="paramname">dstQueueFamily</td><td>dstQueueFamily is the destination queue family for a queue family ownership transfer.</td></tr>
    <tr><td class="paramname">oldLayout</td><td>An old image layout to transition from</td></tr>
    <tr><td class="paramname">newLayout</td><td>A new image layout to transition to</td></tr>
    <tr><td class="paramname">image</td><td>The image to transition</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>The base mip level of the image to transition</td></tr>
    <tr><td class="paramname">numMipLevels</td><td>The number of mip levels of the image to transition</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>The base array layer level of the image to transition</td></tr>
    <tr><td class="paramname">numArrayLayers</td><td>The number of array layers of the image to transition</td></tr>
    <tr><td class="paramname">aspect</td><td>The pvrvk::ImageAspectFlags of the image to transition</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dc7d04620963f299874921f6fd18fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc7d04620963f299874921f6fd18fb8">&#9670;&nbsp;</a></span>takeScreenshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::takeScreenshot </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandPool &amp;&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Swapchain &amp;&#160;</td>
          <td class="paramname"><em>swapchain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>swapIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>screenshotFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>screenshotScale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a particular swapchain image corresponding to the swapchain image at index swapIndex for the swapchain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>A queue to submit the generated command buffer to. This queue must be compatible with the command pool provided.</td></tr>
    <tr><td class="paramname">commandPool</td><td>A command pool from which to allocate a temporary command buffer to carry out the transfer operations.</td></tr>
    <tr><td class="paramname">swapchain</td><td>The swapchain from which a particular image will be saved.</td></tr>
    <tr><td class="paramname">swapIndex</td><td>The swapchain image at index swapIndex will be saved as a TGA file.</td></tr>
    <tr><td class="paramname">screenshotFileName</td><td>The filename to use for the saved TGA image.</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created the buffer used as the target of an imageToBufferCopy.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">screenshotScale</td><td>A scaling factor to use for increasing the size of the saved screenshot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the screenshot could be taken successfully</dd></dl>

</div>
</div>
<a id="adac9f0af2d041d5efe3f668f87c6932b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac9f0af2d041d5efe3f668f87c6932b">&#9670;&nbsp;</a></span>textureUpload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html">TextureUploadResults</a> pvr::utils::textureUpload </td>
          <td>(</td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isEs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload a texture to the GPU on the current context, and return it as part of the <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The pvr::Texture to upload to the GPU</td></tr>
    <tr><td class="paramname">isEs2</td><td>Signifies whether the current context being used for the texture upload is ES2 only. If the context is ES2 only then the texture upload should not use ES3+ functionality as it will be unsupported via this context.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Set to true to allow to attempt to de-compress unsupported compressed textures. The textures will be decompressed if ALL of the following are true: The texture is in a compressed format that can be decompressed by the framework (PVRTC), the platform does NOT support this format (if it is hardware supported, it will never be decompressed), and this flag is set to true. Default:true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structpvr_1_1utils_1_1_texture_upload_results.html" title="The TextureUploadResults structure provides the results for texture upload functions in a simple to u...">TextureUploadResults</a> object containing the uploaded texture and all necessary information (size, formats, whether it was actually decompressed. The "result" field will contain Result::Success on success, errorcode otherwise. See the Texture</dd></dl>

</div>
</div>
<a id="a54f2bb511b50d2c11ddc7377a60714ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f2bb511b50d2c11ddc7377a60714ad">&#9670;&nbsp;</a></span>throwOnErrorDebugReportCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VKAPI_ATTR VkBool32 VKAPI_CALL pvr::utils::throwOnErrorDebugReportCallback </td>
          <td>(</td>
          <td class="paramtype">VkDebugReportFlagsEXT&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDebugReportObjectTypeEXT&#160;</td>
          <td class="paramname"><em>objectType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>messageCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pLayerPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application DebugReportCallback function providing logging for various events. The callback will also throw an exception when VkDebugReportFlagsEXT includes the VK_DEBUG_REPORT_ERROR_BIT_EXT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Indicates the VkDebugReportFlagsEXT triggering the callback.</td></tr>
    <tr><td class="paramname">objectType</td><td>The type of the object being used/created when the event was triggered.</td></tr>
    <tr><td class="paramname">object</td><td>The object where the issue was detected</td></tr>
    <tr><td class="paramname">location</td><td>A component defined value indicating the location of the trigger</td></tr>
    <tr><td class="paramname">messageCode</td><td>A layer defined value indicating the test which triggered the callback</td></tr>
    <tr><td class="paramname">pLayerPrefix</td><td>Abbreviation of the component making the callback</td></tr>
    <tr><td class="paramname">pMessage</td><td>String detailing the trigger conditions</td></tr>
    <tr><td class="paramname">pUserData</td><td>User data given when the callback was created</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an indication to the calling layer as to whether the Vulkan call should be aborted or not. Applications should always return VK_FALSE so that they see the same behavior with and without validation layers enabled.</dd></dl>

</div>
</div>
<a id="aaf3d187bfb119271fea887f28268699a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3d187bfb119271fea887f28268699a">&#9670;&nbsp;</a></span>throwOnErrorDebugUtilsMessengerCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VKAPI_ATTR VkBool32 VKAPI_CALL pvr::utils::throwOnErrorDebugUtilsMessengerCallback </td>
          <td>(</td>
          <td class="paramtype">VkDebugUtilsMessageSeverityFlagBitsEXT&#160;</td>
          <td class="paramname"><em>messageSeverity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDebugUtilsMessageTypeFlagsEXT&#160;</td>
          <td class="paramname"><em>messageTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDebugUtilsMessengerCallbackDataEXT *&#160;</td>
          <td class="paramname"><em>pCallbackData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An application DebugUtilsMessengerCallback function providing logging for various events. The callback will also throw an exception when VkDebugUtilsMessageSeverityFlagBitsEXT includes the VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageSeverity</td><td>Indicates the VkDebugUtilsMessageSeverityFlagBitsEXT which define the severity of any message.</td></tr>
    <tr><td class="paramname">messageTypes</td><td>A set of VkDebugUtilsMessageTypeFlagsEXT which define the type of the message.</td></tr>
    <tr><td class="paramname">pCallbackData</td><td>Contains all the callback related data in the VkDebugUtilsMessengerCallbackDataEXT structure</td></tr>
    <tr><td class="paramname">pUserData</td><td>The user data provided when the VkDebugUtilsMessengerEXT was created</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an indication to the calling layer as to whether the Vulkan call should be aborted or not. Applications should always return VK_FALSE so that they see the same behavior with and without validation layers enabled.</dd></dl>

</div>
</div>
<a id="afd40d1ab877a6c2ddf9c53ad02d8960f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd40d1ab877a6c2ddf9c53ad02d8960f">&#9670;&nbsp;</a></span>throwOnGlError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::throwOnGlError </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>note</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks and logs api errors if appropriate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">note</td><td>A c-style std::string that will be prepended to the error description if an error is found.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf553ba402ff80bc721c72d3a831a703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf553ba402ff80bc721c72d3a831a703">&#9670;&nbsp;</a></span>unpackSamplerFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::unpackSamplerFilter </td>
          <td>(</td>
          <td class="paramtype">PackedSamplerFilter&#160;</td>
          <td class="paramname"><em>packed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Filter &amp;&#160;</td>
          <td class="paramname"><em>mini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Filter &amp;&#160;</td>
          <td class="paramname"><em>magni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SamplerMipmapMode &amp;&#160;</td>
          <td class="paramname"><em>mip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpack a packed sampler filter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packed</td><td>The packed sampler filter</td></tr>
    <tr><td class="paramname">mini</td><td>The minification filter</td></tr>
    <tr><td class="paramname">magni</td><td>The magnification filter</td></tr>
    <tr><td class="paramname">mip</td><td>The sampler mipmap mode</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4a791a9c8914a9bf3b74db574b0c842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a791a9c8914a9bf3b74db574b0c842">&#9670;&nbsp;</a></span>updateBufferUsingStagingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::updateBufferUsingStagingBuffer </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>uploadCmdBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to update a buffer's data via an indirect copy from a temporary staging buffer. Updating memory via the use of a staging buffer is necessary when using memory without e_HOST_VISIBLE_BIT memory property flags meaning the buffer itself cannot be mapped to host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device used to create the staging buffer</td></tr>
    <tr><td class="paramname">buffer</td><td>The destination buffer.</td></tr>
    <tr><td class="paramname">uploadCmdBuffer</td><td>A command buffer into which commands will be recorded for carrying out the buffer copy</td></tr>
    <tr><td class="paramname">data</td><td>The data to use in the update</td></tr>
    <tr><td class="paramname">offset</td><td>The offset to use for the map -&gt; update -&gt; unmap</td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to be updated</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a618e4160bd8c24d9e0d394dc9511f4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618e4160bd8c24d9e0d394dc9511f4a3">&#9670;&nbsp;</a></span>updateHostVisibleBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::updateHostVisibleBuffer </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Buffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushMemory</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to update a buffer's data. This function maps and unmap the buffer only if the buffer is not already mapped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to map -&gt; update -&gt; unmap.</td></tr>
    <tr><td class="paramname">data</td><td>The data to use in the update</td></tr>
    <tr><td class="paramname">offset</td><td>The offset to use for the map -&gt; update -&gt; unmap</td></tr>
    <tr><td class="paramname">size</td><td>The size of the data to be updated</td></tr>
    <tr><td class="paramname">flushMemory</td><td>Boolean flag determining whether to flush the memory prior to the unmap</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f4a3a0c8eb6662f51128ce8a3b78a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4a3a0c8eb6662f51128ce8a3b78a9f">&#9670;&nbsp;</a></span>updateImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::updateImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBufferBase&#160;</td>
          <td class="paramname"><em>transferCommandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpvr_1_1utils_1_1_image_update_info.html">ImageUpdateInfo</a> *&#160;</td>
          <td class="paramname"><em>updateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numUpdateInfos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Format&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCubeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Image &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>bufferAllocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to update an image's data. This function will record the update of the image in the supplied command buffer but NOT submit the command buffer, hence allowing the user to submit it at his own time. IMPORTANT. Assumes image layout is pvrvk::ImageLayout::e_DST_OPTIMAL IMPORTANT. The cleanup object that is the return value of the function must be kept alive as long until the moment that the relevant command buffer submission is finished. Then it can be destroyed (or the cleanup function be called) to free any relevant resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device used to create the image</td></tr>
    <tr><td class="paramname">transferCommandBuffer</td><td>The command buffer into which the image update operations will be added.</td></tr>
    <tr><td class="paramname">updateInfos</td><td>This object is a c-style array of areas and the data to upload.</td></tr>
    <tr><td class="paramname">numUpdateInfos</td><td>The number of <a class="el" href="structpvr_1_1utils_1_1_image_update_info.html" title="The ImageUpdateInfo struct.">ImageUpdateInfo</a> objects in</td></tr>
    <tr><td class="paramname">format</td><td>The format of the image.</td></tr>
    <tr><td class="paramname">layout</td><td>The final image layout for the image being updated.</td></tr>
    <tr><td class="paramname">isCubeMap</td><td>Is the image a cubemap</td></tr>
    <tr><td class="paramname">image</td><td>The image to update</td></tr>
    <tr><td class="paramname">bufferAllocator</td><td>A VMA allocator used to allocate memory for the created buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pvrvk::Image update results structure - ImageUpdateResults</dd></dl>

</div>
</div>
<a id="aff24a1e7c47775943d761eaa3f7f555e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff24a1e7c47775943d761eaa3f7f555e">&#9670;&nbsp;</a></span>uploadImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::Image pvr::utils::uploadImage </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image.</td></tr>
    <tr><td class="paramname">texture</td><td>The source pvr::Texture object from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>A command buffer to add the pipelineBarrier for the image transition.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The image object.</dd></dl>

</div>
</div>
<a id="ac4d35fcf1b7758225738b98830816d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d35fcf1b7758225738b98830816d4e">&#9670;&nbsp;</a></span>uploadImageAndView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::uploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload image to gpu. The upload command and staging buffers are recorded in the commandbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">texture</td><td>The source pvr::Texture object from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A command buffer to which the upload operations should be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>A command buffer to add the pipelineBarrier for the image transition.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The image object.</dd></dl>

</div>
</div>
<a id="a7fbafa4f264dcddf481f21ad03027d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbafa4f264dcddf481f21ad03027d97">&#9670;&nbsp;</a></span>uploadImageAndView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::uploadImageAndView </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::SecondaryCommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads an image to gpu. The upload command and staging buffers are recorded in the commandbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">texture</td><td>The source pvr::Texture object from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandBuffer</td><td>A secondary command buffer to which the upload operations are be added. Note that the upload will not be guranteed to be complete until the command buffer is submitted to a queue with appropriate synchronisation.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>A command buffer to add the pipelineBarrier for the image transition.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded image object.</dd></dl>

</div>
</div>
<a id="ac3d376caf410d6a539eb713d8886ebee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d376caf410d6a539eb713d8886ebee">&#9670;&nbsp;</a></span>uploadImageAndViewSubmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvrvk::ImageView pvr::utils::uploadImageAndViewSubmit </td>
          <td>(</td>
          <td class="paramtype">pvrvk::Device &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::CommandPool &amp;&#160;</td>
          <td class="paramname"><em>commandPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::Queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageUsageFlags&#160;</td>
          <td class="paramname"><em>usageFlags</em> = <code>pvrvk::ImageUsageFlags::e_SAMPLED_BIT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvrvk::ImageLayout&#160;</td>
          <td class="paramname"><em>finalLayout</em> = <code>pvrvk::ImageLayout::e_SHADER_READ_ONLY_OPTIMAL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>stagingBufferAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#aad694c017b2fdbb822163769e1ebeb64">vma::Allocator</a>&#160;</td>
          <td class="paramname"><em>imageAllocator</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_memory_allocator_8h.html#a0e66dd42c1b9d1bb7759aafd399bf5c1">vma::AllocationCreateFlags</a>&#160;</td>
          <td class="paramname"><em>imageAllocationCreateFlags</em> = <code>vma::AllocationCreateFlags::e_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads an image to GPU memory and returns the created image view and associated image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to use to create the image and image view.</td></tr>
    <tr><td class="paramname">texture</td><td>The source pvr::Texture object from which to take the texture data.</td></tr>
    <tr><td class="paramname">allowDecompress</td><td>Specifies whether the texture can be decompressed as part of the image upload.</td></tr>
    <tr><td class="paramname">commandPool</td><td>A command pool from which to allocate a temporary command buffer to carry out the upload operations.</td></tr>
    <tr><td class="paramname">queue</td><td>A queue to which the upload operations should be submitted to.</td></tr>
    <tr><td class="paramname">usageFlags</td><td>A set of image usage flags for which the created image can be used for.</td></tr>
    <tr><td class="paramname">finalLayout</td><td>The final image layout the image will be transitioned to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the image upload will be a created image view with its associated pvrvk::Image.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stagingBufferAllocator</td><td>A VMA allocator used to allocate memory for the created staging buffer.</td></tr>
    <tr><td class="paramname">imageAllocator</td><td>A VMA allocator used to allocate memory for the created image.</td></tr>
    <tr><td class="paramname">imageAllocationCreateFlags</td><td>VMA Allocation creation flags. These flags can be used to control how and where the memory is allocated from. Valid flags include e_DEDICATED_MEMORY_BIT and e_MAPPED_BIT. e_DEDICATED_MEMORY_BIT indicates that the allocation should have its own memory block. e_MAPPED_BIT indicates memory will be persistently mapped respectively.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="20%" height="20%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
