<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PVRCore: pvr::async::TextureAsyncLoader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="80%" height="80%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><b>async</b></li><li class="navelem"><a class="el" href="classpvr_1_1async_1_1_texture_async_loader.html">TextureAsyncLoader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpvr_1_1async_1_1_texture_async_loader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::async::TextureAsyncLoader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class that loads Textures in a (single) different thread and provides futures to them. Create an instance of it, and then just call loadTextureAsync foreach texture to load. When each texture has completed loading, a callback may be called, otherwise you can use all the typical functionality of futures, such as querying if loading is comlete, or using a blocking wait to get the result  
 <a href="classpvr_1_1async_1_1_texture_async_loader.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::async::TextureAsyncLoader:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1async_1_1_texture_async_loader__inherit__graph.png" border="0" usemap="#pvr_1_1async_1_1_texture_async_loader_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1async_1_1_texture_async_loader_inherit__map" id="pvr_1_1async_1_1_texture_async_loader_inherit__map">
<area shape="rect" title="A class that loads Textures in a (single) different thread and provides futures to them...." alt="" coords="304,13,488,54"/>
<area shape="rect" href="classpvr_1_1async_1_1_async_scheduler.html" title=" " alt="" coords="5,5,256,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2e69fbb0066ef55fcca43cd95df576b6"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a2e69fbb0066ef55fcca43cd95df576b6">AsyncResult</a></td></tr>
<tr class="memdesc:a2e69fbb0066ef55fcca43cd95df576b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of result throughout this class.  <a href="classpvr_1_1async_1_1_async_scheduler.html#a2e69fbb0066ef55fcca43cd95df576b6">More...</a><br /></td></tr>
<tr class="separator:a2e69fbb0066ef55fcca43cd95df576b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a372da49b4546f3b3cd5b95051e9ac5d0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a372da49b4546f3b3cd5b95051e9ac5d0">getNumApproxQueuedItem</a> ()</td></tr>
<tr class="memdesc:a372da49b4546f3b3cd5b95051e9ac5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The approximate number of queued items. (Unsynchronized for performance).  <a href="classpvr_1_1async_1_1_async_scheduler.html#a372da49b4546f3b3cd5b95051e9ac5d0">More...</a><br /></td></tr>
<tr class="separator:a372da49b4546f3b3cd5b95051e9ac5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ff290f8906a799226fbc0fafad617c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#ad3ff290f8906a799226fbc0fafad617c">getNumQueuedItems</a> ()</td></tr>
<tr class="memdesc:ad3ff290f8906a799226fbc0fafad617c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The precise number of queued items at the time of calling. Although it is poosible that (if the queue is currently producing or consuming) the number has changed by the time it is used (even if immediately), nevertheless getting the number is synchronized hence precise at the time of querying it.  <a href="classpvr_1_1async_1_1_async_scheduler.html#ad3ff290f8906a799226fbc0fafad617c">More...</a><br /></td></tr>
<tr class="separator:ad3ff290f8906a799226fbc0fafad617c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfabe07e22d5f96d0132edf24032675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a2e69fbb0066ef55fcca43cd95df576b6">AsyncResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_texture_async_loader.html#a9bfabe07e22d5f96d0132edf24032675">loadTextureAsync</a> (const std::string &amp;filename, <a class="el" href="classpvr_1_1_i_asset_provider.html">IAssetProvider</a> *loader, <a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a> format, AsyncResult::element_type::Callback callback=NULL)</td></tr>
<tr class="memdesc:a9bfabe07e22d5f96d0132edf24032675"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enqueues a "load texture" on a background thread, and returns an object that can be used to query and wait for the result.  <a href="classpvr_1_1async_1_1_texture_async_loader.html#a9bfabe07e22d5f96d0132edf24032675">More...</a><br /></td></tr>
<tr class="separator:a9bfabe07e22d5f96d0132edf24032675"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a746911b5838589ee35704d36cb4c80d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a746911b5838589ee35704d36cb4c80d9">_myInfo</a></td></tr>
<tr class="memdesc:a746911b5838589ee35704d36cb4c80d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">String information regarding the tasks operations.  <a href="classpvr_1_1async_1_1_async_scheduler.html#a746911b5838589ee35704d36cb4c80d9">More...</a><br /></td></tr>
<tr class="separator:a746911b5838589ee35704d36cb4c80d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4038070a929677fbd22c5c269784ab7b"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="_texture_load_async_8h.html#a638e90f4057fb947a7b7b58110e6325f">TextureLoadFuture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a4038070a929677fbd22c5c269784ab7b">_queue</a></td></tr>
<tr class="memdesc:a4038070a929677fbd22c5c269784ab7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the work queue. Each item enqueued will be processed by worker.  <a href="classpvr_1_1async_1_1_async_scheduler.html#a4038070a929677fbd22c5c269784ab7b">More...</a><br /></td></tr>
<tr class="separator:a4038070a929677fbd22c5c269784ab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b7686e1550615ebfa117796c35a529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_threading_8h.html#a59c51d287496bea247f3d3e2503cb396">Semaphore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a99b7686e1550615ebfa117796c35a529">_queueSemaphore</a></td></tr>
<tr class="memdesc:a99b7686e1550615ebfa117796c35a529"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is basically a mutex for the queue. Wait on it to lock the queue, then signal it when done.  <a href="classpvr_1_1async_1_1_async_scheduler.html#a99b7686e1550615ebfa117796c35a529">More...</a><br /></td></tr>
<tr class="separator:a99b7686e1550615ebfa117796c35a529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75acf07584edd98f0f5b837d90445f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_threading_8h.html#a59c51d287496bea247f3d3e2503cb396">Semaphore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a75acf07584edd98f0f5b837d90445f4e">_workSemaphore</a></td></tr>
<tr class="memdesc:a75acf07584edd98f0f5b837d90445f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This semaphore is the counter for enqueued work. Signal it once when adding work to the queue.  <a href="classpvr_1_1async_1_1_async_scheduler.html#a75acf07584edd98f0f5b837d90445f4e">More...</a><br /></td></tr>
<tr class="separator:a75acf07584edd98f0f5b837d90445f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class that loads Textures in a (single) different thread and provides futures to them. Create an instance of it, and then just call loadTextureAsync foreach texture to load. When each texture has completed loading, a callback may be called, otherwise you can use all the typical functionality of futures, such as querying if loading is comlete, or using a blocking wait to get the result </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2e69fbb0066ef55fcca43cd95df576b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e69fbb0066ef55fcca43cd95df576b6">&#9670;&nbsp;</a></span>AsyncResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a>&lt;<a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> &gt; &gt; <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> , <a class="el" href="_texture_load_async_8h.html#a638e90f4057fb947a7b7b58110e6325f">TextureLoadFuture</a> , worker &gt;::<a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a2e69fbb0066ef55fcca43cd95df576b6">AsyncResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of result throughout this class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a372da49b4546f3b3cd5b95051e9ac5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372da49b4546f3b3cd5b95051e9ac5d0">&#9670;&nbsp;</a></span>getNumApproxQueuedItem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> , <a class="el" href="_texture_load_async_8h.html#a638e90f4057fb947a7b7b58110e6325f">TextureLoadFuture</a> , worker &gt;::getNumApproxQueuedItem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The approximate number of queued items. (Unsynchronized for performance). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of queued items (currently visible to this thread)</dd></dl>

</div>
</div>
<a id="ad3ff290f8906a799226fbc0fafad617c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ff290f8906a799226fbc0fafad617c">&#9670;&nbsp;</a></span>getNumQueuedItems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> , <a class="el" href="_texture_load_async_8h.html#a638e90f4057fb947a7b7b58110e6325f">TextureLoadFuture</a> , worker &gt;::getNumQueuedItems</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The precise number of queued items at the time of calling. Although it is poosible that (if the queue is currently producing or consuming) the number has changed by the time it is used (even if immediately), nevertheless getting the number is synchronized hence precise at the time of querying it. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of queued items (access is synchronized)</dd></dl>

</div>
</div>
<a id="a9bfabe07e22d5f96d0132edf24032675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfabe07e22d5f96d0132edf24032675">&#9670;&nbsp;</a></span>loadTextureAsync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1async_1_1_async_scheduler.html#a2e69fbb0066ef55fcca43cd95df576b6">AsyncResult</a> pvr::async::TextureAsyncLoader::loadTextureAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_i_asset_provider.html">IAssetProvider</a> *&#160;</td>
          <td class="paramname"><em>loader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AsyncResult::element_type::Callback&#160;</td>
          <td class="paramname"><em>callback</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function enqueues a "load texture" on a background thread, and returns an object that can be used to query and wait for the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename of the texture to load</td></tr>
    <tr><td class="paramname">loader</td><td>A class that provides a "getAssetStream" function to get a <a class="el" href="classpvr_1_1_stream.html" title="This class is used to abstract streams of data (files, blocks of memory, resources etc....">Stream</a> from the filename (usually, the application class itself)</td></tr>
    <tr><td class="paramname">format</td><td>The texture format as which to load the texture.</td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback to call immediately after texture loading is complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to a texture : TextureLoadFuture</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a746911b5838589ee35704d36cb4c80d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746911b5838589ee35704d36cb4c80d9">&#9670;&nbsp;</a></span>_myInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> , <a class="el" href="_texture_load_async_8h.html#a638e90f4057fb947a7b7b58110e6325f">TextureLoadFuture</a> , worker &gt;::_myInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String information regarding the tasks operations. </p>

</div>
</div>
<a id="a4038070a929677fbd22c5c269784ab7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4038070a929677fbd22c5c269784ab7b">&#9670;&nbsp;</a></span>_queue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;<a class="el" href="_texture_load_async_8h.html#a638e90f4057fb947a7b7b58110e6325f">TextureLoadFuture</a> &gt; <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> , <a class="el" href="_texture_load_async_8h.html#a638e90f4057fb947a7b7b58110e6325f">TextureLoadFuture</a> , worker &gt;::_queue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the work queue. Each item enqueued will be processed by worker. </p>

</div>
</div>
<a id="a99b7686e1550615ebfa117796c35a529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b7686e1550615ebfa117796c35a529">&#9670;&nbsp;</a></span>_queueSemaphore</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_threading_8h.html#a59c51d287496bea247f3d3e2503cb396">Semaphore</a> <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> , <a class="el" href="_texture_load_async_8h.html#a638e90f4057fb947a7b7b58110e6325f">TextureLoadFuture</a> , worker &gt;::_queueSemaphore</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is basically a mutex for the queue. Wait on it to lock the queue, then signal it when done. </p>

</div>
</div>
<a id="a75acf07584edd98f0f5b837d90445f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75acf07584edd98f0f5b837d90445f4e">&#9670;&nbsp;</a></span>_workSemaphore</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_threading_8h.html#a59c51d287496bea247f3d3e2503cb396">Semaphore</a> <a class="el" href="classpvr_1_1async_1_1_async_scheduler.html">pvr::async::AsyncScheduler</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> , <a class="el" href="_texture_load_async_8h.html#a638e90f4057fb947a7b7b58110e6325f">TextureLoadFuture</a> , worker &gt;::_workSemaphore</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This semaphore is the counter for enqueued work. Signal it once when adding work to the queue. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRCore/texture/<a class="el" href="_texture_load_async_8h_source.html">TextureLoadAsync.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="20%" height="20%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
