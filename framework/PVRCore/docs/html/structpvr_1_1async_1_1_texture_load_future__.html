<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PVRCore: pvr::async::TextureLoadFuture_ Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="80%" height="80%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><b>async</b></li><li class="navelem"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html">TextureLoadFuture_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="structpvr_1_1async_1_1_texture_load_future__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::async::TextureLoadFuture_ Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class wrapping the operations necessary to retrieve an asynchronously loaded texture, (e.g. querying if the load is complete, or blocking-wait get the result. It is a shared reference counted resource  
 <a href="structpvr_1_1async_1_1_texture_load_future__.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::async::TextureLoadFuture_:</div>
<div class="dyncontent">
<div class="center"><img src="structpvr_1_1async_1_1_texture_load_future____inherit__graph.png" border="0" usemap="#pvr_1_1async_1_1_texture_load_future___inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1async_1_1_texture_load_future___inherit__map" id="pvr_1_1async_1_1_texture_load_future___inherit__map">
<area shape="rect" title="A class wrapping the operations necessary to retrieve an asynchronously loaded texture,..." alt="" coords="576,46,800,73"/>
<area shape="rect" href="classpvr_1_1async_1_1_i_framework_async_result.html" title=" " alt="" coords="297,5,511,47"/>
<area shape="rect" href="classpvr_1_1async_1_1_i_framework_cleanup_object.html" title=" " alt="" coords="5,5,232,47"/>
<area shape="rect" title=" " alt="" coords="280,71,528,112"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaaaab98799521063c73492b20839d8c1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#aaaaab98799521063c73492b20839d8c1">Callback</a>) (<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a>)</td></tr>
<tr class="memdesc:aaaaab98799521063c73492b20839d8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer type that can be used as a callback to call when the return value is ready  <a href="classpvr_1_1async_1_1_i_framework_async_result.html#aaaaab98799521063c73492b20839d8c1">More...</a><br /></td></tr>
<tr class="separator:aaaaab98799521063c73492b20839d8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a2354267bb90adac66def0e251f34d"><td class="memItemLeft" align="right" valign="top"><a id="ab0a2354267bb90adac66def0e251f34d"></a>
typedef <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#aaaaab98799521063c73492b20839d8c1">MyBase::Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#ab0a2354267bb90adac66def0e251f34d">CallbackType</a></td></tr>
<tr class="memdesc:ab0a2354267bb90adac66def0e251f34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of function that can be used as a completion callback. <br /></td></tr>
<tr class="separator:ab0a2354267bb90adac66def0e251f34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87cc198bd4f73a6ffe95a5409a98c9c"><td class="memItemLeft" align="right" valign="top"><a id="ab87cc198bd4f73a6ffe95a5409a98c9c"></a>
typedef <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#ab87cc198bd4f73a6ffe95a5409a98c9c">MyBase</a></td></tr>
<tr class="memdesc:ab87cc198bd4f73a6ffe95a5409a98c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class. <br /></td></tr>
<tr class="separator:ab87cc198bd4f73a6ffe95a5409a98c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66968d22333ae07fbe05b241efc5f2db"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a></td></tr>
<tr class="memdesc:a66968d22333ae07fbe05b241efc5f2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer to this result object (not the wrapped value)  <a href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">More...</a><br /></td></tr>
<tr class="separator:a66968d22333ae07fbe05b241efc5f2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443532fc20e721cbf2ffa8a15e180f56"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a></td></tr>
<tr class="memdesc:a443532fc20e721cbf2ffa8a15e180f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the return value  <a href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">More...</a><br /></td></tr>
<tr class="separator:a443532fc20e721cbf2ffa8a15e180f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2eeb9f821e79c7fc311b54d2640a9831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_cleanup_object.html#a2eeb9f821e79c7fc311b54d2640a9831">cleanup</a> ()</td></tr>
<tr class="memdesc:a2eeb9f821e79c7fc311b54d2640a9831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you are done using this object.  <a href="classpvr_1_1async_1_1_i_framework_cleanup_object.html#a2eeb9f821e79c7fc311b54d2640a9831">More...</a><br /></td></tr>
<tr class="separator:a2eeb9f821e79c7fc311b54d2640a9831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c729bc2846556f45ccdc5fb65103a44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a3c729bc2846556f45ccdc5fb65103a44">get</a> ()</td></tr>
<tr class="memdesc:a3c729bc2846556f45ccdc5fb65103a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the most important function of IFrameworkAsyncResult: it actually gets the return value. If the value is not yet ready (the task is not complete), it will wait for the task completion. Use this immediately when other operations depend on the value. Otherwise, in order to avoid any wait, you can first check <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ab0c3a00d9475c7dcbf3459eeb5c81541" title="Query is the return value is ready to be used">isComplete()</a> and only call this function after <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ab0c3a00d9475c7dcbf3459eeb5c81541" title="Query is the return value is ready to be used">isComplete()</a> has returned true. If the task may fail, you should call <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a09d5a0dedd7e71e68591ed5513206ab0" title="Returns true if the operation was successful. An operation that is not complete cannot be successful,...">isSuccessful()</a> before using the value to ensure it is what you expect.  <a href="classpvr_1_1async_1_1_i_framework_async_result.html#a3c729bc2846556f45ccdc5fb65103a44">More...</a><br /></td></tr>
<tr class="separator:a3c729bc2846556f45ccdc5fb65103a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c3a00d9475c7dcbf3459eeb5c81541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ab0c3a00d9475c7dcbf3459eeb5c81541">isComplete</a> () const</td></tr>
<tr class="memdesc:ab0c3a00d9475c7dcbf3459eeb5c81541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query is the return value is ready to be used  <a href="classpvr_1_1async_1_1_i_framework_async_result.html#ab0c3a00d9475c7dcbf3459eeb5c81541">More...</a><br /></td></tr>
<tr class="separator:ab0c3a00d9475c7dcbf3459eeb5c81541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d5a0dedd7e71e68591ed5513206ab0"><td class="memItemLeft" align="right" valign="top"><a id="a09d5a0dedd7e71e68591ed5513206ab0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a09d5a0dedd7e71e68591ed5513206ab0">isSuccessful</a> () const</td></tr>
<tr class="memdesc:a09d5a0dedd7e71e68591ed5513206ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the operation was successful. An operation that is not complete cannot be successful, so check isComplete to ensure that a return value of false means that the operation actually failed<dl class="section return"><dt>Returns</dt><dd>True if the operation is complete and successful, false if the operation failed or has not yet completed</dd></dl>
<br /></td></tr>
<tr class="separator:a09d5a0dedd7e71e68591ed5513206ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfecf32f5552c811b549c02c1fb2836"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a0dfecf32f5552c811b549c02c1fb2836">loadNow</a> ()</td></tr>
<tr class="memdesc:a0dfecf32f5552c811b549c02c1fb2836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the texture synchronously and signal the result semaphore. Normally called by the worker thread  <a href="structpvr_1_1async_1_1_texture_load_future__.html#a0dfecf32f5552c811b549c02c1fb2836">More...</a><br /></td></tr>
<tr class="separator:a0dfecf32f5552c811b549c02c1fb2836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4263ecd25214768bdae235faa0c6d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a4d4263ecd25214768bdae235faa0c6d1">setCallBack</a> (<a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#ab0a2354267bb90adac66def0e251f34d">CallbackType</a> callback)</td></tr>
<tr class="memdesc:a4d4263ecd25214768bdae235faa0c6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a function to be called when the texture loading has been finished.  <a href="structpvr_1_1async_1_1_texture_load_future__.html#a4d4263ecd25214768bdae235faa0c6d1">More...</a><br /></td></tr>
<tr class="separator:a4d4263ecd25214768bdae235faa0c6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7fef173aeebc5970387f6c9ea22c3da0"><td class="memItemLeft" align="right" valign="top">std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a7fef173aeebc5970387f6c9ea22c3da0">exception</a></td></tr>
<tr class="memdesc:a7fef173aeebc5970387f6c9ea22c3da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to an exception to throw  <a href="structpvr_1_1async_1_1_texture_load_future__.html#a7fef173aeebc5970387f6c9ea22c3da0">More...</a><br /></td></tr>
<tr class="separator:a7fef173aeebc5970387f6c9ea22c3da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611c13912be5b0c6191767393a5db12d"><td class="memItemLeft" align="right" valign="top"><a id="a611c13912be5b0c6191767393a5db12d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a611c13912be5b0c6191767393a5db12d">filename</a></td></tr>
<tr class="memdesc:a611c13912be5b0c6191767393a5db12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filename from which the texture is loaded. <br /></td></tr>
<tr class="separator:a611c13912be5b0c6191767393a5db12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e74ad5eb11c0a5ebf6481559614818"><td class="memItemLeft" align="right" valign="top"><a id="a84e74ad5eb11c0a5ebf6481559614818"></a>
<a class="el" href="namespacepvr.html#a8be7d779089afe1df56a1bf542134d0d">TextureFileFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a84e74ad5eb11c0a5ebf6481559614818">format</a></td></tr>
<tr class="memdesc:a84e74ad5eb11c0a5ebf6481559614818"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format of the texture. <br /></td></tr>
<tr class="separator:a84e74ad5eb11c0a5ebf6481559614818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dfaf430f539cc483da22998ff5ac24"><td class="memItemLeft" align="right" valign="top"><a id="ac6dfaf430f539cc483da22998ff5ac24"></a>
<a class="el" href="classpvr_1_1_i_asset_provider.html">IAssetProvider</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#ac6dfaf430f539cc483da22998ff5ac24">loader</a></td></tr>
<tr class="memdesc:ac6dfaf430f539cc483da22998ff5ac24"><td class="mdescLeft">&#160;</td><td class="mdescRight">The AssetProvider to use to load the texture. <br /></td></tr>
<tr class="separator:ac6dfaf430f539cc483da22998ff5ac24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3973d95b7c30714e73d0f47da6b6b40f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a3973d95b7c30714e73d0f47da6b6b40f">result</a></td></tr>
<tr class="memdesc:a3973d95b7c30714e73d0f47da6b6b40f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of the operation will be stored here  <a href="structpvr_1_1async_1_1_texture_load_future__.html#a3973d95b7c30714e73d0f47da6b6b40f">More...</a><br /></td></tr>
<tr class="separator:a3973d95b7c30714e73d0f47da6b6b40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4ac15d6a67ef7882483a824c50de18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_threading_8h.html#a24e4fe78539bb88975c81b26facf9157">SemaphorePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a3c4ac15d6a67ef7882483a824c50de18">resultSemaphore</a></td></tr>
<tr class="separator:a3c4ac15d6a67ef7882483a824c50de18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1773671be6459506b27aee99528aced1"><td class="memItemLeft" align="right" valign="top"><a id="a1773671be6459506b27aee99528aced1"></a>
<a class="el" href="_threading_8h.html#a59c51d287496bea247f3d3e2503cb396">Semaphore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#a1773671be6459506b27aee99528aced1">workSemaphore</a></td></tr>
<tr class="memdesc:a1773671be6459506b27aee99528aced1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to an externally used semaphore (normally the one used by the queue) <br /></td></tr>
<tr class="separator:a1773671be6459506b27aee99528aced1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad11fe888126058746669ec00b98d33a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ad11fe888126058746669ec00b98d33a2">executeCallBack</a> (<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a> thisPtr)</td></tr>
<tr class="memdesc:ad11fe888126058746669ec00b98d33a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the callback (overridable)  <a href="classpvr_1_1async_1_1_i_framework_async_result.html#ad11fe888126058746669ec00b98d33a2">More...</a><br /></td></tr>
<tr class="separator:ad11fe888126058746669ec00b98d33a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9484ee12974a95ce286429f04d82c4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ad9484ee12974a95ce286429f04d82c4b">setTheCallback</a> (<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#aaaaab98799521063c73492b20839d8c1">Callback</a> completionCallback)</td></tr>
<tr class="memdesc:ad9484ee12974a95ce286429f04d82c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback (a function pointer that will be called whenever processing an item is done)  <a href="classpvr_1_1async_1_1_i_framework_async_result.html#ad9484ee12974a95ce286429f04d82c4b">More...</a><br /></td></tr>
<tr class="separator:ad9484ee12974a95ce286429f04d82c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3b8008b722bead0caf64f2766d5fb37d"><td class="memItemLeft" align="right" valign="top"><a id="a3b8008b722bead0caf64f2766d5fb37d"></a>
<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#aaaaab98799521063c73492b20839d8c1">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a3b8008b722bead0caf64f2766d5fb37d">_completionCallback</a></td></tr>
<tr class="memdesc:a3b8008b722bead0caf64f2766d5fb37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callback that will be called on completion. <br /></td></tr>
<tr class="separator:a3b8008b722bead0caf64f2766d5fb37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3dac58ec5cafe521e7816eb22334c1"><td class="memItemLeft" align="right" valign="top"><a id="a8d3dac58ec5cafe521e7816eb22334c1"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a8d3dac58ec5cafe521e7816eb22334c1">_inCallback</a></td></tr>
<tr class="memdesc:a8d3dac58ec5cafe521e7816eb22334c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a mechanism to query if a function is actually called BY the callback to avoid deadlocking. <br /></td></tr>
<tr class="separator:a8d3dac58ec5cafe521e7816eb22334c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6065186c0708bf0efabd8dca3d138b"><td class="memItemLeft" align="right" valign="top"><a id="a2e6065186c0708bf0efabd8dca3d138b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a2e6065186c0708bf0efabd8dca3d138b">_successful</a></td></tr>
<tr class="memdesc:a2e6065186c0708bf0efabd8dca3d138b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will / should be set to true when the work is successfully completed. <br /></td></tr>
<tr class="separator:a2e6065186c0708bf0efabd8dca3d138b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class wrapping the operations necessary to retrieve an asynchronously loaded texture, (e.g. querying if the load is complete, or blocking-wait get the result. It is a shared reference counted resource </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaaaab98799521063c73492b20839d8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaaab98799521063c73492b20839d8c1">&#9670;&nbsp;</a></span>Callback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a>  &gt;::Callback) (<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function pointer type that can be used as a callback to call when the return value is ready </p>

</div>
</div>
<a id="a66968d22333ae07fbe05b241efc5f2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66968d22333ae07fbe05b241efc5f2db">&#9670;&nbsp;</a></span>PointerType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">IFrameworkAsyncResult</a>&lt;<a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> &gt; &gt; <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a>  &gt;::<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A smart pointer to this result object (not the wrapped value) </p>

</div>
</div>
<a id="a443532fc20e721cbf2ffa8a15e180f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443532fc20e721cbf2ffa8a15e180f56">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a>  <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a>  &gt;::<a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of the return value </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2eeb9f821e79c7fc311b54d2640a9831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eeb9f821e79c7fc311b54d2640a9831">&#9670;&nbsp;</a></span>cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1async_1_1_i_framework_cleanup_object.html">pvr::async::IFrameworkCleanupObject</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a>  &gt;::cleanup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function when you are done using this object. </p>

</div>
</div>
<a id="ad11fe888126058746669ec00b98d33a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11fe888126058746669ec00b98d33a2">&#9670;&nbsp;</a></span>executeCallBack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a>  &gt;::executeCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a66968d22333ae07fbe05b241efc5f2db">PointerType</a>&#160;</td>
          <td class="paramname"><em>thisPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the callback (overridable) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisPtr</td><td>The object with which the callback will be executed as a parameter.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c729bc2846556f45ccdc5fb65103a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c729bc2846556f45ccdc5fb65103a44">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a443532fc20e721cbf2ffa8a15e180f56">ValueType</a> <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a>  &gt;::get</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the most important function of <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html" title="An object that is intended to be used as an asynchronous return value. When you wish to perform a tas...">IFrameworkAsyncResult</a>: it actually gets the return value. If the value is not yet ready (the task is not complete), it will wait for the task completion. Use this immediately when other operations depend on the value. Otherwise, in order to avoid any wait, you can first check <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ab0c3a00d9475c7dcbf3459eeb5c81541" title="Query is the return value is ready to be used">isComplete()</a> and only call this function after <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#ab0c3a00d9475c7dcbf3459eeb5c81541" title="Query is the return value is ready to be used">isComplete()</a> has returned true. If the task may fail, you should call <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#a09d5a0dedd7e71e68591ed5513206ab0" title="Returns true if the operation was successful. An operation that is not complete cannot be successful,...">isSuccessful()</a> before using the value to ensure it is what you expect. </p>
<dl class="section return"><dt>Returns</dt><dd>The return value of the operation.</dd></dl>

</div>
</div>
<a id="ab0c3a00d9475c7dcbf3459eeb5c81541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c3a00d9475c7dcbf3459eeb5c81541">&#9670;&nbsp;</a></span>isComplete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a>  &gt;::isComplete</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query is the return value is ready to be used </p>
<dl class="section return"><dt>Returns</dt><dd>True if the value is ready, otherwise false</dd></dl>

</div>
</div>
<a id="a0dfecf32f5552c811b549c02c1fb2836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfecf32f5552c811b549c02c1fb2836">&#9670;&nbsp;</a></span>loadNow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::async::TextureLoadFuture_::loadNow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load the texture synchronously and signal the result semaphore. Normally called by the worker thread </p>

</div>
</div>
<a id="a4d4263ecd25214768bdae235faa0c6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4263ecd25214768bdae235faa0c6d1">&#9670;&nbsp;</a></span>setCallBack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::async::TextureLoadFuture_::setCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpvr_1_1async_1_1_texture_load_future__.html#ab0a2354267bb90adac66def0e251f34d">CallbackType</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a function to be called when the texture loading has been finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Set a function to be called when the texture loading has been finished.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9484ee12974a95ce286429f04d82c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9484ee12974a95ce286429f04d82c4b">&#9670;&nbsp;</a></span>setTheCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html">pvr::async::IFrameworkAsyncResult</a>&lt; <a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a>  &gt;::setTheCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1async_1_1_i_framework_async_result.html#aaaaab98799521063c73492b20839d8c1">Callback</a>&#160;</td>
          <td class="paramname"><em>completionCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the callback (a function pointer that will be called whenever processing an item is done) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">completionCallback</td><td>The callback to set</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7fef173aeebc5970387f6c9ea22c3da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fef173aeebc5970387f6c9ea22c3da0">&#9670;&nbsp;</a></span>exception</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::exception_ptr pvr::async::TextureLoadFuture_::exception</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pointer to an exception to throw </p>

</div>
</div>
<a id="a3973d95b7c30714e73d0f47da6b6b40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3973d95b7c30714e73d0f47da6b6b40f">&#9670;&nbsp;</a></span>result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_texture_load_async_8h.html#ae4d957eee9f172363a80ce45bf6ac005">TexturePtr</a> pvr::async::TextureLoadFuture_::result</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The result of the operation will be stored here </p>

</div>
</div>
<a id="a3c4ac15d6a67ef7882483a824c50de18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4ac15d6a67ef7882483a824c50de18">&#9670;&nbsp;</a></span>resultSemaphore</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_threading_8h.html#a24e4fe78539bb88975c81b26facf9157">SemaphorePtr</a> pvr::async::TextureLoadFuture_::resultSemaphore</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The semaphore that is used to wait for the result </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRCore/texture/<a class="el" href="_texture_load_async_8h_source.html">TextureLoadAsync.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="20%" height="20%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
