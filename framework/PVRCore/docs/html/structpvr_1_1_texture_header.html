<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PVRCore: pvr::TextureHeader Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="80%" height="80%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="structpvr_1_1_texture_header.html">TextureHeader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structpvr_1_1_texture_header-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::TextureHeader Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class mirroring the PVR <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> container format header, and which can in general represent any <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset. Contains accessors functions to facilitate using the <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> data in application code. /summary&gt;  
 <a href="structpvr_1_1_texture_header.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::TextureHeader:</div>
<div class="dyncontent">
<div class="center"><img src="structpvr_1_1_texture_header__inherit__graph.png" border="0" usemap="#pvr_1_1_texture_header_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1_texture_header_inherit__map" id="pvr_1_1_texture_header_inherit__map">
<area shape="rect" title="A class mirroring the PVR Texture container format header, and which can in general represent any Tex..." alt="" coords="5,5,152,32"/>
<area shape="rect" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac..." alt="" coords="29,80,128,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa575a1cac05e7c71cc544ff4469264a4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4">Constants</a> { <br />
&#160;&#160;<a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4a167572588891304475e448c9a44d0a46">PVRv3</a> = 0x03525650, 
<a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4ae2cd40f7ccea4ca3ef7c46970ab43af6">PVRv3Reversed</a> = 0x50565203, 
<a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4a43bea9e5650f87f5b16b074cbe26f622">CompressedFlag</a> = (1 &lt;&lt; 0), 
<a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4a9253d5725cfe9a48d00e6eb0c9651e29">PremultipliedFlag</a> = (1 &lt;&lt; 1), 
<br />
&#160;&#160;<a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4a656632f4d3e87051deca7655ead0f65b">SizeOfHeader</a> = 52
<br />
 }</td></tr>
<tr class="memdesc:aa575a1cac05e7c71cc544ff4469264a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This header stores everything that you would ever need to load (but not necessarily use) a texture's data accurately, but no more. Data that is provided but is not needed to read the data is stored in the Metadata section (See TextureHeaderWithMetadata). Correct use of the texture may rely on meta data, but accurate data loading can be done through the standard header alone.  <a href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4">More...</a><br /></td></tr>
<tr class="separator:aa575a1cac05e7c71cc544ff4469264a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb28e3c3a9f26529ff3fb001fe327f04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aeb28e3c3a9f26529ff3fb001fe327f04">TextureHeader</a> ()</td></tr>
<tr class="memdesc:aeb28e3c3a9f26529ff3fb001fe327f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for a <a class="el" href="structpvr_1_1_texture_header.html" title="A class mirroring the PVR Texture container format header, and which can in general represent any Tex...">TextureHeader</a>. Returns an empty header.  <a href="structpvr_1_1_texture_header.html#aeb28e3c3a9f26529ff3fb001fe327f04">More...</a><br /></td></tr>
<tr class="separator:aeb28e3c3a9f26529ff3fb001fe327f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147a439d7cd6ad60ec53fb67b0be4445"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a147a439d7cd6ad60ec53fb67b0be4445">TextureHeader</a> (<a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a> <a class="el" href="structpvr_1_1_texture_header.html#a0c4edd7302ab785ff47b46dd4f46170f">pixelFormat</a>, uint32_t <a class="el" href="structpvr_1_1_texture_header.html#a0c32d51bbf9386f82c017c1b867ac362">width</a>, uint32_t <a class="el" href="structpvr_1_1_texture_header.html#a2860b2e50a2ddc9b05769b7178b54858">height</a>, uint32_t <a class="el" href="structpvr_1_1_texture_header.html#a62c45b53efb7db69ab1c782c3441a323">depth</a>=1, uint32_t <a class="el" href="structpvr_1_1_texture_header.html#aa9708c183c5836408d74d5b341846594">numMipMaps</a>=1, <a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a> <a class="el" href="structpvr_1_1_texture_header.html#aae8c205bfe7a99cc479e2e8eeb3ac082">colorSpace</a>=<a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91a4c8bf835da6d934b50f620cdd0cc3913">ColorSpace::lRGB</a>, <a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> <a class="el" href="structpvr_1_1_texture_header.html#a6dc964624a1c060d774ccf2419882e68">channelType</a>=VariableType::UnsignedByteNorm, uint32_t <a class="el" href="structpvr_1_1_texture_header.html#a04e90b5846cddef394f1f0e313d8a8a8">numSurfaces</a>=1, uint32_t <a class="el" href="structpvr_1_1_texture_header.html#ae73034dd746eae6a6b97964196bb35f6">numFaces</a>=1, uint32_t <a class="el" href="structpvr_1_1_texture_header.html#a9621fca15af7e7abd7a4c0839b1f6d72">flags</a>=0, <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> *metaData=NULL, uint32_t <a class="el" href="structpvr_1_1_texture_header.html#a4488946b871a1bf11f465b10923779c1">metaDataSize</a>=0)</td></tr>
<tr class="memdesc:a147a439d7cd6ad60ec53fb67b0be4445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="structpvr_1_1_texture_header.html#a147a439d7cd6ad60ec53fb67b0be4445">More...</a><br /></td></tr>
<tr class="separator:a147a439d7cd6ad60ec53fb67b0be4445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f914183d01dac387bb4b434317b5c30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a2f914183d01dac387bb4b434317b5c30">TextureHeader</a> (uint32_t numMetaData, <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> *metaData)</td></tr>
<tr class="memdesc:a2f914183d01dac387bb4b434317b5c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct this from file header and meta data  <a href="structpvr_1_1_texture_header.html#a2f914183d01dac387bb4b434317b5c30">More...</a><br /></td></tr>
<tr class="separator:a2f914183d01dac387bb4b434317b5c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c81430182569becd27c48dc12e9f36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a15c81430182569becd27c48dc12e9f36">addMetaData</a> (const <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> &amp;metaData)</td></tr>
<tr class="memdesc:a15c81430182569becd27c48dc12e9f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an arbitrary piece of meta data.  <a href="structpvr_1_1_texture_header.html#a15c81430182569becd27c48dc12e9f36">More...</a><br /></td></tr>
<tr class="separator:a15c81430182569becd27c48dc12e9f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6464f127a35d2e4f275d6db3a8ff8d81"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a6464f127a35d2e4f275d6db3a8ff8d81">getBitsPerPixel</a> () const</td></tr>
<tr class="memdesc:a6464f127a35d2e4f275d6db3a8ff8d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bits per pixel of the texture format.  <a href="structpvr_1_1_texture_header.html#a6464f127a35d2e4f275d6db3a8ff8d81">More...</a><br /></td></tr>
<tr class="separator:a6464f127a35d2e4f275d6db3a8ff8d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274e7f9171bdb833117b3f13cb55325a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a274e7f9171bdb833117b3f13cb55325a">getChannelType</a> () const</td></tr>
<tr class="memdesc:a274e7f9171bdb833117b3f13cb55325a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the channel type that the texture's data is stored in.  <a href="structpvr_1_1_texture_header.html#a274e7f9171bdb833117b3f13cb55325a">More...</a><br /></td></tr>
<tr class="separator:a274e7f9171bdb833117b3f13cb55325a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9252454143fb760f259b844e7df6e476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a9252454143fb760f259b844e7df6e476">getColorSpace</a> () const</td></tr>
<tr class="memdesc:a9252454143fb760f259b844e7df6e476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the color space of the texture.  <a href="structpvr_1_1_texture_header.html#a9252454143fb760f259b844e7df6e476">More...</a><br /></td></tr>
<tr class="separator:a9252454143fb760f259b844e7df6e476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1">getCubeMapOrder</a> () const</td></tr>
<tr class="memdesc:ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cube map face order.  <a href="structpvr_1_1_texture_header.html#ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1">More...</a><br /></td></tr>
<tr class="separator:ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac857e69832c7f453963d00d125b2914c"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ac857e69832c7f453963d00d125b2914c">getDataOffset</a> (uint32_t mipMapLevel=0, uint32_t arrayMember=0, uint32_t face=0) const</td></tr>
<tr class="memdesc:ac857e69832c7f453963d00d125b2914c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a offset in the data  <a href="structpvr_1_1_texture_header.html#ac857e69832c7f453963d00d125b2914c">More...</a><br /></td></tr>
<tr class="separator:ac857e69832c7f453963d00d125b2914c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb19f136932ee5150570dc9ec4d84e6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aebb19f136932ee5150570dc9ec4d84e6">getDataSize</a> (int32_t mipLevel=pvrTextureAllMipMaps, bool allSurfaces=true, bool allFaces=true) const</td></tr>
<tr class="memdesc:aebb19f136932ee5150570dc9ec4d84e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size in BYTES of the texture, given various input parameters.  <a href="structpvr_1_1_texture_header.html#aebb19f136932ee5150570dc9ec4d84e6">More...</a><br /></td></tr>
<tr class="separator:aebb19f136932ee5150570dc9ec4d84e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b67b3697ab065bc7ef7568bbf2acea"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a75b67b3697ab065bc7ef7568bbf2acea">getDepth</a> (uint32_t mipLevel=0) const</td></tr>
<tr class="memdesc:a75b67b3697ab065bc7ef7568bbf2acea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the depth of the user specified MIP-Map level for the texture.  <a href="structpvr_1_1_texture_header.html#a75b67b3697ab065bc7ef7568bbf2acea">More...</a><br /></td></tr>
<tr class="separator:a75b67b3697ab065bc7ef7568bbf2acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cc254244c30faa7024c4efae995984"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ae4cc254244c30faa7024c4efae995984">getDirect3DFormat</a> (uint32_t &amp;outD3dFormat) const</td></tr>
<tr class="memdesc:ae4cc254244c30faa7024c4efae995984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Direct3D equivalent format enumeration for this texture.  <a href="structpvr_1_1_texture_header.html#ae4cc254244c30faa7024c4efae995984">More...</a><br /></td></tr>
<tr class="separator:ae4cc254244c30faa7024c4efae995984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebba0b50aeefcb70009fd8ac0b694856"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aebba0b50aeefcb70009fd8ac0b694856">getDirectXGIFormat</a> (uint32_t &amp;outDxgiFormat, bool &amp;notAlpha) const</td></tr>
<tr class="memdesc:aebba0b50aeefcb70009fd8ac0b694856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the DirectXGI equivalent format enumeration for this texture.  <a href="structpvr_1_1_texture_header.html#aebba0b50aeefcb70009fd8ac0b694856">More...</a><br /></td></tr>
<tr class="separator:aebba0b50aeefcb70009fd8ac0b694856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26b8b3f7b23855330e27a1a05421868"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aa26b8b3f7b23855330e27a1a05421868">getHeight</a> (uint32_t uiMipMapLevel=0) const</td></tr>
<tr class="memdesc:aa26b8b3f7b23855330e27a1a05421868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the height of the user specified MIP-Map level for the texture.  <a href="structpvr_1_1_texture_header.html#aa26b8b3f7b23855330e27a1a05421868">More...</a><br /></td></tr>
<tr class="separator:aa26b8b3f7b23855330e27a1a05421868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af241d4635a13a7a649cb30fb05ffacfa"><td class="memItemLeft" align="right" valign="top">const std::map&lt; uint32_t, std::map&lt; uint32_t, <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#af241d4635a13a7a649cb30fb05ffacfa">getMetaDataMap</a> () const</td></tr>
<tr class="memdesc:af241d4635a13a7a649cb30fb05ffacfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer directly to the Meta Data Map, to allow users to read out data.  <a href="structpvr_1_1_texture_header.html#af241d4635a13a7a649cb30fb05ffacfa">More...</a><br /></td></tr>
<tr class="separator:af241d4635a13a7a649cb30fb05ffacfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a4a2c67675ce215979a72b80a0dc68"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a42a4a2c67675ce215979a72b80a0dc68">getMetaDataSize</a> () const</td></tr>
<tr class="memdesc:a42a4a2c67675ce215979a72b80a0dc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the meta data stored in the header. This includes the size of all information stored in all CPVRMetaDataBlocks.  <a href="structpvr_1_1_texture_header.html#a42a4a2c67675ce215979a72b80a0dc68">More...</a><br /></td></tr>
<tr class="separator:a42a4a2c67675ce215979a72b80a0dc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd034de9cff28da4b19fc7b3bf50420"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a5fd034de9cff28da4b19fc7b3bf50420">getMinDimensionsForFormat</a> (uint32_t &amp;minX, uint32_t &amp;minY, uint32_t &amp;minZ) const</td></tr>
<tr class="memdesc:a5fd034de9cff28da4b19fc7b3bf50420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum dimensions that the texture format of this header can be.  <a href="structpvr_1_1_texture_header.html#a5fd034de9cff28da4b19fc7b3bf50420">More...</a><br /></td></tr>
<tr class="separator:a5fd034de9cff28da4b19fc7b3bf50420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86df2b4bb4a776071fea200eed5df84a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a86df2b4bb4a776071fea200eed5df84a">getNumArrayMembers</a> () const</td></tr>
<tr class="memdesc:a86df2b4bb4a776071fea200eed5df84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of array members stored in this texture.  <a href="structpvr_1_1_texture_header.html#a86df2b4bb4a776071fea200eed5df84a">More...</a><br /></td></tr>
<tr class="separator:a86df2b4bb4a776071fea200eed5df84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d23d668b9e065612286ae7de868a690"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a8d23d668b9e065612286ae7de868a690">getNumFaces</a> () const</td></tr>
<tr class="memdesc:a8d23d668b9e065612286ae7de868a690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of faces stored in this texture.  <a href="structpvr_1_1_texture_header.html#a8d23d668b9e065612286ae7de868a690">More...</a><br /></td></tr>
<tr class="separator:a8d23d668b9e065612286ae7de868a690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6621f35f41ca5a11c2f5a3f50e459d82"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a6621f35f41ca5a11c2f5a3f50e459d82">getNumMipMapLevels</a> () const</td></tr>
<tr class="memdesc:a6621f35f41ca5a11c2f5a3f50e459d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of MIP-Map levels stored in this texture.  <a href="structpvr_1_1_texture_header.html#a6621f35f41ca5a11c2f5a3f50e459d82">More...</a><br /></td></tr>
<tr class="separator:a6621f35f41ca5a11c2f5a3f50e459d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c92a91b8166b06ee0d1ca949a727db2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_texture_meta_data.html#a5acad07c0f0cc281a017cb56e7a92f5a">TextureMetaData::AxisOrientation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a0c92a91b8166b06ee0d1ca949a727db2">getOrientation</a> (<a class="el" href="classpvr_1_1_texture_meta_data.html#ae6062237be958135b6d9cfc9fe0fb883">TextureMetaData::Axis</a> axis) const</td></tr>
<tr class="memdesc:a0c92a91b8166b06ee0d1ca949a727db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the data orientation for this texture.  <a href="structpvr_1_1_texture_header.html#a0c92a91b8166b06ee0d1ca949a727db2">More...</a><br /></td></tr>
<tr class="separator:a0c92a91b8166b06ee0d1ca949a727db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7396334bafe60274afa9ac751879ecf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a7396334bafe60274afa9ac751879ecf5">getPixelFormat</a> () const</td></tr>
<tr class="memdesc:a7396334bafe60274afa9ac751879ecf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pixel type ID of the texture.  <a href="structpvr_1_1_texture_header.html#a7396334bafe60274afa9ac751879ecf5">More...</a><br /></td></tr>
<tr class="separator:a7396334bafe60274afa9ac751879ecf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1217da8d95ea75f85455c2e52a3cad5f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a1217da8d95ea75f85455c2e52a3cad5f">getTextureSize</a> (int32_t mipMapLevel=pvrTextureAllMipMaps, bool allSurfaces=true, bool allFaces=true) const</td></tr>
<tr class="memdesc:a1217da8d95ea75f85455c2e52a3cad5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size in PIXELS of the texture, given various input parameters.  <a href="structpvr_1_1_texture_header.html#a1217da8d95ea75f85455c2e52a3cad5f">More...</a><br /></td></tr>
<tr class="separator:a1217da8d95ea75f85455c2e52a3cad5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2067e9d92450ab108cd952caa89da3bd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a2067e9d92450ab108cd952caa89da3bd">getWidth</a> (uint32_t uiMipMapLevel=0) const</td></tr>
<tr class="memdesc:a2067e9d92450ab108cd952caa89da3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the width of the user specified MIP-Map level for the texture.  <a href="structpvr_1_1_texture_header.html#a2067e9d92450ab108cd952caa89da3bd">More...</a><br /></td></tr>
<tr class="separator:a2067e9d92450ab108cd952caa89da3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64689d36069d0500968559a4e408a22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ad64689d36069d0500968559a4e408a22">isBumpMap</a> () const</td></tr>
<tr class="memdesc:ad64689d36069d0500968559a4e408a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this texture is bumpmap  <a href="structpvr_1_1_texture_header.html#ad64689d36069d0500968559a4e408a22">More...</a><br /></td></tr>
<tr class="separator:ad64689d36069d0500968559a4e408a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43ed55d9cdaba12ee0038bc3d48eb92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#af43ed55d9cdaba12ee0038bc3d48eb92">isFileCompressed</a> () const</td></tr>
<tr class="memdesc:af43ed55d9cdaba12ee0038bc3d48eb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression.  <a href="structpvr_1_1_texture_header.html#af43ed55d9cdaba12ee0038bc3d48eb92">More...</a><br /></td></tr>
<tr class="separator:af43ed55d9cdaba12ee0038bc3d48eb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b81566bc53a770ecd67cada7bee7da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ab6b81566bc53a770ecd67cada7bee7da">isPreMultiplied</a> () const</td></tr>
<tr class="memdesc:ab6b81566bc53a770ecd67cada7bee7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether or not the texture's color has been pre-multiplied by the alpha values.  <a href="structpvr_1_1_texture_header.html#ab6b81566bc53a770ecd67cada7bee7da">More...</a><br /></td></tr>
<tr class="separator:ab6b81566bc53a770ecd67cada7bee7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a015fac0ee35f2dbb69e079487309a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a28a015fac0ee35f2dbb69e079487309a">setBumpMap</a> (float bumpScale, std::string bumpOrder)</td></tr>
<tr class="memdesc:a28a015fac0ee35f2dbb69e079487309a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture's bump map data.  <a href="structpvr_1_1_texture_header.html#a28a015fac0ee35f2dbb69e079487309a">More...</a><br /></td></tr>
<tr class="separator:a28a015fac0ee35f2dbb69e079487309a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09da345ffb95b209ae9d515d342491cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a09da345ffb95b209ae9d515d342491cc">setChannelType</a> (<a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> newChannelType)</td></tr>
<tr class="memdesc:a09da345ffb95b209ae9d515d342491cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the channel type of this texture.  <a href="structpvr_1_1_texture_header.html#a09da345ffb95b209ae9d515d342491cc">More...</a><br /></td></tr>
<tr class="separator:a09da345ffb95b209ae9d515d342491cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe2fea504cd8ef590df356d61bcc215"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#acfe2fea504cd8ef590df356d61bcc215">setColorSpace</a> (<a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a> newColorSpace)</td></tr>
<tr class="memdesc:acfe2fea504cd8ef590df356d61bcc215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color space for this texture. Default is lRGB.  <a href="structpvr_1_1_texture_header.html#acfe2fea504cd8ef590df356d61bcc215">More...</a><br /></td></tr>
<tr class="separator:acfe2fea504cd8ef590df356d61bcc215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae0add42744eb80a320819c7a30ceba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a6ae0add42744eb80a320819c7a30ceba">setCubeMapOrder</a> (std::string cubeMapOrder)</td></tr>
<tr class="memdesc:a6ae0add42744eb80a320819c7a30ceba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture's bump map data.  <a href="structpvr_1_1_texture_header.html#a6ae0add42744eb80a320819c7a30ceba">More...</a><br /></td></tr>
<tr class="separator:a6ae0add42744eb80a320819c7a30ceba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7469359ed22b4c6bb41495d2fa2f4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a2b7469359ed22b4c6bb41495d2fa2f4e">setDepth</a> (uint32_t newDepth)</td></tr>
<tr class="memdesc:a2b7469359ed22b4c6bb41495d2fa2f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture depth.  <a href="structpvr_1_1_texture_header.html#a2b7469359ed22b4c6bb41495d2fa2f4e">More...</a><br /></td></tr>
<tr class="separator:a2b7469359ed22b4c6bb41495d2fa2f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa1c1b7885a83633003f9bc88d5b218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a2fa1c1b7885a83633003f9bc88d5b218">setHeight</a> (uint32_t newHeight)</td></tr>
<tr class="memdesc:a2fa1c1b7885a83633003f9bc88d5b218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture height.  <a href="structpvr_1_1_texture_header.html#a2fa1c1b7885a83633003f9bc88d5b218">More...</a><br /></td></tr>
<tr class="separator:a2fa1c1b7885a83633003f9bc88d5b218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cee1199768def6a9748792eb5b0ccc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a2cee1199768def6a9748792eb5b0ccc3">setIsFileCompressed</a> (bool <a class="el" href="structpvr_1_1_texture_header.html#af43ed55d9cdaba12ee0038bc3d48eb92">isFileCompressed</a>)</td></tr>
<tr class="memdesc:a2cee1199768def6a9748792eb5b0ccc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression. Currently unsupported.  <a href="structpvr_1_1_texture_header.html#a2cee1199768def6a9748792eb5b0ccc3">More...</a><br /></td></tr>
<tr class="separator:a2cee1199768def6a9748792eb5b0ccc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edb013521dccb80f92759ab1c45f61b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a3edb013521dccb80f92759ab1c45f61b">setIsPreMultiplied</a> (bool <a class="el" href="structpvr_1_1_texture_header.html#ab6b81566bc53a770ecd67cada7bee7da">isPreMultiplied</a>)</td></tr>
<tr class="memdesc:a3edb013521dccb80f92759ab1c45f61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the texture's color has been pre-multiplied by the alpha values.  <a href="structpvr_1_1_texture_header.html#a3edb013521dccb80f92759ab1c45f61b">More...</a><br /></td></tr>
<tr class="separator:a3edb013521dccb80f92759ab1c45f61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746d4244f009e9e13318710b5842fe9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a746d4244f009e9e13318710b5842fe9a">setNumArrayMembers</a> (uint32_t numNewMembers)</td></tr>
<tr class="memdesc:a746d4244f009e9e13318710b5842fe9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of arrays in this texture  <a href="structpvr_1_1_texture_header.html#a746d4244f009e9e13318710b5842fe9a">More...</a><br /></td></tr>
<tr class="separator:a746d4244f009e9e13318710b5842fe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9525ab8947e88b614c6e81b575d5c3c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a9525ab8947e88b614c6e81b575d5c3c9">setNumFaces</a> (uint32_t numNewFaces)</td></tr>
<tr class="memdesc:a9525ab8947e88b614c6e81b575d5c3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of faces stored in this texture.  <a href="structpvr_1_1_texture_header.html#a9525ab8947e88b614c6e81b575d5c3c9">More...</a><br /></td></tr>
<tr class="separator:a9525ab8947e88b614c6e81b575d5c3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6fe8d132b26659e9072282dd037054"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a0c6fe8d132b26659e9072282dd037054">setNumMipMapLevels</a> (uint32_t numNewMipMapLevels)</td></tr>
<tr class="memdesc:a0c6fe8d132b26659e9072282dd037054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of MIP-Map levels in this texture.  <a href="structpvr_1_1_texture_header.html#a0c6fe8d132b26659e9072282dd037054">More...</a><br /></td></tr>
<tr class="separator:a0c6fe8d132b26659e9072282dd037054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafee0c616f4217ebc193b0a4082a72f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aaafee0c616f4217ebc193b0a4082a72f">setOrientation</a> (<a class="el" href="classpvr_1_1_texture_meta_data.html#a5acad07c0f0cc281a017cb56e7a92f5a">TextureMetaData::AxisOrientation</a> axisOrientation)</td></tr>
<tr class="memdesc:aaafee0c616f4217ebc193b0a4082a72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data orientation for a given axis in this texture.  <a href="structpvr_1_1_texture_header.html#aaafee0c616f4217ebc193b0a4082a72f">More...</a><br /></td></tr>
<tr class="separator:aaafee0c616f4217ebc193b0a4082a72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac843ef8bfde1ea52d0aad891807c4ea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ac843ef8bfde1ea52d0aad891807c4ea2">setPixelFormat</a> (<a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a> uPixelFormat)</td></tr>
<tr class="memdesc:ac843ef8bfde1ea52d0aad891807c4ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pixel format for this texture.  <a href="structpvr_1_1_texture_header.html#ac843ef8bfde1ea52d0aad891807c4ea2">More...</a><br /></td></tr>
<tr class="separator:ac843ef8bfde1ea52d0aad891807c4ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b546b020e47df211588a983cc9872e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a4b546b020e47df211588a983cc9872e7">setWidth</a> (uint32_t newWidth)</td></tr>
<tr class="memdesc:a4b546b020e47df211588a983cc9872e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture width.  <a href="structpvr_1_1_texture_header.html#a4b546b020e47df211588a983cc9872e7">More...</a><br /></td></tr>
<tr class="separator:a4b546b020e47df211588a983cc9872e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a610b01b773fc32dd8b829e9dee05b0e2"><td class="memItemLeft" align="right" valign="top"><a id="a610b01b773fc32dd8b829e9dee05b0e2"></a>
std::map&lt; uint32_t, std::map&lt; uint32_t, <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a610b01b773fc32dd8b829e9dee05b0e2">_metaDataMap</a></td></tr>
<tr class="memdesc:a610b01b773fc32dd8b829e9dee05b0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all the meta data stored for a texture. <br /></td></tr>
<tr class="separator:a610b01b773fc32dd8b829e9dee05b0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc964624a1c060d774ccf2419882e68"><td class="memItemLeft" align="right" valign="top"><a id="a6dc964624a1c060d774ccf2419882e68"></a>
<a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a6dc964624a1c060d774ccf2419882e68">channelType</a></td></tr>
<tr class="memdesc:a6dc964624a1c060d774ccf2419882e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable type that the channel is stored in. Supports signed/unsigned int/short/char/float. <br /></td></tr>
<tr class="separator:a6dc964624a1c060d774ccf2419882e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8c205bfe7a99cc479e2e8eeb3ac082"><td class="memItemLeft" align="right" valign="top"><a id="aae8c205bfe7a99cc479e2e8eeb3ac082"></a>
<a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aae8c205bfe7a99cc479e2e8eeb3ac082">colorSpace</a></td></tr>
<tr class="memdesc:aae8c205bfe7a99cc479e2e8eeb3ac082"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Color Space of the texture, currently either linear RGB or sRGB. <br /></td></tr>
<tr class="separator:aae8c205bfe7a99cc479e2e8eeb3ac082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c45b53efb7db69ab1c782c3441a323"><td class="memItemLeft" align="right" valign="top"><a id="a62c45b53efb7db69ab1c782c3441a323"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a62c45b53efb7db69ab1c782c3441a323">depth</a></td></tr>
<tr class="memdesc:a62c45b53efb7db69ab1c782c3441a323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth of the texture. (Z-slices) <br /></td></tr>
<tr class="separator:a62c45b53efb7db69ab1c782c3441a323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9621fca15af7e7abd7a4c0839b1f6d72"><td class="memItemLeft" align="right" valign="top"><a id="a9621fca15af7e7abd7a4c0839b1f6d72"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a9621fca15af7e7abd7a4c0839b1f6d72">flags</a></td></tr>
<tr class="memdesc:a9621fca15af7e7abd7a4c0839b1f6d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various format flags. <br /></td></tr>
<tr class="separator:a9621fca15af7e7abd7a4c0839b1f6d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2860b2e50a2ddc9b05769b7178b54858"><td class="memItemLeft" align="right" valign="top"><a id="a2860b2e50a2ddc9b05769b7178b54858"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a2860b2e50a2ddc9b05769b7178b54858">height</a></td></tr>
<tr class="memdesc:a2860b2e50a2ddc9b05769b7178b54858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Height of the texture. <br /></td></tr>
<tr class="separator:a2860b2e50a2ddc9b05769b7178b54858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4488946b871a1bf11f465b10923779c1"><td class="memItemLeft" align="right" valign="top"><a id="a4488946b871a1bf11f465b10923779c1"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a4488946b871a1bf11f465b10923779c1">metaDataSize</a></td></tr>
<tr class="memdesc:a4488946b871a1bf11f465b10923779c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the accompanying meta data. <br /></td></tr>
<tr class="separator:a4488946b871a1bf11f465b10923779c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73034dd746eae6a6b97964196bb35f6"><td class="memItemLeft" align="right" valign="top"><a id="ae73034dd746eae6a6b97964196bb35f6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ae73034dd746eae6a6b97964196bb35f6">numFaces</a></td></tr>
<tr class="memdesc:ae73034dd746eae6a6b97964196bb35f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of faces in a Cube Map. Maybe be a value other than 6. <br /></td></tr>
<tr class="separator:ae73034dd746eae6a6b97964196bb35f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9708c183c5836408d74d5b341846594"><td class="memItemLeft" align="right" valign="top"><a id="aa9708c183c5836408d74d5b341846594"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aa9708c183c5836408d74d5b341846594">numMipMaps</a></td></tr>
<tr class="memdesc:aa9708c183c5836408d74d5b341846594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of MIP Maps in the texture - NB: Includes top level. <br /></td></tr>
<tr class="separator:aa9708c183c5836408d74d5b341846594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e90b5846cddef394f1f0e313d8a8a8"><td class="memItemLeft" align="right" valign="top"><a id="a04e90b5846cddef394f1f0e313d8a8a8"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a04e90b5846cddef394f1f0e313d8a8a8">numSurfaces</a></td></tr>
<tr class="memdesc:a04e90b5846cddef394f1f0e313d8a8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of members in a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> Array. <br /></td></tr>
<tr class="separator:a04e90b5846cddef394f1f0e313d8a8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4edd7302ab785ff47b46dd4f46170f"><td class="memItemLeft" align="right" valign="top"><a id="a0c4edd7302ab785ff47b46dd4f46170f"></a>
<a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a0c4edd7302ab785ff47b46dd4f46170f">pixelFormat</a></td></tr>
<tr class="memdesc:a0c4edd7302ab785ff47b46dd4f46170f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pixel format, 8cc value storing the 4 channel identifiers and their respective sizes. <br /></td></tr>
<tr class="separator:a0c4edd7302ab785ff47b46dd4f46170f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c32d51bbf9386f82c017c1b867ac362"><td class="memItemLeft" align="right" valign="top"><a id="a0c32d51bbf9386f82c017c1b867ac362"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a0c32d51bbf9386f82c017c1b867ac362">width</a></td></tr>
<tr class="memdesc:a0c32d51bbf9386f82c017c1b867ac362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of the texture. <br /></td></tr>
<tr class="separator:a0c32d51bbf9386f82c017c1b867ac362"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class mirroring the PVR <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> container format header, and which can in general represent any <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset. Contains accessors functions to facilitate using the <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> data in application code. /summary&gt; </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa575a1cac05e7c71cc544ff4469264a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa575a1cac05e7c71cc544ff4469264a4">&#9670;&nbsp;</a></span>Constants</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4">pvr::TextureHeader::Constants</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This header stores everything that you would ever need to load (but not necessarily use) a texture's data accurately, but no more. Data that is provided but is not needed to read the data is stored in the Metadata section (See TextureHeaderWithMetadata). Correct use of the texture may rely on meta data, but accurate data loading can be done through the standard header alone. </p>
<p>&lt; Contains constants used by the header </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa575a1cac05e7c71cc544ff4469264a4a167572588891304475e448c9a44d0a46"></a>PVRv3&#160;</td><td class="fielddoc"><p>PVR format v3 identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa575a1cac05e7c71cc544ff4469264a4ae2cd40f7ccea4ca3ef7c46970ab43af6"></a>PVRv3Reversed&#160;</td><td class="fielddoc"><p>PVR format v3 reversed identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa575a1cac05e7c71cc544ff4469264a4a43bea9e5650f87f5b16b074cbe26f622"></a>CompressedFlag&#160;</td><td class="fielddoc"><p>Compressed format flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa575a1cac05e7c71cc544ff4469264a4a9253d5725cfe9a48d00e6eb0c9651e29"></a>PremultipliedFlag&#160;</td><td class="fielddoc"><p>Premultiplied flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa575a1cac05e7c71cc544ff4469264a4a656632f4d3e87051deca7655ead0f65b"></a>SizeOfHeader&#160;</td><td class="fielddoc"><p>The total size of the header in bytes. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeb28e3c3a9f26529ff3fb001fe327f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb28e3c3a9f26529ff3fb001fe327f04">&#9670;&nbsp;</a></span>TextureHeader() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::TextureHeader::TextureHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor for a <a class="el" href="structpvr_1_1_texture_header.html" title="A class mirroring the PVR Texture container format header, and which can in general represent any Tex...">TextureHeader</a>. Returns an empty header. </p>

</div>
</div>
<a id="a2f914183d01dac387bb4b434317b5c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f914183d01dac387bb4b434317b5c30">&#9670;&nbsp;</a></span>TextureHeader() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::TextureHeader::TextureHeader </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numMetaData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> *&#160;</td>
          <td class="paramname"><em>metaData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct this from file header and meta data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileHeader</td><td>File header to construct from</td></tr>
    <tr><td class="paramname">numMetaData</td><td>Number of meta data in the array</td></tr>
    <tr><td class="paramname">metaData</td><td>Array of meta data</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a147a439d7cd6ad60ec53fb67b0be4445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147a439d7cd6ad60ec53fb67b0be4445">&#9670;&nbsp;</a></span>TextureHeader() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::TextureHeader::TextureHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>pixelFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numMipMaps</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a>&#160;</td>
          <td class="paramname"><em>colorSpace</em> = <code><a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91a4c8bf835da6d934b50f620cdd0cc3913">ColorSpace::lRGB</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a>&#160;</td>
          <td class="paramname"><em>channelType</em> = <code>VariableType::UnsignedByteNorm</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numSurfaces</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numFaces</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> *&#160;</td>
          <td class="paramname"><em>metaData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>metaDataSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelFormat</td><td>Pixel format of the texture</td></tr>
    <tr><td class="paramname">width</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> width</td></tr>
    <tr><td class="paramname">height</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> height</td></tr>
    <tr><td class="paramname">depth</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> depth</td></tr>
    <tr><td class="paramname">numMipMaps</td><td>Number of mipmap in the texture</td></tr>
    <tr><td class="paramname">colorSpace</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> color space (e.g sRGB, lRGB)</td></tr>
    <tr><td class="paramname">channelType</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> channel type</td></tr>
    <tr><td class="paramname">numSurfaces</td><td>Number of surfaces the texture has</td></tr>
    <tr><td class="paramname">numFaces</td><td>Number of faces the texture has</td></tr>
    <tr><td class="paramname">flags</td><td>Additional provided flags</td></tr>
    <tr><td class="paramname">metaData</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> meta data</td></tr>
    <tr><td class="paramname">metaDataSize</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> meta data size</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a15c81430182569becd27c48dc12e9f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c81430182569becd27c48dc12e9f36">&#9670;&nbsp;</a></span>addMetaData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::addMetaData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>metaData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an arbitrary piece of meta data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaData</td><td>Meta data block to be added.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6464f127a35d2e4f275d6db3a8ff8d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6464f127a35d2e4f275d6db3a8ff8d81">&#9670;&nbsp;</a></span>getBitsPerPixel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getBitsPerPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the bits per pixel of the texture format. </p>
<dl class="section return"><dt>Returns</dt><dd>Return number of bits per pixel</dd></dl>

</div>
</div>
<a id="a274e7f9171bdb833117b3f13cb55325a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274e7f9171bdb833117b3f13cb55325a">&#9670;&nbsp;</a></span>getChannelType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> pvr::TextureHeader::getChannelType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the channel type that the texture's data is stored in. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the enum representing the type of the texture.</dd></dl>

</div>
</div>
<a id="a9252454143fb760f259b844e7df6e476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9252454143fb760f259b844e7df6e476">&#9670;&nbsp;</a></span>getColorSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a> pvr::TextureHeader::getColorSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the color space of the texture. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the ColorSpace enum representing color space.</dd></dl>

</div>
</div>
<a id="ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1">&#9670;&nbsp;</a></span>getCubeMapOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string pvr::TextureHeader::getCubeMapOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the cube map face order. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns cube map order.</dd></dl>
<p>Returned std::string will be in the form "ZzXxYy" with capitals representing positive and small letters representing negative. I.e. Z=Z-Positive, z=Z-Negative.</p>

</div>
</div>
<a id="ac857e69832c7f453963d00d125b2914c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac857e69832c7f453963d00d125b2914c">&#9670;&nbsp;</a></span>getDataOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t pvr::TextureHeader::getDataOffset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayMember</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>face</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a offset in the data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipMapLevel</td><td>The mip map level of the offset</td></tr>
    <tr><td class="paramname">arrayMember</td><td>The array index of the offset</td></tr>
    <tr><td class="paramname">face</td><td>The face of the offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return data offset</dd></dl>

</div>
</div>
<a id="aebb19f136932ee5150570dc9ec4d84e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb19f136932ee5150570dc9ec4d84e6">&#9670;&nbsp;</a></span>getDataSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getDataSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>mipLevel</em> = <code>pvrTextureAllMipMaps</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allSurfaces</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allFaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size in BYTES of the texture, given various input parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipLevel</td><td>Specifies a mip level to check, 'c_pvrTextureAllMIPMapLevels' can be passed to Get the size of all MIP levels.</td></tr>
    <tr><td class="paramname">allSurfaces</td><td>The Size of all surfaces is calculated if true, only a single surface if false. /param&gt; <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allFaces</td><td>The Size of all faces is calculated if true, only a single face if false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the size in BYTES of the specified texture area.</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>User can retrieve the size of either all surfaces or a single surface, all faces or a single face and all MIP-Maps or a single specified MIP level.</p>

</div>
</div>
<a id="a75b67b3697ab065bc7ef7568bbf2acea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b67b3697ab065bc7ef7568bbf2acea">&#9670;&nbsp;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getDepth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipLevel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the depth of the user specified MIP-Map level for the texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipLevel</td><td>MIP level that user is interested in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the depth of the specified MIP-Map level.</dd></dl>

</div>
</div>
<a id="ae4cc254244c30faa7024c4efae995984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cc254244c30faa7024c4efae995984">&#9670;&nbsp;</a></span>getDirect3DFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::TextureHeader::getDirect3DFormat </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>outD3dFormat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Direct3D equivalent format enumeration for this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outD3dFormat</td><td>Returned d3d format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, returns false if it cannot find a suitable type</dd></dl>

</div>
</div>
<a id="aebba0b50aeefcb70009fd8ac0b694856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebba0b50aeefcb70009fd8ac0b694856">&#9670;&nbsp;</a></span>getDirectXGIFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::TextureHeader::getDirectXGIFormat </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>outDxgiFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>notAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the DirectXGI equivalent format enumeration for this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notAlpha</td><td>Return whether the <em>outDxgiFormat</em> is has alpha or not.</td></tr>
    <tr><td class="paramname">outDxgiFormat</td><td>Returned dxgi format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, returns false if it cannot find a suitable type</dd></dl>

</div>
</div>
<a id="aa26b8b3f7b23855330e27a1a05421868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26b8b3f7b23855330e27a1a05421868">&#9670;&nbsp;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getHeight </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uiMipMapLevel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the height of the user specified MIP-Map level for the texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiMipMapLevel</td><td>MIP level that user is interested in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the Height of the specified MIP-Map level.</dd></dl>

</div>
</div>
<a id="af241d4635a13a7a649cb30fb05ffacfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af241d4635a13a7a649cb30fb05ffacfa">&#9670;&nbsp;</a></span>getMetaDataMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;uint32_t, std::map&lt;uint32_t, <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a>&gt; &gt;* pvr::TextureHeader::getMetaDataMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer directly to the Meta Data Map, to allow users to read out data. </p>
<dl class="section return"><dt>Returns</dt><dd>Return a direct pointer to the MetaData map.</dd></dl>

</div>
</div>
<a id="a42a4a2c67675ce215979a72b80a0dc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a4a2c67675ce215979a72b80a0dc68">&#9670;&nbsp;</a></span>getMetaDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getMetaDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total size of the meta data stored in the header. This includes the size of all information stored in all CPVRMetaDataBlocks. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the size, in bytes, of the meta data stored in the header.</dd></dl>

</div>
</div>
<a id="a5fd034de9cff28da4b19fc7b3bf50420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd034de9cff28da4b19fc7b3bf50420">&#9670;&nbsp;</a></span>getMinDimensionsForFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::getMinDimensionsForFormat </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>minX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>minY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>minZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum dimensions that the texture format of this header can be. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minX</td><td>Minimum width of the texture format.</td></tr>
    <tr><td class="paramname">minY</td><td>Minimum height of the texture format.</td></tr>
    <tr><td class="paramname">minZ</td><td>Minimum depth of the texture format.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86df2b4bb4a776071fea200eed5df84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86df2b4bb4a776071fea200eed5df84a">&#9670;&nbsp;</a></span>getNumArrayMembers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getNumArrayMembers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of array members stored in this texture. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the number of array members in this texture.</dd></dl>

</div>
</div>
<a id="a8d23d668b9e065612286ae7de868a690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d23d668b9e065612286ae7de868a690">&#9670;&nbsp;</a></span>getNumFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getNumFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of faces stored in this texture. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the number of faces in this texture.</dd></dl>

</div>
</div>
<a id="a6621f35f41ca5a11c2f5a3f50e459d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6621f35f41ca5a11c2f5a3f50e459d82">&#9670;&nbsp;</a></span>getNumMipMapLevels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getNumMipMapLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of MIP-Map levels stored in this texture. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the number of MIP-Map levels in this texture.</dd></dl>

</div>
</div>
<a id="a0c92a91b8166b06ee0d1ca949a727db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c92a91b8166b06ee0d1ca949a727db2">&#9670;&nbsp;</a></span>getOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_texture_meta_data.html#a5acad07c0f0cc281a017cb56e7a92f5a">TextureMetaData::AxisOrientation</a> pvr::TextureHeader::getOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_texture_meta_data.html#ae6062237be958135b6d9cfc9fe0fb883">TextureMetaData::Axis</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the data orientation for this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The axis to examine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the orientation of the axis.</dd></dl>

</div>
</div>
<a id="a7396334bafe60274afa9ac751879ecf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7396334bafe60274afa9ac751879ecf5">&#9670;&nbsp;</a></span>getPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a> pvr::TextureHeader::getPixelFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pixel type ID of the texture. </p>
<dl class="section return"><dt>Returns</dt><dd>Return a 64-bit pixel type ID.</dd></dl>

</div>
</div>
<a id="a1217da8d95ea75f85455c2e52a3cad5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1217da8d95ea75f85455c2e52a3cad5f">&#9670;&nbsp;</a></span>getTextureSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getTextureSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>pvrTextureAllMipMaps</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allSurfaces</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allFaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size in PIXELS of the texture, given various input parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipMapLevel</td><td>Specifies a MIP level to check, 'c_pvrTextureAllMIPMapLevels' can be passed to Get the size of all MIP levels.</td></tr>
    <tr><td class="paramname">allSurfaces</td><td>The Size of all surfaces is calculated if true, only a single surface if false. /param&gt; <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allFaces</td><td>The Size of all faces is calculated if true, only a single face if false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the size in PIXELS of the specified texture area.</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>User can retrieve the total size of either all surfaces or a single surface, all faces or a single face and all MIP-Maps or a single specified MIP level. All of these</p>

</div>
</div>
<a id="a2067e9d92450ab108cd952caa89da3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2067e9d92450ab108cd952caa89da3bd">&#9670;&nbsp;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getWidth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uiMipMapLevel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the width of the user specified MIP-Map level for the texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiMipMapLevel</td><td>MIP level that user is interested in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the width of the specified MIP-Map level.</dd></dl>

</div>
</div>
<a id="ad64689d36069d0500968559a4e408a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64689d36069d0500968559a4e408a22">&#9670;&nbsp;</a></span>isBumpMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::TextureHeader::isBumpMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this texture is bumpmap </p>
<dl class="section return"><dt>Returns</dt><dd>Return true if the texture is bumpmap</dd></dl>

</div>
</div>
<a id="af43ed55d9cdaba12ee0038bc3d48eb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43ed55d9cdaba12ee0038bc3d48eb92">&#9670;&nbsp;</a></span>isFileCompressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::TextureHeader::isFileCompressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression. </p>
<dl class="section return"><dt>Returns</dt><dd>Return true if it is file compressed.</dd></dl>

</div>
</div>
<a id="ab6b81566bc53a770ecd67cada7bee7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b81566bc53a770ecd67cada7bee7da">&#9670;&nbsp;</a></span>isPreMultiplied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::TextureHeader::isPreMultiplied </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether or not the texture's color has been pre-multiplied by the alpha values. </p>
<dl class="section return"><dt>Returns</dt><dd>Return true if texture is premultiplied.</dd></dl>

</div>
</div>
<a id="a28a015fac0ee35f2dbb69e079487309a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a015fac0ee35f2dbb69e079487309a">&#9670;&nbsp;</a></span>setBumpMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setBumpMap </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bumpScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>bumpOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a texture's bump map data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bumpScale</td><td>Floating point "height" value to scale the bump map.</td></tr>
    <tr><td class="paramname">bumpOrder</td><td>Up to 4 character std::string, with values x,y,z,h in some combination.</td></tr>
  </table>
  </dd>
</dl>
<p>For <em>bumpOrder</em> Not all values need to be present. Denotes channel order: x,y,z refer to the corresponding axes, h indicates presence of the original height map. It is possible to have only some of these values rather than all. For example if 'h' is present alone it will be considered a height map. The values should be presented in RGBA order, regardless of the texture format, so a zyxh order in a bgra texture should still be passed as 'xyzh'. Capitals are allowed. Any character stored here that is not one of x,y,z,h or a NULL character will be ignored when PVRTexLib reads the data, but will be preserved. This is useful if you wish to define a custom data channel for instance. In these instances PVRTexLib will assume it is simply color data.</p>

</div>
</div>
<a id="a09da345ffb95b209ae9d515d342491cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09da345ffb95b209ae9d515d342491cc">&#9670;&nbsp;</a></span>setChannelType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setChannelType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a>&#160;</td>
          <td class="paramname"><em>newChannelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the channel type of this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelType</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a>'s channel type</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfe2fea504cd8ef590df356d61bcc215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe2fea504cd8ef590df356d61bcc215">&#9670;&nbsp;</a></span>setColorSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setColorSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a>&#160;</td>
          <td class="paramname"><em>newColorSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the color space for this texture. Default is lRGB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorSpace</td><td>A color space of the texture.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ae0add42744eb80a320819c7a30ceba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae0add42744eb80a320819c7a30ceba">&#9670;&nbsp;</a></span>setCubeMapOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setCubeMapOrder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cubeMapOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a texture's bump map data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cubeMapOrder</td><td>Up to 6 character std::string, with values x,X,y,Y,z,Z in some combination.</td></tr>
  </table>
  </dd>
</dl>
<p>for <em>cubmapOrder</em> Not all values need to be present. Denotes face order: Capitals refer to positive axis positions and small letters refer to negative axis positions. E.g. x=X-Negative, X=X-Positive. It is possible to have only some of these values rather than all, as long as they are NULL terminated. NB: Values past the 6th character are not read.</p>

</div>
</div>
<a id="a2b7469359ed22b4c6bb41495d2fa2f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7469359ed22b4c6bb41495d2fa2f4e">&#9670;&nbsp;</a></span>setDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setDepth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>newDepth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the texture depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newDepth</td><td>The new depth.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fa1c1b7885a83633003f9bc88d5b218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa1c1b7885a83633003f9bc88d5b218">&#9670;&nbsp;</a></span>setHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setHeight </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>newHeight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the texture height. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newHeight</td><td>The new height.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cee1199768def6a9748792eb5b0ccc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cee1199768def6a9748792eb5b0ccc3">&#9670;&nbsp;</a></span>setIsFileCompressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setIsFileCompressed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isFileCompressed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression. Currently unsupported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isFileCompressed</td><td>Sets file compression to true/false.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3edb013521dccb80f92759ab1c45f61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edb013521dccb80f92759ab1c45f61b">&#9670;&nbsp;</a></span>setIsPreMultiplied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setIsPreMultiplied </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPreMultiplied</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not the texture's color has been pre-multiplied by the alpha values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isPreMultiplied</td><td>Sets if texture is premultiplied.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a746d4244f009e9e13318710b5842fe9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746d4244f009e9e13318710b5842fe9a">&#9670;&nbsp;</a></span>setNumArrayMembers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setNumArrayMembers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numNewMembers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of arrays in this texture </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numNewMembers</td><td>The new number of members in this array.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9525ab8947e88b614c6e81b575d5c3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9525ab8947e88b614c6e81b575d5c3c9">&#9670;&nbsp;</a></span>setNumFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setNumFaces </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numNewFaces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of faces stored in this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numNewFaces</td><td>New number of faces for this texture.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c6fe8d132b26659e9072282dd037054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6fe8d132b26659e9072282dd037054">&#9670;&nbsp;</a></span>setNumMipMapLevels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setNumMipMapLevels </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numNewMipMapLevels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of MIP-Map levels in this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numNewMipMapLevels</td><td>New number of MIP-Map levels.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaafee0c616f4217ebc193b0a4082a72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafee0c616f4217ebc193b0a4082a72f">&#9670;&nbsp;</a></span>setOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_texture_meta_data.html#a5acad07c0f0cc281a017cb56e7a92f5a">TextureMetaData::AxisOrientation</a>&#160;</td>
          <td class="paramname"><em>axisOrientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the data orientation for a given axis in this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axisOrientation</td><td>Specifying axis and orientation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac843ef8bfde1ea52d0aad891807c4ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac843ef8bfde1ea52d0aad891807c4ea2">&#9670;&nbsp;</a></span>setPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setPixelFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>uPixelFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pixel format for this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uPixelFormat</td><td>The format of the pixel.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b546b020e47df211588a983cc9872e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b546b020e47df211588a983cc9872e7">&#9670;&nbsp;</a></span>setWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setWidth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>newWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the texture width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newWidth</td><td>The new width.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRCore/texture/<a class="el" href="_texture_header_8h_source.html">TextureHeader.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="20%" height="20%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
