<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PVRCore: pvr::Texture Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="80%" height="80%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRCore</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="classpvr_1_1_texture.html">Texture</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classpvr_1_1_texture-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::Texture Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A 2D <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset, together with Information, Metadata and actual Pixel data. Only represents the actual data, not the API objects that may be created from it.  
 <a href="classpvr_1_1_texture.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::Texture:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1_texture__inherit__graph.png" border="0" usemap="#pvr_1_1_texture_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1_texture_inherit__map" id="pvr_1_1_texture_inherit__map">
<area shape="rect" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac..." alt="" coords="29,80,128,107"/>
<area shape="rect" href="structpvr_1_1_texture_header.html" title="A class mirroring the PVR Texture container format header, and which can in general represent any Tex..." alt="" coords="5,5,152,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa575a1cac05e7c71cc544ff4469264a4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4">Constants</a> { <br />
&#160;&#160;<a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4a167572588891304475e448c9a44d0a46">PVRv3</a> = 0x03525650, 
<a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4ae2cd40f7ccea4ca3ef7c46970ab43af6">PVRv3Reversed</a> = 0x50565203, 
<a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4a43bea9e5650f87f5b16b074cbe26f622">CompressedFlag</a> = (1 &lt;&lt; 0), 
<a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4a9253d5725cfe9a48d00e6eb0c9651e29">PremultipliedFlag</a> = (1 &lt;&lt; 1), 
<br />
&#160;&#160;<a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4a656632f4d3e87051deca7655ead0f65b">SizeOfHeader</a> = 52
<br />
 }</td></tr>
<tr class="memdesc:aa575a1cac05e7c71cc544ff4469264a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This header stores everything that you would ever need to load (but not necessarily use) a texture's data accurately, but no more. Data that is provided but is not needed to read the data is stored in the Metadata section (See TextureHeaderWithMetadata). Correct use of the texture may rely on meta data, but accurate data loading can be done through the standard header alone.  <a href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4">More...</a><br /></td></tr>
<tr class="separator:aa575a1cac05e7c71cc544ff4469264a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1d4ae5b8b2c94ca4cc26d84350c0073d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a1d4ae5b8b2c94ca4cc26d84350c0073d">Texture</a> ()</td></tr>
<tr class="memdesc:a1d4ae5b8b2c94ca4cc26d84350c0073d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new empty texture.  <a href="classpvr_1_1_texture.html#a1d4ae5b8b2c94ca4cc26d84350c0073d">More...</a><br /></td></tr>
<tr class="separator:a1d4ae5b8b2c94ca4cc26d84350c0073d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e5e89a98b484b2c09757f6b9f967f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a61e5e89a98b484b2c09757f6b9f967f0">Texture</a> (const <a class="el" href="structpvr_1_1_texture_header.html">TextureHeader</a> &amp;sHeader, const unsigned char *pData=NULL)</td></tr>
<tr class="memdesc:a61e5e89a98b484b2c09757f6b9f967f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture using the information from a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> header and copy the actual data from a provided pointer.  <a href="classpvr_1_1_texture.html#a61e5e89a98b484b2c09757f6b9f967f0">More...</a><br /></td></tr>
<tr class="separator:a61e5e89a98b484b2c09757f6b9f967f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c81430182569becd27c48dc12e9f36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a15c81430182569becd27c48dc12e9f36">addMetaData</a> (const <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> &amp;metaData)</td></tr>
<tr class="memdesc:a15c81430182569becd27c48dc12e9f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an arbitrary piece of meta data.  <a href="structpvr_1_1_texture_header.html#a15c81430182569becd27c48dc12e9f36">More...</a><br /></td></tr>
<tr class="separator:a15c81430182569becd27c48dc12e9f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eba5d93f2335cdb4085ad88b8e3a5cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a0eba5d93f2335cdb4085ad88b8e3a5cf">addPaddingMetaData</a> (uint32_t alignment)</td></tr>
<tr class="memdesc:a0eba5d93f2335cdb4085ad88b8e3a5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function pads to a boundary value equal to "uiPadding". For example, setting alignment=8 will align the start of the texture data to an 8 char boundary.  <a href="classpvr_1_1_texture.html#a0eba5d93f2335cdb4085ad88b8e3a5cf">More...</a><br /></td></tr>
<tr class="separator:a0eba5d93f2335cdb4085ad88b8e3a5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6464f127a35d2e4f275d6db3a8ff8d81"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a6464f127a35d2e4f275d6db3a8ff8d81">getBitsPerPixel</a> () const</td></tr>
<tr class="memdesc:a6464f127a35d2e4f275d6db3a8ff8d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bits per pixel of the texture format.  <a href="structpvr_1_1_texture_header.html#a6464f127a35d2e4f275d6db3a8ff8d81">More...</a><br /></td></tr>
<tr class="separator:a6464f127a35d2e4f275d6db3a8ff8d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274e7f9171bdb833117b3f13cb55325a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a274e7f9171bdb833117b3f13cb55325a">getChannelType</a> () const</td></tr>
<tr class="memdesc:a274e7f9171bdb833117b3f13cb55325a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the channel type that the texture's data is stored in.  <a href="structpvr_1_1_texture_header.html#a274e7f9171bdb833117b3f13cb55325a">More...</a><br /></td></tr>
<tr class="separator:a274e7f9171bdb833117b3f13cb55325a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9252454143fb760f259b844e7df6e476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a9252454143fb760f259b844e7df6e476">getColorSpace</a> () const</td></tr>
<tr class="memdesc:a9252454143fb760f259b844e7df6e476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the color space of the texture.  <a href="structpvr_1_1_texture_header.html#a9252454143fb760f259b844e7df6e476">More...</a><br /></td></tr>
<tr class="separator:a9252454143fb760f259b844e7df6e476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1">getCubeMapOrder</a> () const</td></tr>
<tr class="memdesc:ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the cube map face order.  <a href="structpvr_1_1_texture_header.html#ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1">More...</a><br /></td></tr>
<tr class="separator:ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21098a02ff1c57c9c1830a953c47df20"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a21098a02ff1c57c9c1830a953c47df20">getCubemapPixel</a> (float x, float y, float z, uint32_t mipMapLevel=0, uint32_t arrayMember=0)</td></tr>
<tr class="memdesc:a21098a02ff1c57c9c1830a953c47df20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the data for the direction (x,y,z) provided for the specific mip map level and array layer.  <a href="classpvr_1_1_texture.html#a21098a02ff1c57c9c1830a953c47df20">More...</a><br /></td></tr>
<tr class="separator:a21098a02ff1c57c9c1830a953c47df20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac857e69832c7f453963d00d125b2914c"><td class="memItemLeft" align="right" valign="top">ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ac857e69832c7f453963d00d125b2914c">getDataOffset</a> (uint32_t mipMapLevel=0, uint32_t arrayMember=0, uint32_t face=0) const</td></tr>
<tr class="memdesc:ac857e69832c7f453963d00d125b2914c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a offset in the data  <a href="structpvr_1_1_texture_header.html#ac857e69832c7f453963d00d125b2914c">More...</a><br /></td></tr>
<tr class="separator:ac857e69832c7f453963d00d125b2914c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c3d7c47fe8507e1730a27039ba8b6d"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a45c3d7c47fe8507e1730a27039ba8b6d">getDataPointer</a> (uint32_t mipMapLevel=0, uint32_t arrayMember=0, uint32_t face=0)</td></tr>
<tr class="memdesc:a45c3d7c47fe8507e1730a27039ba8b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer into the raw texture's data. Can be offset to a specific array member, face and/or MIP Map levels.  <a href="classpvr_1_1_texture.html#a45c3d7c47fe8507e1730a27039ba8b6d">More...</a><br /></td></tr>
<tr class="separator:a45c3d7c47fe8507e1730a27039ba8b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76820857331fc851753b72f4c906b44f"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a76820857331fc851753b72f4c906b44f">getDataPointer</a> (uint32_t mipMapLevel=0, uint32_t arrayMember=0, uint32_t face=0) const</td></tr>
<tr class="memdesc:a76820857331fc851753b72f4c906b44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (const) pointer into the raw texture's data. Can be offset to a specific array member, face and/or MIP Map levels.  <a href="classpvr_1_1_texture.html#a76820857331fc851753b72f4c906b44f">More...</a><br /></td></tr>
<tr class="separator:a76820857331fc851753b72f4c906b44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb19f136932ee5150570dc9ec4d84e6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aebb19f136932ee5150570dc9ec4d84e6">getDataSize</a> (int32_t mipLevel=pvrTextureAllMipMaps, bool allSurfaces=true, bool allFaces=true) const</td></tr>
<tr class="memdesc:aebb19f136932ee5150570dc9ec4d84e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size in BYTES of the texture, given various input parameters.  <a href="structpvr_1_1_texture_header.html#aebb19f136932ee5150570dc9ec4d84e6">More...</a><br /></td></tr>
<tr class="separator:aebb19f136932ee5150570dc9ec4d84e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b67b3697ab065bc7ef7568bbf2acea"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a75b67b3697ab065bc7ef7568bbf2acea">getDepth</a> (uint32_t mipLevel=0) const</td></tr>
<tr class="memdesc:a75b67b3697ab065bc7ef7568bbf2acea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the depth of the user specified MIP-Map level for the texture.  <a href="structpvr_1_1_texture_header.html#a75b67b3697ab065bc7ef7568bbf2acea">More...</a><br /></td></tr>
<tr class="separator:a75b67b3697ab065bc7ef7568bbf2acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df2f585e7dbf0e196606b347ce963cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">ImageType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a9df2f585e7dbf0e196606b347ce963cf">getDimension</a> () const</td></tr>
<tr class="memdesc:a9df2f585e7dbf0e196606b347ce963cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base dimensioning type of the image (3D, 2D, 1D).  <a href="classpvr_1_1_texture.html#a9df2f585e7dbf0e196606b347ce963cf">More...</a><br /></td></tr>
<tr class="separator:a9df2f585e7dbf0e196606b347ce963cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616290360c63f6775b39f4fefedd6e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvr.html#abc7deef434e373b18abd3b929c31e9aa">Extent3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a616290360c63f6775b39f4fefedd6e60">getDimensions</a> (uint32_t miplevel=0) const</td></tr>
<tr class="memdesc:a616290360c63f6775b39f4fefedd6e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the texture's dimensions as a 3D extent (height, width, depth).  <a href="classpvr_1_1_texture.html#a616290360c63f6775b39f4fefedd6e60">More...</a><br /></td></tr>
<tr class="separator:a616290360c63f6775b39f4fefedd6e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cc254244c30faa7024c4efae995984"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ae4cc254244c30faa7024c4efae995984">getDirect3DFormat</a> (uint32_t &amp;outD3dFormat) const</td></tr>
<tr class="memdesc:ae4cc254244c30faa7024c4efae995984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Direct3D equivalent format enumeration for this texture.  <a href="structpvr_1_1_texture_header.html#ae4cc254244c30faa7024c4efae995984">More...</a><br /></td></tr>
<tr class="separator:ae4cc254244c30faa7024c4efae995984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebba0b50aeefcb70009fd8ac0b694856"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aebba0b50aeefcb70009fd8ac0b694856">getDirectXGIFormat</a> (uint32_t &amp;outDxgiFormat, bool &amp;notAlpha) const</td></tr>
<tr class="memdesc:aebba0b50aeefcb70009fd8ac0b694856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the DirectXGI equivalent format enumeration for this texture.  <a href="structpvr_1_1_texture_header.html#aebba0b50aeefcb70009fd8ac0b694856">More...</a><br /></td></tr>
<tr class="separator:aebba0b50aeefcb70009fd8ac0b694856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26b8b3f7b23855330e27a1a05421868"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aa26b8b3f7b23855330e27a1a05421868">getHeight</a> (uint32_t uiMipMapLevel=0) const</td></tr>
<tr class="memdesc:aa26b8b3f7b23855330e27a1a05421868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the height of the user specified MIP-Map level for the texture.  <a href="structpvr_1_1_texture_header.html#aa26b8b3f7b23855330e27a1a05421868">More...</a><br /></td></tr>
<tr class="separator:aa26b8b3f7b23855330e27a1a05421868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae486a18b866c3a1adf769e8fe124762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1_image_layers_size.html">ImageLayersSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#aae486a18b866c3a1adf769e8fe124762">getLayersSize</a> () const</td></tr>
<tr class="memdesc:aae486a18b866c3a1adf769e8fe124762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the texture's layer layout (miplevels, arraylevels). Faces are considered array levels, so a cube array has array x face array levels.  <a href="classpvr_1_1_texture.html#aae486a18b866c3a1adf769e8fe124762">More...</a><br /></td></tr>
<tr class="separator:aae486a18b866c3a1adf769e8fe124762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af241d4635a13a7a649cb30fb05ffacfa"><td class="memItemLeft" align="right" valign="top">const std::map&lt; uint32_t, std::map&lt; uint32_t, <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#af241d4635a13a7a649cb30fb05ffacfa">getMetaDataMap</a> () const</td></tr>
<tr class="memdesc:af241d4635a13a7a649cb30fb05ffacfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer directly to the Meta Data Map, to allow users to read out data.  <a href="structpvr_1_1_texture_header.html#af241d4635a13a7a649cb30fb05ffacfa">More...</a><br /></td></tr>
<tr class="separator:af241d4635a13a7a649cb30fb05ffacfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a4a2c67675ce215979a72b80a0dc68"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a42a4a2c67675ce215979a72b80a0dc68">getMetaDataSize</a> () const</td></tr>
<tr class="memdesc:a42a4a2c67675ce215979a72b80a0dc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total size of the meta data stored in the header. This includes the size of all information stored in all CPVRMetaDataBlocks.  <a href="structpvr_1_1_texture_header.html#a42a4a2c67675ce215979a72b80a0dc68">More...</a><br /></td></tr>
<tr class="separator:a42a4a2c67675ce215979a72b80a0dc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd034de9cff28da4b19fc7b3bf50420"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a5fd034de9cff28da4b19fc7b3bf50420">getMinDimensionsForFormat</a> (uint32_t &amp;minX, uint32_t &amp;minY, uint32_t &amp;minZ) const</td></tr>
<tr class="memdesc:a5fd034de9cff28da4b19fc7b3bf50420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum dimensions that the texture format of this header can be.  <a href="structpvr_1_1_texture_header.html#a5fd034de9cff28da4b19fc7b3bf50420">More...</a><br /></td></tr>
<tr class="separator:a5fd034de9cff28da4b19fc7b3bf50420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86df2b4bb4a776071fea200eed5df84a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a86df2b4bb4a776071fea200eed5df84a">getNumArrayMembers</a> () const</td></tr>
<tr class="memdesc:a86df2b4bb4a776071fea200eed5df84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of array members stored in this texture.  <a href="structpvr_1_1_texture_header.html#a86df2b4bb4a776071fea200eed5df84a">More...</a><br /></td></tr>
<tr class="separator:a86df2b4bb4a776071fea200eed5df84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d23d668b9e065612286ae7de868a690"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a8d23d668b9e065612286ae7de868a690">getNumFaces</a> () const</td></tr>
<tr class="memdesc:a8d23d668b9e065612286ae7de868a690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of faces stored in this texture.  <a href="structpvr_1_1_texture_header.html#a8d23d668b9e065612286ae7de868a690">More...</a><br /></td></tr>
<tr class="separator:a8d23d668b9e065612286ae7de868a690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6621f35f41ca5a11c2f5a3f50e459d82"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a6621f35f41ca5a11c2f5a3f50e459d82">getNumMipMapLevels</a> () const</td></tr>
<tr class="memdesc:a6621f35f41ca5a11c2f5a3f50e459d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of MIP-Map levels stored in this texture.  <a href="structpvr_1_1_texture_header.html#a6621f35f41ca5a11c2f5a3f50e459d82">More...</a><br /></td></tr>
<tr class="separator:a6621f35f41ca5a11c2f5a3f50e459d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c92a91b8166b06ee0d1ca949a727db2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_texture_meta_data.html#a5acad07c0f0cc281a017cb56e7a92f5a">TextureMetaData::AxisOrientation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a0c92a91b8166b06ee0d1ca949a727db2">getOrientation</a> (<a class="el" href="classpvr_1_1_texture_meta_data.html#ae6062237be958135b6d9cfc9fe0fb883">TextureMetaData::Axis</a> axis) const</td></tr>
<tr class="memdesc:a0c92a91b8166b06ee0d1ca949a727db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the data orientation for this texture.  <a href="structpvr_1_1_texture_header.html#a0c92a91b8166b06ee0d1ca949a727db2">More...</a><br /></td></tr>
<tr class="separator:a0c92a91b8166b06ee0d1ca949a727db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7396334bafe60274afa9ac751879ecf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a7396334bafe60274afa9ac751879ecf5">getPixelFormat</a> () const</td></tr>
<tr class="memdesc:a7396334bafe60274afa9ac751879ecf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pixel type ID of the texture.  <a href="structpvr_1_1_texture_header.html#a7396334bafe60274afa9ac751879ecf5">More...</a><br /></td></tr>
<tr class="separator:a7396334bafe60274afa9ac751879ecf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f9c1662ea35506822a33412deaf92c"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a88f9c1662ea35506822a33412deaf92c">getPixelPointer</a> (uint32_t x, uint32_t y, uint32_t z=0, uint32_t mipMapLevel=0, uint32_t arrayMember=0, uint32_t face=0)</td></tr>
<tr class="memdesc:a88f9c1662ea35506822a33412deaf92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer into the raw texture's data, offset to a specific pixel. Note that this does not work for compressed textures.  <a href="classpvr_1_1_texture.html#a88f9c1662ea35506822a33412deaf92c">More...</a><br /></td></tr>
<tr class="separator:a88f9c1662ea35506822a33412deaf92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7e020e0919fcc69c7b7da72cb20b74"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a4b7e020e0919fcc69c7b7da72cb20b74">getPixelPointerByUvw</a> (float u, float v, float w=0, uint32_t mipMapLevel=0, uint32_t arrayMember=0, <a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">CubeFace</a> face=(<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">CubeFace</a>) 0)</td></tr>
<tr class="memdesc:a4b7e020e0919fcc69c7b7da72cb20b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the data of the closest texel to the provided uvw coordinates (right/down texel returned if coordinate is on a boundary). Note that this does not work for compressed textures.  <a href="classpvr_1_1_texture.html#a4b7e020e0919fcc69c7b7da72cb20b74">More...</a><br /></td></tr>
<tr class="separator:a4b7e020e0919fcc69c7b7da72cb20b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c4a94741387fc0ba99d3f6c443c747"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#a29c4a94741387fc0ba99d3f6c443c747">getPixelSize</a> () const</td></tr>
<tr class="memdesc:a29c4a94741387fc0ba99d3f6c443c747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes size of each pixel in the texture. Not accurate for many compressed textures (e.g. ASTC)  <a href="classpvr_1_1_texture.html#a29c4a94741387fc0ba99d3f6c443c747">More...</a><br /></td></tr>
<tr class="separator:a29c4a94741387fc0ba99d3f6c443c747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1217da8d95ea75f85455c2e52a3cad5f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a1217da8d95ea75f85455c2e52a3cad5f">getTextureSize</a> (int32_t mipMapLevel=pvrTextureAllMipMaps, bool allSurfaces=true, bool allFaces=true) const</td></tr>
<tr class="memdesc:a1217da8d95ea75f85455c2e52a3cad5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size in PIXELS of the texture, given various input parameters.  <a href="structpvr_1_1_texture_header.html#a1217da8d95ea75f85455c2e52a3cad5f">More...</a><br /></td></tr>
<tr class="separator:a1217da8d95ea75f85455c2e52a3cad5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2067e9d92450ab108cd952caa89da3bd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a2067e9d92450ab108cd952caa89da3bd">getWidth</a> (uint32_t uiMipMapLevel=0) const</td></tr>
<tr class="memdesc:a2067e9d92450ab108cd952caa89da3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the width of the user specified MIP-Map level for the texture.  <a href="structpvr_1_1_texture_header.html#a2067e9d92450ab108cd952caa89da3bd">More...</a><br /></td></tr>
<tr class="separator:a2067e9d92450ab108cd952caa89da3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bda057c26fb767772415ed46c49998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_texture.html#ac5bda057c26fb767772415ed46c49998">initializeWithHeader</a> (const <a class="el" href="structpvr_1_1_texture_header.html">TextureHeader</a> &amp;sHeader)</td></tr>
<tr class="memdesc:ac5bda057c26fb767772415ed46c49998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture using the information from a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> header and preallocate memory for its data. /summary&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sHeader</td><td>A texture header describing the texture</td></tr>
  </table>
  </dd>
</dl>
 <a href="classpvr_1_1_texture.html#ac5bda057c26fb767772415ed46c49998">More...</a><br /></td></tr>
<tr class="separator:ac5bda057c26fb767772415ed46c49998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64689d36069d0500968559a4e408a22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ad64689d36069d0500968559a4e408a22">isBumpMap</a> () const</td></tr>
<tr class="memdesc:ad64689d36069d0500968559a4e408a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this texture is bumpmap  <a href="structpvr_1_1_texture_header.html#ad64689d36069d0500968559a4e408a22">More...</a><br /></td></tr>
<tr class="separator:ad64689d36069d0500968559a4e408a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43ed55d9cdaba12ee0038bc3d48eb92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#af43ed55d9cdaba12ee0038bc3d48eb92">isFileCompressed</a> () const</td></tr>
<tr class="memdesc:af43ed55d9cdaba12ee0038bc3d48eb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression.  <a href="structpvr_1_1_texture_header.html#af43ed55d9cdaba12ee0038bc3d48eb92">More...</a><br /></td></tr>
<tr class="separator:af43ed55d9cdaba12ee0038bc3d48eb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b81566bc53a770ecd67cada7bee7da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ab6b81566bc53a770ecd67cada7bee7da">isPreMultiplied</a> () const</td></tr>
<tr class="memdesc:ab6b81566bc53a770ecd67cada7bee7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether or not the texture's color has been pre-multiplied by the alpha values.  <a href="structpvr_1_1_texture_header.html#ab6b81566bc53a770ecd67cada7bee7da">More...</a><br /></td></tr>
<tr class="separator:ab6b81566bc53a770ecd67cada7bee7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a015fac0ee35f2dbb69e079487309a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a28a015fac0ee35f2dbb69e079487309a">setBumpMap</a> (float bumpScale, std::string bumpOrder)</td></tr>
<tr class="memdesc:a28a015fac0ee35f2dbb69e079487309a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture's bump map data.  <a href="structpvr_1_1_texture_header.html#a28a015fac0ee35f2dbb69e079487309a">More...</a><br /></td></tr>
<tr class="separator:a28a015fac0ee35f2dbb69e079487309a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09da345ffb95b209ae9d515d342491cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a09da345ffb95b209ae9d515d342491cc">setChannelType</a> (<a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> newChannelType)</td></tr>
<tr class="memdesc:a09da345ffb95b209ae9d515d342491cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the channel type of this texture.  <a href="structpvr_1_1_texture_header.html#a09da345ffb95b209ae9d515d342491cc">More...</a><br /></td></tr>
<tr class="separator:a09da345ffb95b209ae9d515d342491cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe2fea504cd8ef590df356d61bcc215"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#acfe2fea504cd8ef590df356d61bcc215">setColorSpace</a> (<a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a> newColorSpace)</td></tr>
<tr class="memdesc:acfe2fea504cd8ef590df356d61bcc215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color space for this texture. Default is lRGB.  <a href="structpvr_1_1_texture_header.html#acfe2fea504cd8ef590df356d61bcc215">More...</a><br /></td></tr>
<tr class="separator:acfe2fea504cd8ef590df356d61bcc215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae0add42744eb80a320819c7a30ceba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a6ae0add42744eb80a320819c7a30ceba">setCubeMapOrder</a> (std::string cubeMapOrder)</td></tr>
<tr class="memdesc:a6ae0add42744eb80a320819c7a30ceba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a texture's bump map data.  <a href="structpvr_1_1_texture_header.html#a6ae0add42744eb80a320819c7a30ceba">More...</a><br /></td></tr>
<tr class="separator:a6ae0add42744eb80a320819c7a30ceba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7469359ed22b4c6bb41495d2fa2f4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a2b7469359ed22b4c6bb41495d2fa2f4e">setDepth</a> (uint32_t newDepth)</td></tr>
<tr class="memdesc:a2b7469359ed22b4c6bb41495d2fa2f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture depth.  <a href="structpvr_1_1_texture_header.html#a2b7469359ed22b4c6bb41495d2fa2f4e">More...</a><br /></td></tr>
<tr class="separator:a2b7469359ed22b4c6bb41495d2fa2f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa1c1b7885a83633003f9bc88d5b218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a2fa1c1b7885a83633003f9bc88d5b218">setHeight</a> (uint32_t newHeight)</td></tr>
<tr class="memdesc:a2fa1c1b7885a83633003f9bc88d5b218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture height.  <a href="structpvr_1_1_texture_header.html#a2fa1c1b7885a83633003f9bc88d5b218">More...</a><br /></td></tr>
<tr class="separator:a2fa1c1b7885a83633003f9bc88d5b218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cee1199768def6a9748792eb5b0ccc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a2cee1199768def6a9748792eb5b0ccc3">setIsFileCompressed</a> (bool <a class="el" href="structpvr_1_1_texture_header.html#af43ed55d9cdaba12ee0038bc3d48eb92">isFileCompressed</a>)</td></tr>
<tr class="memdesc:a2cee1199768def6a9748792eb5b0ccc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression. Currently unsupported.  <a href="structpvr_1_1_texture_header.html#a2cee1199768def6a9748792eb5b0ccc3">More...</a><br /></td></tr>
<tr class="separator:a2cee1199768def6a9748792eb5b0ccc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edb013521dccb80f92759ab1c45f61b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a3edb013521dccb80f92759ab1c45f61b">setIsPreMultiplied</a> (bool <a class="el" href="structpvr_1_1_texture_header.html#ab6b81566bc53a770ecd67cada7bee7da">isPreMultiplied</a>)</td></tr>
<tr class="memdesc:a3edb013521dccb80f92759ab1c45f61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the texture's color has been pre-multiplied by the alpha values.  <a href="structpvr_1_1_texture_header.html#a3edb013521dccb80f92759ab1c45f61b">More...</a><br /></td></tr>
<tr class="separator:a3edb013521dccb80f92759ab1c45f61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746d4244f009e9e13318710b5842fe9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a746d4244f009e9e13318710b5842fe9a">setNumArrayMembers</a> (uint32_t numNewMembers)</td></tr>
<tr class="memdesc:a746d4244f009e9e13318710b5842fe9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of arrays in this texture  <a href="structpvr_1_1_texture_header.html#a746d4244f009e9e13318710b5842fe9a">More...</a><br /></td></tr>
<tr class="separator:a746d4244f009e9e13318710b5842fe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9525ab8947e88b614c6e81b575d5c3c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a9525ab8947e88b614c6e81b575d5c3c9">setNumFaces</a> (uint32_t numNewFaces)</td></tr>
<tr class="memdesc:a9525ab8947e88b614c6e81b575d5c3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of faces stored in this texture.  <a href="structpvr_1_1_texture_header.html#a9525ab8947e88b614c6e81b575d5c3c9">More...</a><br /></td></tr>
<tr class="separator:a9525ab8947e88b614c6e81b575d5c3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6fe8d132b26659e9072282dd037054"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a0c6fe8d132b26659e9072282dd037054">setNumMipMapLevels</a> (uint32_t numNewMipMapLevels)</td></tr>
<tr class="memdesc:a0c6fe8d132b26659e9072282dd037054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of MIP-Map levels in this texture.  <a href="structpvr_1_1_texture_header.html#a0c6fe8d132b26659e9072282dd037054">More...</a><br /></td></tr>
<tr class="separator:a0c6fe8d132b26659e9072282dd037054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafee0c616f4217ebc193b0a4082a72f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aaafee0c616f4217ebc193b0a4082a72f">setOrientation</a> (<a class="el" href="classpvr_1_1_texture_meta_data.html#a5acad07c0f0cc281a017cb56e7a92f5a">TextureMetaData::AxisOrientation</a> axisOrientation)</td></tr>
<tr class="memdesc:aaafee0c616f4217ebc193b0a4082a72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the data orientation for a given axis in this texture.  <a href="structpvr_1_1_texture_header.html#aaafee0c616f4217ebc193b0a4082a72f">More...</a><br /></td></tr>
<tr class="separator:aaafee0c616f4217ebc193b0a4082a72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac843ef8bfde1ea52d0aad891807c4ea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ac843ef8bfde1ea52d0aad891807c4ea2">setPixelFormat</a> (<a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a> uPixelFormat)</td></tr>
<tr class="memdesc:ac843ef8bfde1ea52d0aad891807c4ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pixel format for this texture.  <a href="structpvr_1_1_texture_header.html#ac843ef8bfde1ea52d0aad891807c4ea2">More...</a><br /></td></tr>
<tr class="separator:ac843ef8bfde1ea52d0aad891807c4ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b546b020e47df211588a983cc9872e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a4b546b020e47df211588a983cc9872e7">setWidth</a> (uint32_t newWidth)</td></tr>
<tr class="memdesc:a4b546b020e47df211588a983cc9872e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture width.  <a href="structpvr_1_1_texture_header.html#a4b546b020e47df211588a983cc9872e7">More...</a><br /></td></tr>
<tr class="separator:a4b546b020e47df211588a983cc9872e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a610b01b773fc32dd8b829e9dee05b0e2"><td class="memItemLeft" align="right" valign="top"><a id="a610b01b773fc32dd8b829e9dee05b0e2"></a>
std::map&lt; uint32_t, std::map&lt; uint32_t, <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a610b01b773fc32dd8b829e9dee05b0e2">_metaDataMap</a></td></tr>
<tr class="memdesc:a610b01b773fc32dd8b829e9dee05b0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of all the meta data stored for a texture. <br /></td></tr>
<tr class="separator:a610b01b773fc32dd8b829e9dee05b0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc964624a1c060d774ccf2419882e68"><td class="memItemLeft" align="right" valign="top"><a id="a6dc964624a1c060d774ccf2419882e68"></a>
<a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a6dc964624a1c060d774ccf2419882e68">channelType</a></td></tr>
<tr class="memdesc:a6dc964624a1c060d774ccf2419882e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable type that the channel is stored in. Supports signed/unsigned int/short/char/float. <br /></td></tr>
<tr class="separator:a6dc964624a1c060d774ccf2419882e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8c205bfe7a99cc479e2e8eeb3ac082"><td class="memItemLeft" align="right" valign="top"><a id="aae8c205bfe7a99cc479e2e8eeb3ac082"></a>
<a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aae8c205bfe7a99cc479e2e8eeb3ac082">colorSpace</a></td></tr>
<tr class="memdesc:aae8c205bfe7a99cc479e2e8eeb3ac082"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Color Space of the texture, currently either linear RGB or sRGB. <br /></td></tr>
<tr class="separator:aae8c205bfe7a99cc479e2e8eeb3ac082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c45b53efb7db69ab1c782c3441a323"><td class="memItemLeft" align="right" valign="top"><a id="a62c45b53efb7db69ab1c782c3441a323"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a62c45b53efb7db69ab1c782c3441a323">depth</a></td></tr>
<tr class="memdesc:a62c45b53efb7db69ab1c782c3441a323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth of the texture. (Z-slices) <br /></td></tr>
<tr class="separator:a62c45b53efb7db69ab1c782c3441a323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9621fca15af7e7abd7a4c0839b1f6d72"><td class="memItemLeft" align="right" valign="top"><a id="a9621fca15af7e7abd7a4c0839b1f6d72"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a9621fca15af7e7abd7a4c0839b1f6d72">flags</a></td></tr>
<tr class="memdesc:a9621fca15af7e7abd7a4c0839b1f6d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various format flags. <br /></td></tr>
<tr class="separator:a9621fca15af7e7abd7a4c0839b1f6d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2860b2e50a2ddc9b05769b7178b54858"><td class="memItemLeft" align="right" valign="top"><a id="a2860b2e50a2ddc9b05769b7178b54858"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a2860b2e50a2ddc9b05769b7178b54858">height</a></td></tr>
<tr class="memdesc:a2860b2e50a2ddc9b05769b7178b54858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Height of the texture. <br /></td></tr>
<tr class="separator:a2860b2e50a2ddc9b05769b7178b54858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4488946b871a1bf11f465b10923779c1"><td class="memItemLeft" align="right" valign="top"><a id="a4488946b871a1bf11f465b10923779c1"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a4488946b871a1bf11f465b10923779c1">metaDataSize</a></td></tr>
<tr class="memdesc:a4488946b871a1bf11f465b10923779c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the accompanying meta data. <br /></td></tr>
<tr class="separator:a4488946b871a1bf11f465b10923779c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73034dd746eae6a6b97964196bb35f6"><td class="memItemLeft" align="right" valign="top"><a id="ae73034dd746eae6a6b97964196bb35f6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#ae73034dd746eae6a6b97964196bb35f6">numFaces</a></td></tr>
<tr class="memdesc:ae73034dd746eae6a6b97964196bb35f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of faces in a Cube Map. Maybe be a value other than 6. <br /></td></tr>
<tr class="separator:ae73034dd746eae6a6b97964196bb35f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9708c183c5836408d74d5b341846594"><td class="memItemLeft" align="right" valign="top"><a id="aa9708c183c5836408d74d5b341846594"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#aa9708c183c5836408d74d5b341846594">numMipMaps</a></td></tr>
<tr class="memdesc:aa9708c183c5836408d74d5b341846594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of MIP Maps in the texture - NB: Includes top level. <br /></td></tr>
<tr class="separator:aa9708c183c5836408d74d5b341846594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e90b5846cddef394f1f0e313d8a8a8"><td class="memItemLeft" align="right" valign="top"><a id="a04e90b5846cddef394f1f0e313d8a8a8"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a04e90b5846cddef394f1f0e313d8a8a8">numSurfaces</a></td></tr>
<tr class="memdesc:a04e90b5846cddef394f1f0e313d8a8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of members in a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> Array. <br /></td></tr>
<tr class="separator:a04e90b5846cddef394f1f0e313d8a8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4edd7302ab785ff47b46dd4f46170f"><td class="memItemLeft" align="right" valign="top"><a id="a0c4edd7302ab785ff47b46dd4f46170f"></a>
<a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a0c4edd7302ab785ff47b46dd4f46170f">pixelFormat</a></td></tr>
<tr class="memdesc:a0c4edd7302ab785ff47b46dd4f46170f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pixel format, 8cc value storing the 4 channel identifiers and their respective sizes. <br /></td></tr>
<tr class="separator:a0c4edd7302ab785ff47b46dd4f46170f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c32d51bbf9386f82c017c1b867ac362"><td class="memItemLeft" align="right" valign="top"><a id="a0c32d51bbf9386f82c017c1b867ac362"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1_texture_header.html#a0c32d51bbf9386f82c017c1b867ac362">width</a></td></tr>
<tr class="memdesc:a0c32d51bbf9386f82c017c1b867ac362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of the texture. <br /></td></tr>
<tr class="separator:a0c32d51bbf9386f82c017c1b867ac362"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A 2D <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> asset, together with Information, Metadata and actual Pixel data. Only represents the actual data, not the API objects that may be created from it. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa575a1cac05e7c71cc544ff4469264a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa575a1cac05e7c71cc544ff4469264a4">&#9670;&nbsp;</a></span>Constants</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structpvr_1_1_texture_header.html#aa575a1cac05e7c71cc544ff4469264a4">pvr::TextureHeader::Constants</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This header stores everything that you would ever need to load (but not necessarily use) a texture's data accurately, but no more. Data that is provided but is not needed to read the data is stored in the Metadata section (See TextureHeaderWithMetadata). Correct use of the texture may rely on meta data, but accurate data loading can be done through the standard header alone. </p>
<p>&lt; Contains constants used by the header </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa575a1cac05e7c71cc544ff4469264a4a167572588891304475e448c9a44d0a46"></a>PVRv3&#160;</td><td class="fielddoc"><p>PVR format v3 identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa575a1cac05e7c71cc544ff4469264a4ae2cd40f7ccea4ca3ef7c46970ab43af6"></a>PVRv3Reversed&#160;</td><td class="fielddoc"><p>PVR format v3 reversed identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa575a1cac05e7c71cc544ff4469264a4a43bea9e5650f87f5b16b074cbe26f622"></a>CompressedFlag&#160;</td><td class="fielddoc"><p>Compressed format flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa575a1cac05e7c71cc544ff4469264a4a9253d5725cfe9a48d00e6eb0c9651e29"></a>PremultipliedFlag&#160;</td><td class="fielddoc"><p>Premultiplied flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa575a1cac05e7c71cc544ff4469264a4a656632f4d3e87051deca7655ead0f65b"></a>SizeOfHeader&#160;</td><td class="fielddoc"><p>The total size of the header in bytes. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1d4ae5b8b2c94ca4cc26d84350c0073d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4ae5b8b2c94ca4cc26d84350c0073d">&#9670;&nbsp;</a></span>Texture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::Texture::Texture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new empty texture. </p>

</div>
</div>
<a id="a61e5e89a98b484b2c09757f6b9f967f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e5e89a98b484b2c09757f6b9f967f0">&#9670;&nbsp;</a></span>Texture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::Texture::Texture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1_texture_header.html">TextureHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>sHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pData</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a texture using the information from a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> header and copy the actual data from a provided pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sHeader</td><td>A texture header describing the texture</td></tr>
    <tr><td class="paramname">pData</td><td>Pointer to memory containing the actual data.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a new texture based on a texture header, pre-allocating the correct amount of memory. If data is supplied, it will be copied into memory. If the pointer contains less data than is dictated by the texture header, the behaviour is undefined.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a15c81430182569becd27c48dc12e9f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c81430182569becd27c48dc12e9f36">&#9670;&nbsp;</a></span>addMetaData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::addMetaData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>metaData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an arbitrary piece of meta data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metaData</td><td>Meta data block to be added.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eba5d93f2335cdb4085ad88b8e3a5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eba5d93f2335cdb4085ad88b8e3a5cf">&#9670;&nbsp;</a></span>addPaddingMetaData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::Texture::addPaddingMetaData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function pads to a boundary value equal to "uiPadding". For example, setting alignment=8 will align the start of the texture data to an 8 char boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alignment</td><td>The final alignment of the metadata</td></tr>
  </table>
  </dd>
</dl>
<p>When writing the texture out to a PVR file, it is often desirable to pad the meta data so that the start of the texture data aligns to a given boundary. Note - this should be called immediately before saving (in any case, before adding any metadata) as the value is worked out based on the current meta data size. /remarks&gt; </p>

</div>
</div>
<a id="a6464f127a35d2e4f275d6db3a8ff8d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6464f127a35d2e4f275d6db3a8ff8d81">&#9670;&nbsp;</a></span>getBitsPerPixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getBitsPerPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the bits per pixel of the texture format. </p>
<dl class="section return"><dt>Returns</dt><dd>Return number of bits per pixel</dd></dl>

</div>
</div>
<a id="a274e7f9171bdb833117b3f13cb55325a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274e7f9171bdb833117b3f13cb55325a">&#9670;&nbsp;</a></span>getChannelType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a> pvr::TextureHeader::getChannelType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the channel type that the texture's data is stored in. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the enum representing the type of the texture.</dd></dl>

</div>
</div>
<a id="a9252454143fb760f259b844e7df6e476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9252454143fb760f259b844e7df6e476">&#9670;&nbsp;</a></span>getColorSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a> pvr::TextureHeader::getColorSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the color space of the texture. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the ColorSpace enum representing color space.</dd></dl>

</div>
</div>
<a id="ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c74ab2b6bdc8cfa8a55cabc4b1f1b1">&#9670;&nbsp;</a></span>getCubeMapOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string pvr::TextureHeader::getCubeMapOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the cube map face order. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns cube map order.</dd></dl>
<p>Returned std::string will be in the form "ZzXxYy" with capitals representing positive and small letters representing negative. I.e. Z=Z-Positive, z=Z-Negative.</p>

</div>
</div>
<a id="a21098a02ff1c57c9c1830a953c47df20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21098a02ff1c57c9c1830a953c47df20">&#9670;&nbsp;</a></span>getCubemapPixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* pvr::Texture::getCubemapPixel </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayMember</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to the data for the direction (x,y,z) provided for the specific mip map level and array layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x component of the direction</td></tr>
    <tr><td class="paramname">y</td><td>The y component of the direction</td></tr>
    <tr><td class="paramname">z</td><td>The z component of the direction</td></tr>
    <tr><td class="paramname">mipMapLevel</td><td>The mip map level for which to get the data pointer (default 0)</td></tr>
    <tr><td class="paramname">arrayMember</td><td>The array member for which to get the data pointer (default 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to the data for the direction specified.</dd></dl>

</div>
</div>
<a id="ac857e69832c7f453963d00d125b2914c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac857e69832c7f453963d00d125b2914c">&#9670;&nbsp;</a></span>getDataOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ptrdiff_t pvr::TextureHeader::getDataOffset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayMember</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>face</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a offset in the data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipMapLevel</td><td>The mip map level of the offset</td></tr>
    <tr><td class="paramname">arrayMember</td><td>The array index of the offset</td></tr>
    <tr><td class="paramname">face</td><td>The face of the offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return data offset</dd></dl>

</div>
</div>
<a id="a45c3d7c47fe8507e1730a27039ba8b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c3d7c47fe8507e1730a27039ba8b6d">&#9670;&nbsp;</a></span>getDataPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* pvr::Texture::getDataPointer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayMember</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>face</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer into the raw texture's data. Can be offset to a specific array member, face and/or MIP Map levels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipMapLevel</td><td>The mip map level for which to get the data pointer (default 0)</td></tr>
    <tr><td class="paramname">arrayMember</td><td>The array member for which to get the data pointer (default 0)</td></tr>
    <tr><td class="paramname">face</td><td>The face for which to get the data pointer (default 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to a location in the texture.</dd></dl>
<p>The data is contiguous so that the entire texture (all mips, array members and faces) can always be accessed from any pointer.</p>

</div>
</div>
<a id="a76820857331fc851753b72f4c906b44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76820857331fc851753b72f4c906b44f">&#9670;&nbsp;</a></span>getDataPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char* pvr::Texture::getDataPointer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayMember</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>face</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a (const) pointer into the raw texture's data. Can be offset to a specific array member, face and/or MIP Map levels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipMapLevel</td><td>The mip map level to get a pointer to (default 0)</td></tr>
    <tr><td class="paramname">arrayMember</td><td>The array member to get a pointer to (default 0)</td></tr>
    <tr><td class="paramname">face</td><td>The cube face to get a pointer to (default 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const raw pointer to a location in the texture.</dd></dl>
<p>The data is contiguous so that the entire texture (all mips, array members and faces) can always be accessed from any pointer.</p>

</div>
</div>
<a id="aebb19f136932ee5150570dc9ec4d84e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb19f136932ee5150570dc9ec4d84e6">&#9670;&nbsp;</a></span>getDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getDataSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>mipLevel</em> = <code>pvrTextureAllMipMaps</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allSurfaces</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allFaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size in BYTES of the texture, given various input parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipLevel</td><td>Specifies a mip level to check, 'c_pvrTextureAllMIPMapLevels' can be passed to Get the size of all MIP levels.</td></tr>
    <tr><td class="paramname">allSurfaces</td><td>The Size of all surfaces is calculated if true, only a single surface if false. /param&gt; <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allFaces</td><td>The Size of all faces is calculated if true, only a single face if false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the size in BYTES of the specified texture area.</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>User can retrieve the size of either all surfaces or a single surface, all faces or a single face and all MIP-Maps or a single specified MIP level.</p>

</div>
</div>
<a id="a75b67b3697ab065bc7ef7568bbf2acea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b67b3697ab065bc7ef7568bbf2acea">&#9670;&nbsp;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getDepth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipLevel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the depth of the user specified MIP-Map level for the texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipLevel</td><td>MIP level that user is interested in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the depth of the specified MIP-Map level.</dd></dl>

</div>
</div>
<a id="a9df2f585e7dbf0e196606b347ce963cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df2f585e7dbf0e196606b347ce963cf">&#9670;&nbsp;</a></span>getDimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#ab98ea90165357c2f9030218c337f90bf">ImageType</a> pvr::Texture::getDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base dimensioning type of the image (3D, 2D, 1D). </p>
<dl class="section return"><dt>Returns</dt><dd>The base dimensioning type of the image (3D, 2D, 1D).</dd></dl>

</div>
</div>
<a id="a616290360c63f6775b39f4fefedd6e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616290360c63f6775b39f4fefedd6e60">&#9670;&nbsp;</a></span>getDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvr.html#abc7deef434e373b18abd3b929c31e9aa">Extent3D</a> pvr::Texture::getDimensions </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>miplevel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the texture's dimensions as a 3D extent (height, width, depth). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">miplevel</td><td>(Default 0) The mip level for which to get the dimensions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the texture's dimensions as a 3D extent (height, width, depth)</dd></dl>

</div>
</div>
<a id="ae4cc254244c30faa7024c4efae995984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cc254244c30faa7024c4efae995984">&#9670;&nbsp;</a></span>getDirect3DFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::TextureHeader::getDirect3DFormat </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>outD3dFormat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the Direct3D equivalent format enumeration for this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outD3dFormat</td><td>Returned d3d format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, returns false if it cannot find a suitable type</dd></dl>

</div>
</div>
<a id="aebba0b50aeefcb70009fd8ac0b694856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebba0b50aeefcb70009fd8ac0b694856">&#9670;&nbsp;</a></span>getDirectXGIFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::TextureHeader::getDirectXGIFormat </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>outDxgiFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>notAlpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the DirectXGI equivalent format enumeration for this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notAlpha</td><td>Return whether the <em>outDxgiFormat</em> is has alpha or not.</td></tr>
    <tr><td class="paramname">outDxgiFormat</td><td>Returned dxgi format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, returns false if it cannot find a suitable type</dd></dl>

</div>
</div>
<a id="aa26b8b3f7b23855330e27a1a05421868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26b8b3f7b23855330e27a1a05421868">&#9670;&nbsp;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getHeight </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uiMipMapLevel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the height of the user specified MIP-Map level for the texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiMipMapLevel</td><td>MIP level that user is interested in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the Height of the specified MIP-Map level.</dd></dl>

</div>
</div>
<a id="aae486a18b866c3a1adf769e8fe124762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae486a18b866c3a1adf769e8fe124762">&#9670;&nbsp;</a></span>getLayersSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1_image_layers_size.html">ImageLayersSize</a> pvr::Texture::getLayersSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the texture's layer layout (miplevels, arraylevels). Faces are considered array levels, so a cube array has array x face array levels. </p>
<dl class="section return"><dt>Returns</dt><dd>The texture's layer layout (miplevels, arraylevels)</dd></dl>

</div>
</div>
<a id="af241d4635a13a7a649cb30fb05ffacfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af241d4635a13a7a649cb30fb05ffacfa">&#9670;&nbsp;</a></span>getMetaDataMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;uint32_t, std::map&lt;uint32_t, <a class="el" href="classpvr_1_1_texture_meta_data.html">TextureMetaData</a>&gt; &gt;* pvr::TextureHeader::getMetaDataMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer directly to the Meta Data Map, to allow users to read out data. </p>
<dl class="section return"><dt>Returns</dt><dd>Return a direct pointer to the MetaData map.</dd></dl>

</div>
</div>
<a id="a42a4a2c67675ce215979a72b80a0dc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a4a2c67675ce215979a72b80a0dc68">&#9670;&nbsp;</a></span>getMetaDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getMetaDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total size of the meta data stored in the header. This includes the size of all information stored in all CPVRMetaDataBlocks. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the size, in bytes, of the meta data stored in the header.</dd></dl>

</div>
</div>
<a id="a5fd034de9cff28da4b19fc7b3bf50420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd034de9cff28da4b19fc7b3bf50420">&#9670;&nbsp;</a></span>getMinDimensionsForFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::getMinDimensionsForFormat </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>minX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>minY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>minZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum dimensions that the texture format of this header can be. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minX</td><td>Minimum width of the texture format.</td></tr>
    <tr><td class="paramname">minY</td><td>Minimum height of the texture format.</td></tr>
    <tr><td class="paramname">minZ</td><td>Minimum depth of the texture format.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86df2b4bb4a776071fea200eed5df84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86df2b4bb4a776071fea200eed5df84a">&#9670;&nbsp;</a></span>getNumArrayMembers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getNumArrayMembers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of array members stored in this texture. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the number of array members in this texture.</dd></dl>

</div>
</div>
<a id="a8d23d668b9e065612286ae7de868a690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d23d668b9e065612286ae7de868a690">&#9670;&nbsp;</a></span>getNumFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getNumFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of faces stored in this texture. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the number of faces in this texture.</dd></dl>

</div>
</div>
<a id="a6621f35f41ca5a11c2f5a3f50e459d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6621f35f41ca5a11c2f5a3f50e459d82">&#9670;&nbsp;</a></span>getNumMipMapLevels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getNumMipMapLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of MIP-Map levels stored in this texture. </p>
<dl class="section return"><dt>Returns</dt><dd>Return the number of MIP-Map levels in this texture.</dd></dl>

</div>
</div>
<a id="a0c92a91b8166b06ee0d1ca949a727db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c92a91b8166b06ee0d1ca949a727db2">&#9670;&nbsp;</a></span>getOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_texture_meta_data.html#a5acad07c0f0cc281a017cb56e7a92f5a">TextureMetaData::AxisOrientation</a> pvr::TextureHeader::getOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_texture_meta_data.html#ae6062237be958135b6d9cfc9fe0fb883">TextureMetaData::Axis</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the data orientation for this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>The axis to examine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the orientation of the axis.</dd></dl>

</div>
</div>
<a id="a7396334bafe60274afa9ac751879ecf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7396334bafe60274afa9ac751879ecf5">&#9670;&nbsp;</a></span>getPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a> pvr::TextureHeader::getPixelFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pixel type ID of the texture. </p>
<dl class="section return"><dt>Returns</dt><dd>Return a 64-bit pixel type ID.</dd></dl>

</div>
</div>
<a id="a88f9c1662ea35506822a33412deaf92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f9c1662ea35506822a33412deaf92c">&#9670;&nbsp;</a></span>getPixelPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* pvr::Texture::getPixelPointer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>z</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayMember</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>face</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer into the raw texture's data, offset to a specific pixel. Note that this does not work for compressed textures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x position of the pointer</td></tr>
    <tr><td class="paramname">y</td><td>The y position of the pointer</td></tr>
    <tr><td class="paramname">z</td><td>The z position of the pointer (default 0)</td></tr>
    <tr><td class="paramname">mipMapLevel</td><td>The mip map level for which to get the data pointer (default 0)</td></tr>
    <tr><td class="paramname">arrayMember</td><td>The array member for which to get the data pointer (default 0)</td></tr>
    <tr><td class="paramname">face</td><td>The face for which to get the data pointer (default 0). The number is equal to the value of the corresponding CubeFace enum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to a location in the texture.</dd></dl>
<p>The data is contiguous so that the entire texture (all mips, array members and faces) can always be accessed from any pointer. Equivalent to getDataPointer(mipMapLevel, arrayMember, faceNumber) + [char offset of pixel (x,y,z)]</p>

</div>
</div>
<a id="a4b7e020e0919fcc69c7b7da72cb20b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7e020e0919fcc69c7b7da72cb20b74">&#9670;&nbsp;</a></span>getPixelPointerByUvw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* pvr::Texture::getPixelPointerByUvw </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>arrayMember</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">CubeFace</a>&#160;</td>
          <td class="paramname"><em>face</em> = <code>(<a class="el" href="namespacepvr.html#a87b409df225dee78541eb74988f4e20c">CubeFace</a>)0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pointer to the data of the closest texel to the provided uvw coordinates (right/down texel returned if coordinate is on a boundary). Note that this does not work for compressed textures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The u position [0..1] of the pointer. Clamped to [0..1]</td></tr>
    <tr><td class="paramname">v</td><td>The v position [0..1] of the pointer. Clamped to [0..1]</td></tr>
    <tr><td class="paramname">w</td><td>Thew position [0..1] of the pointer (default 0). Clamped to [0..1]</td></tr>
    <tr><td class="paramname">mipMapLevel</td><td>The mip map level for which to get the data pointer (default 0)</td></tr>
    <tr><td class="paramname">arrayMember</td><td>The array member for which to get the data pointer (default 0)</td></tr>
    <tr><td class="paramname">face</td><td>The face for which to get the data pointer (default 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to a location in the texture.</dd></dl>
<p>The data is contiguous so that the entire texture (all mips, array members and faces) can always be accessed from any pointer.</p>

</div>
</div>
<a id="a29c4a94741387fc0ba99d3f6c443c747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c4a94741387fc0ba99d3f6c443c747">&#9670;&nbsp;</a></span>getPixelSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t pvr::Texture::getPixelSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of bytes size of each pixel in the texture. Not accurate for many compressed textures (e.g. ASTC) </p>
<dl class="section return"><dt>Returns</dt><dd>he number of bytes size of each pixel in the texture. May return zero for some compressed formats. /returns&gt; </dd></dl>

</div>
</div>
<a id="a1217da8d95ea75f85455c2e52a3cad5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1217da8d95ea75f85455c2e52a3cad5f">&#9670;&nbsp;</a></span>getTextureSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getTextureSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>mipMapLevel</em> = <code>pvrTextureAllMipMaps</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allSurfaces</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allFaces</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size in PIXELS of the texture, given various input parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mipMapLevel</td><td>Specifies a MIP level to check, 'c_pvrTextureAllMIPMapLevels' can be passed to Get the size of all MIP levels.</td></tr>
    <tr><td class="paramname">allSurfaces</td><td>The Size of all surfaces is calculated if true, only a single surface if false. /param&gt; <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allFaces</td><td>The Size of all faces is calculated if true, only a single face if false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the size in PIXELS of the specified texture area.</dd></dl>
</td></tr>
  </table>
  </dd>
</dl>
<p>User can retrieve the total size of either all surfaces or a single surface, all faces or a single face and all MIP-Maps or a single specified MIP level. All of these</p>

</div>
</div>
<a id="a2067e9d92450ab108cd952caa89da3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2067e9d92450ab108cd952caa89da3bd">&#9670;&nbsp;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pvr::TextureHeader::getWidth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uiMipMapLevel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the width of the user specified MIP-Map level for the texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uiMipMapLevel</td><td>MIP level that user is interested in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the width of the specified MIP-Map level.</dd></dl>

</div>
</div>
<a id="ac5bda057c26fb767772415ed46c49998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5bda057c26fb767772415ed46c49998">&#9670;&nbsp;</a></span>initializeWithHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::Texture::initializeWithHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvr_1_1_texture_header.html">TextureHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>sHeader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a texture using the information from a <a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a> header and preallocate memory for its data. /summary&gt; </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sHeader</td><td>A texture header describing the texture</td></tr>
  </table>
  </dd>
</dl>
</p>
<p>Creates a new texture based on a texture header, pre-allocating the correct amount of memory.</p>

</div>
</div>
<a id="ad64689d36069d0500968559a4e408a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64689d36069d0500968559a4e408a22">&#9670;&nbsp;</a></span>isBumpMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::TextureHeader::isBumpMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this texture is bumpmap </p>
<dl class="section return"><dt>Returns</dt><dd>Return true if the texture is bumpmap</dd></dl>

</div>
</div>
<a id="af43ed55d9cdaba12ee0038bc3d48eb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43ed55d9cdaba12ee0038bc3d48eb92">&#9670;&nbsp;</a></span>isFileCompressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::TextureHeader::isFileCompressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression. </p>
<dl class="section return"><dt>Returns</dt><dd>Return true if it is file compressed.</dd></dl>

</div>
</div>
<a id="ab6b81566bc53a770ecd67cada7bee7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b81566bc53a770ecd67cada7bee7da">&#9670;&nbsp;</a></span>isPreMultiplied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::TextureHeader::isPreMultiplied </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether or not the texture's color has been pre-multiplied by the alpha values. </p>
<dl class="section return"><dt>Returns</dt><dd>Return true if texture is premultiplied.</dd></dl>

</div>
</div>
<a id="a28a015fac0ee35f2dbb69e079487309a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a015fac0ee35f2dbb69e079487309a">&#9670;&nbsp;</a></span>setBumpMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setBumpMap </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bumpScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>bumpOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a texture's bump map data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bumpScale</td><td>Floating point "height" value to scale the bump map.</td></tr>
    <tr><td class="paramname">bumpOrder</td><td>Up to 4 character std::string, with values x,y,z,h in some combination.</td></tr>
  </table>
  </dd>
</dl>
<p>For <em>bumpOrder</em> Not all values need to be present. Denotes channel order: x,y,z refer to the corresponding axes, h indicates presence of the original height map. It is possible to have only some of these values rather than all. For example if 'h' is present alone it will be considered a height map. The values should be presented in RGBA order, regardless of the texture format, so a zyxh order in a bgra texture should still be passed as 'xyzh'. Capitals are allowed. Any character stored here that is not one of x,y,z,h or a NULL character will be ignored when PVRTexLib reads the data, but will be preserved. This is useful if you wish to define a custom data channel for instance. In these instances PVRTexLib will assume it is simply color data.</p>

</div>
</div>
<a id="a09da345ffb95b209ae9d515d342491cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09da345ffb95b209ae9d515d342491cc">&#9670;&nbsp;</a></span>setChannelType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setChannelType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a6f7777c11dfff8fcf4a03d85e5ab0b98">VariableType</a>&#160;</td>
          <td class="paramname"><em>newChannelType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the channel type of this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelType</td><td><a class="el" href="classpvr_1_1_texture.html" title="A 2D Texture asset, together with Information, Metadata and actual Pixel data. Only represents the ac...">Texture</a>'s channel type</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfe2fea504cd8ef590df356d61bcc215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe2fea504cd8ef590df356d61bcc215">&#9670;&nbsp;</a></span>setColorSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setColorSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr.html#a1b94afe6b8a7c21e8f8ddee1f7b5cb91">ColorSpace</a>&#160;</td>
          <td class="paramname"><em>newColorSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the color space for this texture. Default is lRGB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorSpace</td><td>A color space of the texture.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ae0add42744eb80a320819c7a30ceba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae0add42744eb80a320819c7a30ceba">&#9670;&nbsp;</a></span>setCubeMapOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setCubeMapOrder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cubeMapOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a texture's bump map data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cubeMapOrder</td><td>Up to 6 character std::string, with values x,X,y,Y,z,Z in some combination.</td></tr>
  </table>
  </dd>
</dl>
<p>for <em>cubmapOrder</em> Not all values need to be present. Denotes face order: Capitals refer to positive axis positions and small letters refer to negative axis positions. E.g. x=X-Negative, X=X-Positive. It is possible to have only some of these values rather than all, as long as they are NULL terminated. NB: Values past the 6th character are not read.</p>

</div>
</div>
<a id="a2b7469359ed22b4c6bb41495d2fa2f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7469359ed22b4c6bb41495d2fa2f4e">&#9670;&nbsp;</a></span>setDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setDepth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>newDepth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the texture depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newDepth</td><td>The new depth.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fa1c1b7885a83633003f9bc88d5b218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa1c1b7885a83633003f9bc88d5b218">&#9670;&nbsp;</a></span>setHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setHeight </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>newHeight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the texture height. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newHeight</td><td>The new height.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cee1199768def6a9748792eb5b0ccc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cee1199768def6a9748792eb5b0ccc3">&#9670;&nbsp;</a></span>setIsFileCompressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setIsFileCompressed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isFileCompressed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not the texture is compressed using PVRTexLib's FILE compression - this is independent of any texture compression. Currently unsupported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isFileCompressed</td><td>Sets file compression to true/false.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3edb013521dccb80f92759ab1c45f61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edb013521dccb80f92759ab1c45f61b">&#9670;&nbsp;</a></span>setIsPreMultiplied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setIsPreMultiplied </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPreMultiplied</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not the texture's color has been pre-multiplied by the alpha values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isPreMultiplied</td><td>Sets if texture is premultiplied.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a746d4244f009e9e13318710b5842fe9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746d4244f009e9e13318710b5842fe9a">&#9670;&nbsp;</a></span>setNumArrayMembers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setNumArrayMembers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numNewMembers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of arrays in this texture </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numNewMembers</td><td>The new number of members in this array.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9525ab8947e88b614c6e81b575d5c3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9525ab8947e88b614c6e81b575d5c3c9">&#9670;&nbsp;</a></span>setNumFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setNumFaces </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numNewFaces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of faces stored in this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numNewFaces</td><td>New number of faces for this texture.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c6fe8d132b26659e9072282dd037054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c6fe8d132b26659e9072282dd037054">&#9670;&nbsp;</a></span>setNumMipMapLevels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setNumMipMapLevels </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numNewMipMapLevels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of MIP-Map levels in this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numNewMipMapLevels</td><td>New number of MIP-Map levels.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaafee0c616f4217ebc193b0a4082a72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafee0c616f4217ebc193b0a4082a72f">&#9670;&nbsp;</a></span>setOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_texture_meta_data.html#a5acad07c0f0cc281a017cb56e7a92f5a">TextureMetaData::AxisOrientation</a>&#160;</td>
          <td class="paramname"><em>axisOrientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the data orientation for a given axis in this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axisOrientation</td><td>Specifying axis and orientation.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac843ef8bfde1ea52d0aad891807c4ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac843ef8bfde1ea52d0aad891807c4ea2">&#9670;&nbsp;</a></span>setPixelFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setPixelFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1_pixel_format.html">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>uPixelFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pixel format for this texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uPixelFormat</td><td>The format of the pixel.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b546b020e47df211588a983cc9872e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b546b020e47df211588a983cc9872e7">&#9670;&nbsp;</a></span>setWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::TextureHeader::setWidth </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>newWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the texture width. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newWidth</td><td>The new width.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRCore/texture/<a class="el" href="_texture_8h_source.html">Texture.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="20%" height="20%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
