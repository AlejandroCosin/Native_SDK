<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.17"/>
<title>PVRVk: pvrvk::impl::SecondaryCommandBuffer_ Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" type="image/x-icon" href="img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="https://www.imgtec.com/developers/" target="_blank"><img src="PVRlogo.png" width="80%" height="80%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRVk</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvrvk.html">pvrvk</a></li><li class="navelem"><a class="el" href="namespacepvrvk_1_1impl.html">impl</a></li><li class="navelem"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html">SecondaryCommandBuffer_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpvrvk_1_1impl_1_1_secondary_command_buffer__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvrvk::impl::SecondaryCommandBuffer_ Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer.  
 <a href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvrvk::impl::SecondaryCommandBuffer_:</div>
<div class="dyncontent">
<div class="center"><img src="classpvrvk_1_1impl_1_1_secondary_command_buffer____inherit__graph.png" border="0" usemap="#pvrvk_1_1impl_1_1_secondary_command_buffer___inherit__map" alt="Inheritance graph"/></div>
<map name="pvrvk_1_1impl_1_1_secondary_command_buffer___inherit__map" id="pvrvk_1_1impl_1_1_secondary_command_buffer___inherit__map">
<area shape="rect" title="Contains all the commands and states that need to be submitted to the gpu, including pipeline,..." alt="" coords="825,50,1064,91"/>
<area shape="rect" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html" title="Contains all the commands and states that need to be recorded for later submission to the gpu includi..." alt="" coords="567,50,777,91"/>
<area shape="rect" href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html" title=" " alt="" coords="251,5,517,61"/>
<area shape="rect" href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html" title=" " alt="" coords="5,5,201,61"/>
<area shape="rect" href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html" title=" " alt="" coords="249,86,519,127"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer___1_1make__shared__enabler.html">make_shared_enabler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class which restricts the creation of a <a class="el" href="namespacepvrvk.html#a672ec131cfc43b620333165b270a1b32" title="A SecondaryCommandBufferis a CommandBuffer that can only be submitted to a primary CommandBuffer and ...">pvrvk::SecondaryCommandBuffer</a> to children or friends of a <a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html" title="Contains all the commands and states that need to be submitted to the gpu, including pipeline,...">pvrvk::impl::SecondaryCommandBuffer_</a>.  <a href="classpvrvk_1_1impl_1_1_secondary_command_buffer___1_1make__shared__enabler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d449edb8cf90b9c237f940f0b561a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a6d449edb8cf90b9c237f940f0b561a9c">begin</a> (const CommandBufferUsageFlags flags=CommandBufferUsageFlags(0))</td></tr>
<tr class="memdesc:a6d449edb8cf90b9c237f940f0b561a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a6d449edb8cf90b9c237f940f0b561a9c">More...</a><br /></td></tr>
<tr class="separator:a6d449edb8cf90b9c237f940f0b561a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d449edb8cf90b9c237f940f0b561a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#a6d449edb8cf90b9c237f940f0b561a9c">begin</a> (const CommandBufferUsageFlags flags=CommandBufferUsageFlags(0))</td></tr>
<tr class="memdesc:a6d449edb8cf90b9c237f940f0b561a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands.  <a href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#a6d449edb8cf90b9c237f940f0b561a9c">More...</a><br /></td></tr>
<tr class="separator:a6d449edb8cf90b9c237f940f0b561a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574e16f7068cd5d978b627c9582ac7b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#a574e16f7068cd5d978b627c9582ac7b9">begin</a> (const <a class="el" href="namespacepvrvk.html#a5ea48df1aae258ade7640f956c5941fa">Framebuffer</a> &amp;framebuffer, uint32_t subpass=0, const CommandBufferUsageFlags flags=CommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT)</td></tr>
<tr class="memdesc:a574e16f7068cd5d978b627c9582ac7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands.  <a href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#a574e16f7068cd5d978b627c9582ac7b9">More...</a><br /></td></tr>
<tr class="separator:a574e16f7068cd5d978b627c9582ac7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d9e885485c1753a0b13f9ab07a78f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#a09d9e885485c1753a0b13f9ab07a78f6">begin</a> (const <a class="el" href="namespacepvrvk.html#a1f42311ecc0e570ba9d62332ff6f1f6d">RenderPass</a> &amp;renderpass, uint32_t subpass=0, const CommandBufferUsageFlags flags=CommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT)</td></tr>
<tr class="memdesc:a09d9e885485c1753a0b13f9ab07a78f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function before beginning to record commands. If the Framebuffer object is known, prefer the Framebuffer overload as it may offer better performance.  <a href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#a09d9e885485c1753a0b13f9ab07a78f6">More...</a><br /></td></tr>
<tr class="separator:a09d9e885485c1753a0b13f9ab07a78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45afc2b8a3f4fe54db79d82e1dc42ac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a45afc2b8a3f4fe54db79d82e1dc42ac6">beginDebugUtilsLabel</a> (const <a class="el" href="structpvrvk_1_1_debug_utils_label.html">pvrvk::DebugUtilsLabel</a> &amp;labelInfo)</td></tr>
<tr class="memdesc:a45afc2b8a3f4fe54db79d82e1dc42ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a45afc2b8a3f4fe54db79d82e1dc42ac6">More...</a><br /></td></tr>
<tr class="separator:a45afc2b8a3f4fe54db79d82e1dc42ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862a03340dc1812389fca32ceaffa881"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a862a03340dc1812389fca32ceaffa881">beginQuery</a> (<a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;queryPool, uint32_t queryIndex, QueryControlFlags flags=QueryControlFlags(0))</td></tr>
<tr class="memdesc:a862a03340dc1812389fca32ceaffa881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a query for a particular QueryPool.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a862a03340dc1812389fca32ceaffa881">More...</a><br /></td></tr>
<tr class="separator:a862a03340dc1812389fca32ceaffa881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9c026fda6f898ed9195b8bcf7ec2b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#acd9c026fda6f898ed9195b8bcf7ec2b1">beginQueryIndexed</a> (<a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;queryPool, uint32_t queryIndex, QueryControlFlags flags=QueryControlFlags(0), uint32_t index=0)</td></tr>
<tr class="memdesc:acd9c026fda6f898ed9195b8bcf7ec2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a query for a particular QueryPool.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#acd9c026fda6f898ed9195b8bcf7ec2b1">More...</a><br /></td></tr>
<tr class="separator:acd9c026fda6f898ed9195b8bcf7ec2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b723eecd29bfb3e5b35909d6cbb7af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a57b723eecd29bfb3e5b35909d6cbb7af">beginTransformFeedback</a> (<a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a> counterBuffer, VkDeviceSize counterBufferOffset=0)</td></tr>
<tr class="memdesc:a57b723eecd29bfb3e5b35909d6cbb7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes active transform feedback for specific transform feedback buffers.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a57b723eecd29bfb3e5b35909d6cbb7af">More...</a><br /></td></tr>
<tr class="separator:a57b723eecd29bfb3e5b35909d6cbb7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06530f4a0a7b0e10705650ca23d96b2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a06530f4a0a7b0e10705650ca23d96b2b">beginTransformFeedback</a> (uint32_t firstCounterBuffer, uint32_t numCounterBuffers, const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a> *counterBuffers=nullptr, const VkDeviceSize *counterBufferOffsets=nullptr)</td></tr>
<tr class="memdesc:a06530f4a0a7b0e10705650ca23d96b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes active transform feedback for specific transform feedback buffers.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a06530f4a0a7b0e10705650ca23d96b2b">More...</a><br /></td></tr>
<tr class="separator:a06530f4a0a7b0e10705650ca23d96b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e81e963a89f7b2b16112acb4c01d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a37e81e963a89f7b2b16112acb4c01d54">bindDescriptorSet</a> (PipelineBindPoint bindingPoint, const <a class="el" href="namespacepvrvk.html#a3639982454c70cc356ca557c7073c9f8">PipelineLayout</a> &amp;pipelineLayout, uint32_t firstSet, const <a class="el" href="namespacepvrvk.html#aad7d79ce674b1d4114eafb17a5914133">DescriptorSet</a> set, const uint32_t *dynamicOffsets=nullptr, uint32_t numDynamicOffsets=0)</td></tr>
<tr class="memdesc:a37e81e963a89f7b2b16112acb4c01d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind descriptorset  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a37e81e963a89f7b2b16112acb4c01d54">More...</a><br /></td></tr>
<tr class="separator:a37e81e963a89f7b2b16112acb4c01d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d43d0aee637c66a1137e0e32d1c09f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#af5d43d0aee637c66a1137e0e32d1c09f">bindDescriptorSets</a> (PipelineBindPoint bindingPoint, const <a class="el" href="namespacepvrvk.html#a3639982454c70cc356ca557c7073c9f8">PipelineLayout</a> &amp;pipelineLayout, uint32_t firstSet, const <a class="el" href="namespacepvrvk.html#aad7d79ce674b1d4114eafb17a5914133">DescriptorSet</a> *sets, uint32_t numDescriptorSets, const uint32_t *dynamicOffsets=nullptr, uint32_t numDynamicOffsets=0)</td></tr>
<tr class="memdesc:af5d43d0aee637c66a1137e0e32d1c09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind descriptorsets  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#af5d43d0aee637c66a1137e0e32d1c09f">More...</a><br /></td></tr>
<tr class="separator:af5d43d0aee637c66a1137e0e32d1c09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66ee757605ffa9afa68bf95ab9c7adf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aa66ee757605ffa9afa68bf95ab9c7adf">bindIndexBuffer</a> (const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;buffer, uint32_t offset, IndexType indexType)</td></tr>
<tr class="memdesc:aa66ee757605ffa9afa68bf95ab9c7adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind index bufer  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aa66ee757605ffa9afa68bf95ab9c7adf">More...</a><br /></td></tr>
<tr class="separator:aa66ee757605ffa9afa68bf95ab9c7adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d2f3d38f2aad3fa3ba4b7b793d1421"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a79d2f3d38f2aad3fa3ba4b7b793d1421">bindPipeline</a> (<a class="el" href="namespacepvrvk.html#a29a9475928347749fcf6e15f01d1ac9f">ComputePipeline</a> &amp;pipeline)</td></tr>
<tr class="memdesc:a79d2f3d38f2aad3fa3ba4b7b793d1421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a compute pipeline  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a79d2f3d38f2aad3fa3ba4b7b793d1421">More...</a><br /></td></tr>
<tr class="separator:a79d2f3d38f2aad3fa3ba4b7b793d1421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc394932317683fb0582841423527b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adfc394932317683fb0582841423527b2">bindPipeline</a> (const <a class="el" href="namespacepvrvk.html#a0eb06716297c66be780d357af1d36e91">GraphicsPipeline</a> &amp;pipeline)</td></tr>
<tr class="memdesc:adfc394932317683fb0582841423527b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a graphics pipeline.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adfc394932317683fb0582841423527b2">More...</a><br /></td></tr>
<tr class="separator:adfc394932317683fb0582841423527b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181604abd7b574918c422a426c91a300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a181604abd7b574918c422a426c91a300">bindPipeline</a> (<a class="el" href="namespacepvrvk.html#ae27af35258ddd3bb126a662c90d265b4">RaytracingPipeline</a> &amp;pipeline)</td></tr>
<tr class="memdesc:a181604abd7b574918c422a426c91a300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a ray tracing pipeline  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a181604abd7b574918c422a426c91a300">More...</a><br /></td></tr>
<tr class="separator:a181604abd7b574918c422a426c91a300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503e3d2574d33525209e5737814fe888"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a503e3d2574d33525209e5737814fe888">bindTransformFeedbackBuffers</a> (<a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a> buffer, VkDeviceSize offset, VkDeviceSize size=VK_WHOLE_SIZE)</td></tr>
<tr class="memdesc:a503e3d2574d33525209e5737814fe888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a transform feedback buffer to the command buffer for use in subsequent draw commands.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a503e3d2574d33525209e5737814fe888">More...</a><br /></td></tr>
<tr class="separator:a503e3d2574d33525209e5737814fe888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef32304c508552915c284f6764bdd47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8ef32304c508552915c284f6764bdd47">bindTransformFeedbackBuffers</a> (uint32_t firstBinding, uint32_t bindingCount, const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a> *buffers, const VkDeviceSize *offsets, const VkDeviceSize *sizes=nullptr)</td></tr>
<tr class="memdesc:a8ef32304c508552915c284f6764bdd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a set of transform feedback buffers to the command buffer for use in subsequent draw commands.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8ef32304c508552915c284f6764bdd47">More...</a><br /></td></tr>
<tr class="separator:a8ef32304c508552915c284f6764bdd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2853f758e9e70e100e3140405fc8e03c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2853f758e9e70e100e3140405fc8e03c">bindVertexBuffer</a> (<a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> const *buffers, uint32_t *offsets, uint16_t numBuffers, uint16_t startBinding, uint16_t numBindings)</td></tr>
<tr class="memdesc:a2853f758e9e70e100e3140405fc8e03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind vertex buffer  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2853f758e9e70e100e3140405fc8e03c">More...</a><br /></td></tr>
<tr class="separator:a2853f758e9e70e100e3140405fc8e03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2382fc789d3e96d50693f9e5483ff0b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2382fc789d3e96d50693f9e5483ff0b0">bindVertexBuffer</a> (const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;buffer, uint32_t offset, uint16_t bindingIndex)</td></tr>
<tr class="memdesc:a2382fc789d3e96d50693f9e5483ff0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind vertex buffer  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2382fc789d3e96d50693f9e5483ff0b0">More...</a><br /></td></tr>
<tr class="separator:a2382fc789d3e96d50693f9e5483ff0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c135444b1cab09ac85b642323155cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a40c135444b1cab09ac85b642323155cb">bindVertexBuffers</a> (const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> *buffers, uint32_t firstBinding, uint16_t bindingCount, const uint32_t *offsets=nullptr)</td></tr>
<tr class="memdesc:a40c135444b1cab09ac85b642323155cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind vertex buffer  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a40c135444b1cab09ac85b642323155cb">More...</a><br /></td></tr>
<tr class="separator:a40c135444b1cab09ac85b642323155cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b3caadb988c50778a3867c229d652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a5b6b3caadb988c50778a3867c229d652">blitImage</a> (const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;srcImage, const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;dstImage, const ImageBlit *regions, uint32_t numRegions, Filter filter, ImageLayout srcLayout, ImageLayout dstLayout)</td></tr>
<tr class="memdesc:a5b6b3caadb988c50778a3867c229d652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a5b6b3caadb988c50778a3867c229d652">More...</a><br /></td></tr>
<tr class="separator:a5b6b3caadb988c50778a3867c229d652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d8498fee836c63989072eb483d8938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a26d8498fee836c63989072eb483d8938">clearAttachment</a> (const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> &amp;clearAttachment, const ClearRect &amp;clearRectangle)</td></tr>
<tr class="memdesc:a26d8498fee836c63989072eb483d8938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a particular attachment using a provided region whilst inside of a renderpass.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a26d8498fee836c63989072eb483d8938">More...</a><br /></td></tr>
<tr class="separator:a26d8498fee836c63989072eb483d8938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac681c14ddfb7b443d318e695633571b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac681c14ddfb7b443d318e695633571b5">clearAttachments</a> (const uint32_t numAttachments, const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> *clearAttachments, uint32_t numRectangles, const ClearRect *clearRectangles)</td></tr>
<tr class="memdesc:ac681c14ddfb7b443d318e695633571b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a set of attacments using a number of regions for each selected attachment to clear whilst inside a renderpass.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac681c14ddfb7b443d318e695633571b5">More...</a><br /></td></tr>
<tr class="separator:ac681c14ddfb7b443d318e695633571b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1050ce0f6d621cb56b25e5ba0e862cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae1050ce0f6d621cb56b25e5ba0e862cf">clearColorImage</a> (const <a class="el" href="namespacepvrvk.html#adc4f5e5a2423045c3197ce383a53d910">ImageView</a> &amp;image, const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;clearColor, ImageLayout currentLayout, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges)</td></tr>
<tr class="memdesc:ae1050ce0f6d621cb56b25e5ba0e862cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a color image outside of a renderpass instance using a number of ranges.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae1050ce0f6d621cb56b25e5ba0e862cf">More...</a><br /></td></tr>
<tr class="separator:ae1050ce0f6d621cb56b25e5ba0e862cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5832f5365e38a33a1768baf09fc4ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a6a5832f5365e38a33a1768baf09fc4ba">clearColorImage</a> (const <a class="el" href="namespacepvrvk.html#adc4f5e5a2423045c3197ce383a53d910">ImageView</a> &amp;image, const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;clearColor, ImageLayout currentLayout, const uint32_t baseMipLevel=0, const uint32_t numLevels=1, const uint32_t baseArrayLayer=0, const uint32_t numLayers=1)</td></tr>
<tr class="memdesc:a6a5832f5365e38a33a1768baf09fc4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a color image outside of a renderpass instance.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a6a5832f5365e38a33a1768baf09fc4ba">More...</a><br /></td></tr>
<tr class="separator:a6a5832f5365e38a33a1768baf09fc4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b58f4906588ca9dfa2438c37540c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a51b58f4906588ca9dfa2438c37540c30">clearDepthImage</a> (const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;image, float clearDepth, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges, ImageLayout layout)</td></tr>
<tr class="memdesc:a51b58f4906588ca9dfa2438c37540c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the depth image outside of a renderpass instance using a number of ranges.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a51b58f4906588ca9dfa2438c37540c30">More...</a><br /></td></tr>
<tr class="separator:a51b58f4906588ca9dfa2438c37540c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac919e8871b7d6b2c6886562f08c5b5ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac919e8871b7d6b2c6886562f08c5b5ac">clearDepthImage</a> (const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;image, float clearDepth, const uint32_t baseMipLevel, const uint32_t numLevels, const uint32_t baseArrayLayer, const uint32_t numLayers, ImageLayout layout)</td></tr>
<tr class="memdesc:ac919e8871b7d6b2c6886562f08c5b5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear depth image outside of a renderpass instance.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac919e8871b7d6b2c6886562f08c5b5ac">More...</a><br /></td></tr>
<tr class="separator:ac919e8871b7d6b2c6886562f08c5b5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4caad1d3256751db0735dae4c4ecd14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac4caad1d3256751db0735dae4c4ecd14">clearDepthStencilImage</a> (const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;image, float clearDepth, uint32_t clearStencil, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges, ImageLayout layout)</td></tr>
<tr class="memdesc:ac4caad1d3256751db0735dae4c4ecd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear depth stencil image outside of a renderpass instance using a number of ranges.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac4caad1d3256751db0735dae4c4ecd14">More...</a><br /></td></tr>
<tr class="separator:ac4caad1d3256751db0735dae4c4ecd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc175f1965e8857291b3e61380fde0d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#afc175f1965e8857291b3e61380fde0d1">clearDepthStencilImage</a> (const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;image, float clearDepth, uint32_t clearStencil, const uint32_t baseMipLevel, const uint32_t numLevels, const uint32_t baseArrayLayer, const uint32_t numLayers, ImageLayout layout)</td></tr>
<tr class="memdesc:afc175f1965e8857291b3e61380fde0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear depth stencil image outside of a renderpass instance.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#afc175f1965e8857291b3e61380fde0d1">More...</a><br /></td></tr>
<tr class="separator:afc175f1965e8857291b3e61380fde0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7894b82302fae9d634b6564a0e912256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7894b82302fae9d634b6564a0e912256">clearStencilImage</a> (const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;image, uint32_t clearStencil, const uint32_t *baseMipLevels, const uint32_t *numLevels, const uint32_t *baseArrayLayers, const uint32_t *numLayers, uint32_t numRanges, ImageLayout layout)</td></tr>
<tr class="memdesc:a7894b82302fae9d634b6564a0e912256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear stencil image outside of a renderpass instance using a number of ranges.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7894b82302fae9d634b6564a0e912256">More...</a><br /></td></tr>
<tr class="separator:a7894b82302fae9d634b6564a0e912256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fcb36a78addbdf25d5f52044e37152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a96fcb36a78addbdf25d5f52044e37152">clearStencilImage</a> (const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;image, uint32_t clearStencil, const uint32_t baseMipLevel, const uint32_t numLevels, const uint32_t baseArrayLayer, const uint32_t numLayers, ImageLayout layout)</td></tr>
<tr class="memdesc:a96fcb36a78addbdf25d5f52044e37152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears a stencil image outside of a renderpass instance.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a96fcb36a78addbdf25d5f52044e37152">More...</a><br /></td></tr>
<tr class="separator:a96fcb36a78addbdf25d5f52044e37152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc6d67c3d3a47780e62c8d9632776cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a9fc6d67c3d3a47780e62c8d9632776cb">copyBuffer</a> (const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;srcBuffer, const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;dstBuffer, uint32_t numRegions, const BufferCopy *regions)</td></tr>
<tr class="memdesc:a9fc6d67c3d3a47780e62c8d9632776cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Buffer  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a9fc6d67c3d3a47780e62c8d9632776cb">More...</a><br /></td></tr>
<tr class="separator:a9fc6d67c3d3a47780e62c8d9632776cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851659286aa0122bc8d42ec5c823604c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a851659286aa0122bc8d42ec5c823604c">copyBufferToImage</a> (const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;buffer, const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;image, ImageLayout dstImageLayout, uint32_t regionsCount, const BufferImageCopy *regions)</td></tr>
<tr class="memdesc:a851659286aa0122bc8d42ec5c823604c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy buffer to image  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a851659286aa0122bc8d42ec5c823604c">More...</a><br /></td></tr>
<tr class="separator:a851659286aa0122bc8d42ec5c823604c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226df08eca4fcc10fac3976860cd70af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a226df08eca4fcc10fac3976860cd70af">copyImage</a> (const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;srcImage, const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;dstImage, ImageLayout srcImageLayout, ImageLayout dstImageLayout, uint32_t numRegions, const ImageCopy *regions)</td></tr>
<tr class="memdesc:a226df08eca4fcc10fac3976860cd70af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data between Images  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a226df08eca4fcc10fac3976860cd70af">More...</a><br /></td></tr>
<tr class="separator:a226df08eca4fcc10fac3976860cd70af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da3e72621920307892661c98f0cab01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8da3e72621920307892661c98f0cab01">copyImageToBuffer</a> (const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;srcImage, ImageLayout srcImageLayout, <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;dstBuffer, const BufferImageCopy *regions, uint32_t numRegions)</td></tr>
<tr class="memdesc:a8da3e72621920307892661c98f0cab01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image to buffer  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8da3e72621920307892661c98f0cab01">More...</a><br /></td></tr>
<tr class="separator:a8da3e72621920307892661c98f0cab01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b0c98a25f798bb0af566f3f1238c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae7b0c98a25f798bb0af566f3f1238c3c">copyQueryPoolResults</a> (<a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;queryPool, uint32_t firstQuery, uint32_t queryCount, <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;dstBuffer, VkDeviceSize offset, VkDeviceSize stride, QueryResultFlags flags)</td></tr>
<tr class="memdesc:ae7b0c98a25f798bb0af566f3f1238c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the query statuses and numerical results directly to buffer memory.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae7b0c98a25f798bb0af566f3f1238c3c">More...</a><br /></td></tr>
<tr class="separator:ae7b0c98a25f798bb0af566f3f1238c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a30a9993a36579194e6c7f73b107a8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2a30a9993a36579194e6c7f73b107a8e">debugMarkerBeginEXT</a> (<a class="el" href="structpvrvk_1_1_debug_marker_marker_info.html">pvrvk::DebugMarkerMarkerInfo</a> &amp;markerInfo)</td></tr>
<tr class="memdesc:a2a30a9993a36579194e6c7f73b107a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a debug marked region.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2a30a9993a36579194e6c7f73b107a8e">More...</a><br /></td></tr>
<tr class="separator:a2a30a9993a36579194e6c7f73b107a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029a7feee509f14715a509ef1de45b26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a029a7feee509f14715a509ef1de45b26">debugMarkerEndEXT</a> ()</td></tr>
<tr class="memdesc:a029a7feee509f14715a509ef1de45b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a debug marked region.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a029a7feee509f14715a509ef1de45b26">More...</a><br /></td></tr>
<tr class="separator:a029a7feee509f14715a509ef1de45b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c72a73a8da59ae5356a6c8c30ba310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a61c72a73a8da59ae5356a6c8c30ba310">debugMarkerInsertEXT</a> (<a class="el" href="structpvrvk_1_1_debug_marker_marker_info.html">pvrvk::DebugMarkerMarkerInfo</a> &amp;markerInfo)</td></tr>
<tr class="memdesc:a61c72a73a8da59ae5356a6c8c30ba310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a debug marker.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a61c72a73a8da59ae5356a6c8c30ba310">More...</a><br /></td></tr>
<tr class="separator:a61c72a73a8da59ae5356a6c8c30ba310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aeb9ef8d82603dfeac45d2ff177ba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a96aeb9ef8d82603dfeac45d2ff177ba2">dispatch</a> (uint32_t numGroupX, uint32_t numGroupY, uint32_t numGroupZ)</td></tr>
<tr class="memdesc:a96aeb9ef8d82603dfeac45d2ff177ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a96aeb9ef8d82603dfeac45d2ff177ba2">More...</a><br /></td></tr>
<tr class="separator:a96aeb9ef8d82603dfeac45d2ff177ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb78b08d16568eeb47ffed3294d3f6e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#acb78b08d16568eeb47ffed3294d3f6e2">dispatchIndirect</a> (<a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;buffer, uint32_t offset)</td></tr>
<tr class="memdesc:acb78b08d16568eeb47ffed3294d3f6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded. dispatchIndirect behaves similarly to dispatch except that the parameters are read by the device from a buffer during execution. The parameters of the dispatch are encoded in a DispatchIndirectCommand structure taken from buffer starting at offset  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#acb78b08d16568eeb47ffed3294d3f6e2">More...</a><br /></td></tr>
<tr class="separator:acb78b08d16568eeb47ffed3294d3f6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a38f7566ddeb086f6aa546ee3311288"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a4a38f7566ddeb086f6aa546ee3311288">draw</a> (uint32_t firstVertex, uint32_t numVertices, uint32_t firstInstance=0, uint32_t numInstances=1)</td></tr>
<tr class="memdesc:a4a38f7566ddeb086f6aa546ee3311288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-indexed drawing command.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a4a38f7566ddeb086f6aa546ee3311288">More...</a><br /></td></tr>
<tr class="separator:a4a38f7566ddeb086f6aa546ee3311288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85499f2c0908567eb04903dc51b2c9da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a85499f2c0908567eb04903dc51b2c9da">drawIndexed</a> (uint32_t firstIndex, uint32_t numIndices, int32_t vertexOffset=0, uint32_t firstInstance=0, uint32_t numInstances=1)</td></tr>
<tr class="memdesc:a85499f2c0908567eb04903dc51b2c9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed drawing command.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a85499f2c0908567eb04903dc51b2c9da">More...</a><br /></td></tr>
<tr class="separator:a85499f2c0908567eb04903dc51b2c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c8d29b0470bcc6df46f83032408db1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a58c8d29b0470bcc6df46f83032408db1">drawIndexedIndirect</a> (const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;buffer, uint32_t offset, uint32_t count, uint32_t stride)</td></tr>
<tr class="memdesc:a58c8d29b0470bcc6df46f83032408db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-indexed indirect drawing command.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a58c8d29b0470bcc6df46f83032408db1">More...</a><br /></td></tr>
<tr class="separator:a58c8d29b0470bcc6df46f83032408db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea627c5ef086a05ac210a4a4b3287ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2ea627c5ef086a05ac210a4a4b3287ea">drawIndirect</a> (const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;buffer, uint32_t offset, uint32_t count, uint32_t stride)</td></tr>
<tr class="memdesc:a2ea627c5ef086a05ac210a4a4b3287ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-indexed indirect drawing command.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a2ea627c5ef086a05ac210a4a4b3287ea">More...</a><br /></td></tr>
<tr class="separator:a2ea627c5ef086a05ac210a4a4b3287ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d898c93ffd584464a0f079b7df6785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a65d898c93ffd584464a0f079b7df6785">drawIndirectByteCount</a> (uint32_t instanceCount, uint32_t firstInstance, <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a> counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride)</td></tr>
<tr class="memdesc:a65d898c93ffd584464a0f079b7df6785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a non-indexed draw call, where the vertex count is based on a byte count read from a buffer and the passed in vertex stride parameter.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a65d898c93ffd584464a0f079b7df6785">More...</a><br /></td></tr>
<tr class="separator:a65d898c93ffd584464a0f079b7df6785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571250974bf01a908011ca732dbb74d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a571250974bf01a908011ca732dbb74d7">end</a> ()</td></tr>
<tr class="memdesc:a571250974bf01a908011ca732dbb74d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you are done recording commands. BeginRecording must be called first.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a571250974bf01a908011ca732dbb74d7">More...</a><br /></td></tr>
<tr class="separator:a571250974bf01a908011ca732dbb74d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5041db8fba30b3e7711c66bff1841677"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a5041db8fba30b3e7711c66bff1841677">endDebugUtilsLabel</a> ()</td></tr>
<tr class="memdesc:a5041db8fba30b3e7711c66bff1841677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a label region of work submitted to this command buffer.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a5041db8fba30b3e7711c66bff1841677">More...</a><br /></td></tr>
<tr class="separator:a5041db8fba30b3e7711c66bff1841677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1bc81278e124ac66d23eac1fe2dc6cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac1bc81278e124ac66d23eac1fe2dc6cd">endQuery</a> (<a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;queryPool, uint32_t queryIndex)</td></tr>
<tr class="memdesc:ac1bc81278e124ac66d23eac1fe2dc6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a query for a particular QueryPool.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ac1bc81278e124ac66d23eac1fe2dc6cd">More...</a><br /></td></tr>
<tr class="separator:ac1bc81278e124ac66d23eac1fe2dc6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bef572ff59b8feb48ac11cc853931b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a87bef572ff59b8feb48ac11cc853931b">endQueryIndexed</a> (<a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;queryPool, uint32_t queryIndex, uint32_t index=0)</td></tr>
<tr class="memdesc:a87bef572ff59b8feb48ac11cc853931b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a query for a particular QueryPool.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a87bef572ff59b8feb48ac11cc853931b">More...</a><br /></td></tr>
<tr class="separator:a87bef572ff59b8feb48ac11cc853931b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ad56f9817502bade39faeb9bd5e53a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a27ad56f9817502bade39faeb9bd5e53a">endTransformFeedback</a> (<a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a> counterBuffer, VkDeviceSize counterBufferOffset=0)</td></tr>
<tr class="memdesc:a27ad56f9817502bade39faeb9bd5e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes inactive transform feedback for specific transform feedback buffers.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a27ad56f9817502bade39faeb9bd5e53a">More...</a><br /></td></tr>
<tr class="separator:a27ad56f9817502bade39faeb9bd5e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd32218e444b8b78a272b0db5c7b5ca4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#abd32218e444b8b78a272b0db5c7b5ca4">endTransformFeedback</a> (uint32_t firstCounterBuffer, uint32_t numCounterBuffers, const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a> *counterBuffers=nullptr, const VkDeviceSize *counterBufferOffsets=nullptr)</td></tr>
<tr class="memdesc:abd32218e444b8b78a272b0db5c7b5ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes inactive transform feedback for specific transform feedback buffers.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#abd32218e444b8b78a272b0db5c7b5ca4">More...</a><br /></td></tr>
<tr class="separator:abd32218e444b8b78a272b0db5c7b5ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e4d36d3a03784aa145a257affc24c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae9e4d36d3a03784aa145a257affc24c3">fillBuffer</a> (const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;dstBuffer, uint32_t dstOffset, uint32_t data, uint64_t size=VK_WHOLE_SIZE)</td></tr>
<tr class="memdesc:ae9e4d36d3a03784aa145a257affc24c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear buffer data  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae9e4d36d3a03784aa145a257affc24c3">More...</a><br /></td></tr>
<tr class="separator:ae9e4d36d3a03784aa145a257affc24c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1d41731998110bc7216fc79aca7e85"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepvrvk.html#a19e4e901387a642d912f4e8e67d541b7">CommandPool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aef1d41731998110bc7216fc79aca7e85">getCommandPool</a> () const</td></tr>
<tr class="memdesc:aef1d41731998110bc7216fc79aca7e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const getter for the command pool used to allocate this command buffer.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aef1d41731998110bc7216fc79aca7e85">More...</a><br /></td></tr>
<tr class="separator:aef1d41731998110bc7216fc79aca7e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fac1d61fb53bcce751d3386d97a41d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a48baa2a10fcb9f1bafd42e398fdbce61">Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html#a5fac1d61fb53bcce751d3386d97a41d1">getDevice</a> ()</td></tr>
<tr class="memdesc:a5fac1d61fb53bcce751d3386d97a41d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Device  <a href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html#a5fac1d61fb53bcce751d3386d97a41d1">More...</a><br /></td></tr>
<tr class="separator:a5fac1d61fb53bcce751d3386d97a41d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d29595868d7f06527e3d8fd0e72f92"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepvrvk.html#a48baa2a10fcb9f1bafd42e398fdbce61">Device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html#ac8d29595868d7f06527e3d8fd0e72f92">getDevice</a> () const</td></tr>
<tr class="memdesc:ac8d29595868d7f06527e3d8fd0e72f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Device (const)  <a href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html#ac8d29595868d7f06527e3d8fd0e72f92">More...</a><br /></td></tr>
<tr class="separator:ac8d29595868d7f06527e3d8fd0e72f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a50f281b09625367de97d0b9d6b863f"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html#a0a50f281b09625367de97d0b9d6b863f">getObjectName</a> () const</td></tr>
<tr class="memdesc:a0a50f281b09625367de97d0b9d6b863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Debug Marker name.  <a href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html#a0a50f281b09625367de97d0b9d6b863f">More...</a><br /></td></tr>
<tr class="separator:a0a50f281b09625367de97d0b9d6b863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd5073b84650d52de16ab11d80d9b88"><td class="memItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html#a0dd5073b84650d52de16ab11d80d9b88">getObjectType</a> () const</td></tr>
<tr class="memdesc:a0dd5073b84650d52de16ab11d80d9b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specified object's type.  <a href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html#a0dd5073b84650d52de16ab11d80d9b88">More...</a><br /></td></tr>
<tr class="separator:a0dd5073b84650d52de16ab11d80d9b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2e6d460c18fca2adf251043c672bcc"><td class="memItemLeft" align="right" valign="top">const VkCommandBuffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html#a9d2e6d460c18fca2adf251043c672bcc">getVkHandle</a> () const</td></tr>
<tr class="memdesc:a9d2e6d460c18fca2adf251043c672bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vulkan object (const)  <a href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html#a9d2e6d460c18fca2adf251043c672bcc">More...</a><br /></td></tr>
<tr class="separator:a9d2e6d460c18fca2adf251043c672bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd58139997afe65b294d34815ee9dbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a5dd58139997afe65b294d34815ee9dbd">insertDebugUtilsLabel</a> (const <a class="el" href="structpvrvk_1_1_debug_utils_label.html">pvrvk::DebugUtilsLabel</a> &amp;labelInfo)</td></tr>
<tr class="memdesc:a5dd58139997afe65b294d34815ee9dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single debug label any time.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a5dd58139997afe65b294d34815ee9dbd">More...</a><br /></td></tr>
<tr class="separator:a5dd58139997afe65b294d34815ee9dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f32e4b0b8899d01ff783456befcb5b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a0f32e4b0b8899d01ff783456befcb5b9">isRecording</a> ()</td></tr>
<tr class="memdesc:a0f32e4b0b8899d01ff783456befcb5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries if a command buffer is in the recording state  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a0f32e4b0b8899d01ff783456befcb5b9">More...</a><br /></td></tr>
<tr class="separator:a0f32e4b0b8899d01ff783456befcb5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f27bf1f81f790997dca75aa747ddaf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7f27bf1f81f790997dca75aa747ddaf2">pipelineBarrier</a> (PipelineStageFlags srcStage, PipelineStageFlags dstStage, const <a class="el" href="structpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers, bool dependencyByRegion=true)</td></tr>
<tr class="memdesc:a7f27bf1f81f790997dca75aa747ddaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7f27bf1f81f790997dca75aa747ddaf2">More...</a><br /></td></tr>
<tr class="separator:a7f27bf1f81f790997dca75aa747ddaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723ace2575665407b309eb3a397c180d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a723ace2575665407b309eb3a397c180d">pushConstants</a> (const <a class="el" href="namespacepvrvk.html#a3639982454c70cc356ca557c7073c9f8">PipelineLayout</a> &amp;pipelineLayout, ShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *data)</td></tr>
<tr class="memdesc:a723ace2575665407b309eb3a397c180d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value of shader push constants at the offset specified.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a723ace2575665407b309eb3a397c180d">More...</a><br /></td></tr>
<tr class="separator:a723ace2575665407b309eb3a397c180d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bb86da0f90ca1bb6a9977fa6941251"><td class="memItemLeft" align="right" valign="top"><a id="aa1bb86da0f90ca1bb6a9977fa6941251"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aa1bb86da0f90ca1bb6a9977fa6941251">reset</a> (CommandBufferResetFlags resetFlags=CommandBufferResetFlags::e_NONE)</td></tr>
<tr class="memdesc:aa1bb86da0f90ca1bb6a9977fa6941251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears this CommandBuffer discarding any previously recorded commands and puts the command buffer in the initial state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resetFlags</td><td>Is a bitmask of CommandBufferResetFlagBits controlling the reset operation.</td></tr>
  </table>
  </dd>
</dl>
<br /></td></tr>
<tr class="separator:aa1bb86da0f90ca1bb6a9977fa6941251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cea12c65ab4bbd82d0916a47e44437"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aa4cea12c65ab4bbd82d0916a47e44437">resetEvent</a> (<a class="el" href="namespacepvrvk.html#a635ac03f2c72ca7a64ecb846d10ca140">Event</a> &amp;event, PipelineStageFlags pipelineStageFlags=PipelineStageFlags::e_ALL_COMMANDS_BIT)</td></tr>
<tr class="memdesc:aa4cea12c65ab4bbd82d0916a47e44437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an execution dependency on commands that were submitted before it, and defines an event unsignal operation which resets the event to the unsignaled state.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aa4cea12c65ab4bbd82d0916a47e44437">More...</a><br /></td></tr>
<tr class="separator:aa4cea12c65ab4bbd82d0916a47e44437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34022a1a96759902c41c68a33264576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html#ac34022a1a96759902c41c68a33264576">resetObjectName</a> ()</td></tr>
<tr class="memdesc:ac34022a1a96759902c41c68a33264576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the name of a specified object using the extension VK_EXT_debug_marker or VK_EXT_debug_utils.  <a href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html#ac34022a1a96759902c41c68a33264576">More...</a><br /></td></tr>
<tr class="separator:ac34022a1a96759902c41c68a33264576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d37c209b0ef644c8f069a70be5bf156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7d37c209b0ef644c8f069a70be5bf156">resetQueryPool</a> (<a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;queryPool, uint32_t firstQuery, uint32_t queryCount)</td></tr>
<tr class="memdesc:a7d37c209b0ef644c8f069a70be5bf156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a particular range of queries for a particular QueryPool and sets their status' to unavailable which also makes their numerical results undefined.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7d37c209b0ef644c8f069a70be5bf156">More...</a><br /></td></tr>
<tr class="separator:a7d37c209b0ef644c8f069a70be5bf156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8148425c603008468c0a25e84c486b1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8148425c603008468c0a25e84c486b1d">resetQueryPool</a> (<a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;queryPool, uint32_t queryIndex)</td></tr>
<tr class="memdesc:a8148425c603008468c0a25e84c486b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a particular range of queries for a particular QueryPool and sets their status' to unavailable which also makes their numerical results undefined.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8148425c603008468c0a25e84c486b1d">More...</a><br /></td></tr>
<tr class="separator:a8148425c603008468c0a25e84c486b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7934a30102546d42737ea88999eb3e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7934a30102546d42737ea88999eb3e16">resolveImage</a> (const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;srcImage, const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;dstImage, const ImageResolve *regions, uint32_t numRegions, ImageLayout srcLayout, ImageLayout dstLayout)</td></tr>
<tr class="memdesc:a7934a30102546d42737ea88999eb3e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a7934a30102546d42737ea88999eb3e16">More...</a><br /></td></tr>
<tr class="separator:a7934a30102546d42737ea88999eb3e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce2c215aa9814e5e8aa02f679f9fa24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a9ce2c215aa9814e5e8aa02f679f9fa24">setBlendConstants</a> (float rgba[4])</td></tr>
<tr class="memdesc:a9ce2c215aa9814e5e8aa02f679f9fa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic blend constant bias state affecting pipeline objects created with VK_DYNAMIC_STATE_BLEND_CONSTANTS enabled.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a9ce2c215aa9814e5e8aa02f679f9fa24">More...</a><br /></td></tr>
<tr class="separator:a9ce2c215aa9814e5e8aa02f679f9fa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a9d46e8f693398db0dc03fede5fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a486a9d46e8f693398db0dc03fede5fb6">setDepthBias</a> (float constantFactor, float clamp, float slopeFactor)</td></tr>
<tr class="memdesc:a486a9d46e8f693398db0dc03fede5fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic depth bias state affecting pipeline objects created where depthBiasEnable is enabled.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a486a9d46e8f693398db0dc03fede5fb6">More...</a><br /></td></tr>
<tr class="separator:a486a9d46e8f693398db0dc03fede5fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41e1a87d69f9f3476ea6e20037b9b00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae41e1a87d69f9f3476ea6e20037b9b00">setDepthBounds</a> (float min, float max)</td></tr>
<tr class="memdesc:ae41e1a87d69f9f3476ea6e20037b9b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic depth bounds state affecting pipeline objects created with VK_DYNAMIC_STATE_DEPTH_BOUNDS enabled.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ae41e1a87d69f9f3476ea6e20037b9b00">More...</a><br /></td></tr>
<tr class="separator:ae41e1a87d69f9f3476ea6e20037b9b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c47766d3ed0ef1aa2dc0ea6819162c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ad2c47766d3ed0ef1aa2dc0ea6819162c">setEvent</a> (<a class="el" href="namespacepvrvk.html#a635ac03f2c72ca7a64ecb846d10ca140">Event</a> &amp;event, PipelineStageFlags pipelineStageFlags=PipelineStageFlags::e_ALL_COMMANDS_BIT)</td></tr>
<tr class="memdesc:ad2c47766d3ed0ef1aa2dc0ea6819162c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an execution dependency on commands that were submitted before it, and defines an event signal operation which sets the event to the signaled state.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ad2c47766d3ed0ef1aa2dc0ea6819162c">More...</a><br /></td></tr>
<tr class="separator:ad2c47766d3ed0ef1aa2dc0ea6819162c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ede42f0aeabc8b98cc13585114323a7"><td class="memItemLeft" align="right" valign="top"><a id="a2ede42f0aeabc8b98cc13585114323a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setFragmentShadingRate</b> (Extent2D fragmentSize, FragmentShadingRateCombinerOpKHR combinerOps[2])</td></tr>
<tr class="separator:a2ede42f0aeabc8b98cc13585114323a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e36ba62ffb95e3a6fd71aa415542391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a6e36ba62ffb95e3a6fd71aa415542391">setLineWidth</a> (float lineWidth)</td></tr>
<tr class="memdesc:a6e36ba62ffb95e3a6fd71aa415542391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic line width state affecting pipeline objects created with VK_DYNAMIC_STATE_LINE_WIDTH enabled.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a6e36ba62ffb95e3a6fd71aa415542391">More...</a><br /></td></tr>
<tr class="separator:a6e36ba62ffb95e3a6fd71aa415542391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cc55657dbc15c87bc158960f5ececd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html#a93cc55657dbc15c87bc158960f5ececd">setObjectName</a> (const std::string &amp;objectName)</td></tr>
<tr class="memdesc:a93cc55657dbc15c87bc158960f5ececd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes use of the extension VK_EXT_debug_marker or VK_EXT_debug_utils to provide a name for a specified object.  <a href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html#a93cc55657dbc15c87bc158960f5ececd">More...</a><br /></td></tr>
<tr class="separator:a93cc55657dbc15c87bc158960f5ececd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3e93927c6dfb8e82ef548282462f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html#a4f3e93927c6dfb8e82ef548282462f03">setObjectTag</a> (uint64_t tagName, size_t tagSize, const void *tag)</td></tr>
<tr class="memdesc:a4f3e93927c6dfb8e82ef548282462f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes use of the extension VK_EXT_debug_marker or VK_EXT_debug_utils to provide a tag for a specified object.  <a href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html#a4f3e93927c6dfb8e82ef548282462f03">More...</a><br /></td></tr>
<tr class="separator:a4f3e93927c6dfb8e82ef548282462f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ee4dbcda7a265e6b5898a1a9d052d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a73ee4dbcda7a265e6b5898a1a9d052d2">setScissor</a> (uint32_t firstScissor, uint32_t numScissors, const Rect2D *scissors)</td></tr>
<tr class="memdesc:a73ee4dbcda7a265e6b5898a1a9d052d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic scissor state affecting pipeline objects created with VK_DYNAMIC_STATE_SCISSOR enabled.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a73ee4dbcda7a265e6b5898a1a9d052d2">More...</a><br /></td></tr>
<tr class="separator:a73ee4dbcda7a265e6b5898a1a9d052d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef9f36e3f5383594c1f561fa800aff7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#acef9f36e3f5383594c1f561fa800aff7">setStencilCompareMask</a> (StencilFaceFlags face, uint32_t compareMask)</td></tr>
<tr class="memdesc:acef9f36e3f5383594c1f561fa800aff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic stencil compare mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK enabled.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#acef9f36e3f5383594c1f561fa800aff7">More...</a><br /></td></tr>
<tr class="separator:acef9f36e3f5383594c1f561fa800aff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc42ff2f511f268d68d0901b6281326d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adc42ff2f511f268d68d0901b6281326d">setStencilReference</a> (StencilFaceFlags face, uint32_t reference)</td></tr>
<tr class="memdesc:adc42ff2f511f268d68d0901b6281326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic stencil reference mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_REFERENCE enabled.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adc42ff2f511f268d68d0901b6281326d">More...</a><br /></td></tr>
<tr class="separator:adc42ff2f511f268d68d0901b6281326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3837e03b54149248c01087d7f77dd9f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a3837e03b54149248c01087d7f77dd9f8">setStencilWriteMask</a> (StencilFaceFlags face, uint32_t writeMask)</td></tr>
<tr class="memdesc:a3837e03b54149248c01087d7f77dd9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dynamic stencil write mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_WRITE_MASK enabled.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a3837e03b54149248c01087d7f77dd9f8">More...</a><br /></td></tr>
<tr class="separator:a3837e03b54149248c01087d7f77dd9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b850bccfeda750ecb9e2c98c8c2b018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8b850bccfeda750ecb9e2c98c8c2b018">setViewport</a> (const Viewport &amp;viewport)</td></tr>
<tr class="memdesc:a8b850bccfeda750ecb9e2c98c8c2b018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set viewport  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8b850bccfeda750ecb9e2c98c8c2b018">More...</a><br /></td></tr>
<tr class="separator:a8b850bccfeda750ecb9e2c98c8c2b018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03678a47f714d335cec2b4118b0b92e"><td class="memItemLeft" align="right" valign="top"><a id="ae03678a47f714d335cec2b4118b0b92e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>traceRays</b> (pvrvk::StridedDeviceAddressRegionKHR &amp;raygenTable, pvrvk::StridedDeviceAddressRegionKHR &amp;missTable, pvrvk::StridedDeviceAddressRegionKHR &amp;hitTable, pvrvk::StridedDeviceAddressRegionKHR &amp;callableTable, int width, int height, int depth)</td></tr>
<tr class="separator:ae03678a47f714d335cec2b4118b0b92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdff785ab2013d7b2ff4c05f2f5e21af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#abdff785ab2013d7b2ff4c05f2f5e21af">updateBuffer</a> (const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;buffer, const void *data, uint32_t offset, uint32_t length)</td></tr>
<tr class="memdesc:abdff785ab2013d7b2ff4c05f2f5e21af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates buffer data inline in a command buffer. The update is only allowed outside of a renderpass and is treated as a transfer operation for the purposes of syncrhonization.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#abdff785ab2013d7b2ff4c05f2f5e21af">More...</a><br /></td></tr>
<tr class="separator:abdff785ab2013d7b2ff4c05f2f5e21af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7cfaed7300edd34cd1de176278e516"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aff7cfaed7300edd34cd1de176278e516">waitForEvent</a> (const <a class="el" href="namespacepvrvk.html#a635ac03f2c72ca7a64ecb846d10ca140">Event</a> &amp;event, PipelineStageFlags srcStage, PipelineStageFlags dstStage, const <a class="el" href="structpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers)</td></tr>
<tr class="memdesc:aff7cfaed7300edd34cd1de176278e516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a memory dependency between prior event signal operations and subsequent commands.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#aff7cfaed7300edd34cd1de176278e516">More...</a><br /></td></tr>
<tr class="separator:aff7cfaed7300edd34cd1de176278e516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7063f61ca8234126f81ec9625153e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8b7063f61ca8234126f81ec9625153e7">waitForEvents</a> (const <a class="el" href="namespacepvrvk.html#a635ac03f2c72ca7a64ecb846d10ca140">Event</a> *events, uint32_t numEvents, PipelineStageFlags srcStage, PipelineStageFlags dstStage, const <a class="el" href="structpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers)</td></tr>
<tr class="memdesc:a8b7063f61ca8234126f81ec9625153e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a set of memory dependencies between prior event signal operations and subsequent commands.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a8b7063f61ca8234126f81ec9625153e7">More...</a><br /></td></tr>
<tr class="separator:a8b7063f61ca8234126f81ec9625153e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fc5e0ce68a45bfda286a3a02fec71b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a09fc5e0ce68a45bfda286a3a02fec71b">writeTimestamp</a> (<a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;queryPool, uint32_t queryIndex, PipelineStageFlags pipelineStage)</td></tr>
<tr class="memdesc:a09fc5e0ce68a45bfda286a3a02fec71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a timestamp for a particular QueryPool to be written to the query.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a09fc5e0ce68a45bfda286a3a02fec71b">More...</a><br /></td></tr>
<tr class="separator:a09fc5e0ce68a45bfda286a3a02fec71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a3b549fa535fa2fe4af59f57232650da0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacepvrvk.html#a3f629d1c9df2b60d79a4bde49fc969ab">CommandBufferBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a3b549fa535fa2fe4af59f57232650da0">constructShared</a> (const <a class="el" href="namespacepvrvk.html#aecbfc9aca0ecd8de47ccb6137aafcabd">DeviceWeakPtr</a> &amp;device, <a class="el" href="namespacepvrvk.html#a19e4e901387a642d912f4e8e67d541b7">CommandPool</a> &amp;pool, VkCommandBuffer myHandle)</td></tr>
<tr class="memdesc:a3b549fa535fa2fe4af59f57232650da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected function used to create a <a class="el" href="namespacepvrvk.html#a3f629d1c9df2b60d79a4bde49fc969ab" title="A CommandBuffer(Base) represents a std::string of commands that will be submitted to the GPU in a bat...">pvrvk::CommandBufferBase</a>. Note that this function shouldn't normally be called directly and will be called by a friend of <a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html" title="Contains all the commands and states that need to be recorded for later submission to the gpu includi...">CommandBufferBase_</a> which will generally be a CommandPool.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a3b549fa535fa2fe4af59f57232650da0">More...</a><br /></td></tr>
<tr class="separator:a3b549fa535fa2fe4af59f57232650da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ecea65366e5ba505ac4dd5479bed23"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacepvrvk.html#a672ec131cfc43b620333165b270a1b32">SecondaryCommandBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#ab2ecea65366e5ba505ac4dd5479bed23">constructShared</a> (const <a class="el" href="namespacepvrvk.html#aecbfc9aca0ecd8de47ccb6137aafcabd">DeviceWeakPtr</a> &amp;device, <a class="el" href="namespacepvrvk.html#a19e4e901387a642d912f4e8e67d541b7">CommandPool</a> pool, VkCommandBuffer myHandle)</td></tr>
<tr class="memdesc:ab2ecea65366e5ba505ac4dd5479bed23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected function used to create a <a class="el" href="namespacepvrvk.html#a672ec131cfc43b620333165b270a1b32" title="A SecondaryCommandBufferis a CommandBuffer that can only be submitted to a primary CommandBuffer and ...">pvrvk::SecondaryCommandBuffer</a>. Note that this function shouldn't normally be called directly and will be called by a friend of <a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html" title="Contains all the commands and states that need to be submitted to the gpu, including pipeline,...">SecondaryCommandBuffer_</a> which will generally be a CommandPool  <a href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html#ab2ecea65366e5ba505ac4dd5479bed23">More...</a><br /></td></tr>
<tr class="separator:ab2ecea65366e5ba505ac4dd5479bed23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7e34537906b05ee353451b35dac332ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#aecbfc9aca0ecd8de47ccb6137aafcabd">DeviceWeakPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html#a7e34537906b05ee353451b35dac332ca">_device</a></td></tr>
<tr class="memdesc:a7e34537906b05ee353451b35dac332ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device which was used to create this DeviceObject  <a href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html#a7e34537906b05ee353451b35dac332ca">More...</a><br /></td></tr>
<tr class="separator:a7e34537906b05ee353451b35dac332ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759e4e7ca81cb8812048075ddcf274d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a759e4e7ca81cb8812048075ddcf274d6">_isRecording</a></td></tr>
<tr class="memdesc:a759e4e7ca81cb8812048075ddcf274d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the command buffer is currently in the recording state which is controlled via calling the begin function.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#a759e4e7ca81cb8812048075ddcf274d6">More...</a><br /></td></tr>
<tr class="separator:a759e4e7ca81cb8812048075ddcf274d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fab5878ab60a1307b8185a432bc861"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ad5fab5878ab60a1307b8185a432bc861">_objectReferences</a></td></tr>
<tr class="memdesc:ad5fab5878ab60a1307b8185a432bc861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a list of references to the objects currently in use by this command buffer. This ensures that objects are kept alive through reference counting until the command buffer is finished with them.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#ad5fab5878ab60a1307b8185a432bc861">More...</a><br /></td></tr>
<tr class="separator:ad5fab5878ab60a1307b8185a432bc861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6a5283158daab0cdc032c0c6925f37"><td class="memItemLeft" align="right" valign="top">ObjectType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html#a4f6a5283158daab0cdc032c0c6925f37">_objectType</a></td></tr>
<tr class="memdesc:a4f6a5283158daab0cdc032c0c6925f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Vulkan object type.  <a href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html#a4f6a5283158daab0cdc032c0c6925f37">More...</a><br /></td></tr>
<tr class="separator:a4f6a5283158daab0cdc032c0c6925f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4cc024978587b241ae65a8541d5815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepvrvk.html#a19e4e901387a642d912f4e8e67d541b7">CommandPool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adb4cc024978587b241ae65a8541d5815">_pool</a></td></tr>
<tr class="memdesc:adb4cc024978587b241ae65a8541d5815"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command pool from which this command buffer was allocated.  <a href="classpvrvk_1_1impl_1_1_command_buffer_base__.html#adb4cc024978587b241ae65a8541d5815">More...</a><br /></td></tr>
<tr class="separator:adb4cc024978587b241ae65a8541d5815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674fbf75f66ed66d68aa03d32e6114bd"><td class="memItemLeft" align="right" valign="top">VkCommandBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html#a674fbf75f66ed66d68aa03d32e6114bd">_vkHandle</a></td></tr>
<tr class="memdesc:a674fbf75f66ed66d68aa03d32e6114bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Vulkan object handle representing the Vulkan object at an API level.  <a href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html#a674fbf75f66ed66d68aa03d32e6114bd">More...</a><br /></td></tr>
<tr class="separator:a674fbf75f66ed66d68aa03d32e6114bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. </p>
<p>Secondary command buffers cannot contain RenderPasses, and cannot be submitted to the GPU. SecondaryCommandBuffers can be submitted to the primaryCommandBuffer -It is invalid to submit commands to a command buffer while it is not being recorded. -It is invalid to reset a command buffer while it is being recorded. -It is invalid to submit a command buffer more than once if it is one time submit command buffer -Draw commands must be between a BeginRenderPass and an EndRenderPass command</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6d449edb8cf90b9c237f940f0b561a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d449edb8cf90b9c237f940f0b561a9c">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::begin </td>
          <td>(</td>
          <td class="paramtype">const CommandBufferUsageFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>CommandBufferUsageFlags(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags is a bitmask of CommandBufferUsageFlags specifying usage behavior for the command buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d449edb8cf90b9c237f940f0b561a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d449edb8cf90b9c237f940f0b561a9c">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags is a bitmask of CommandBufferUsageFlags specifying usage behavior for the command buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a574e16f7068cd5d978b627c9582ac7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574e16f7068cd5d978b627c9582ac7b9">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::SecondaryCommandBuffer_::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5ea48df1aae258ade7640f956c5941fa">Framebuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>framebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>subpass</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CommandBufferUsageFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>CommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">framebuffer</td><td>Refers to an Framebuffer object that this CommandBuffer will be rendering to if it is executed within a render pass instance.</td></tr>
    <tr><td class="paramname">subpass</td><td>The index of the subpass within the render pass instance that this CommandBuffer will be executed within.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags is a bitmask of CommandBufferUsageFlagBits specifying usage behavior for the command buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09d9e885485c1753a0b13f9ab07a78f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d9e885485c1753a0b13f9ab07a78f6">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::SecondaryCommandBuffer_::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a1f42311ecc0e570ba9d62332ff6f1f6d">RenderPass</a> &amp;&#160;</td>
          <td class="paramname"><em>renderpass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>subpass</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CommandBufferUsageFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>CommandBufferUsageFlags::e_RENDER_PASS_CONTINUE_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function before beginning to record commands. If the Framebuffer object is known, prefer the Framebuffer overload as it may offer better performance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderpass</td><td>A RenderPass object defining which render passes this SecondaryCommandBuffer will be compatible with and can be executed within.</td></tr>
    <tr><td class="paramname">subpass</td><td>The index of the subpass within the render pass instance that this CommandBuffer will be executed within.</td></tr>
    <tr><td class="paramname">flags</td><td>Flags is a bitmask of CommandBufferUsageFlagBits specifying usage behavior for the command buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45afc2b8a3f4fe54db79d82e1dc42ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45afc2b8a3f4fe54db79d82e1dc42ac6">&#9670;&nbsp;</a></span>beginDebugUtilsLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::beginDebugUtilsLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_debug_utils_label.html">pvrvk::DebugUtilsLabel</a> &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins identifying a region of work submitted to this command buffer. The calls to beginDebugUtilsLabel and endDebugUtilsLabel must be matched and balanced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to open</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a862a03340dc1812389fca32ceaffa881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862a03340dc1812389fca32ceaffa881">&#9670;&nbsp;</a></span>beginQuery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::beginQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryControlFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>QueryControlFlags(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins a query for a particular QueryPool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool which will manage the results of the query.</td></tr>
    <tr><td class="paramname">queryIndex</td><td>The query index within the QueryPool which will contain the results.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies the Query Control Flag bits which provide constraints on the type of queries that can be performed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd9c026fda6f898ed9195b8bcf7ec2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9c026fda6f898ed9195b8bcf7ec2b1">&#9670;&nbsp;</a></span>beginQueryIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::beginQueryIndexed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryControlFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>QueryControlFlags(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins a query for a particular QueryPool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool which will manage the results of the query.</td></tr>
    <tr><td class="paramname">queryIndex</td><td>The query index within the QueryPool which will contain the results.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies the Query Control Flag bits which provide constraints on the type of queries that can be performed.</td></tr>
    <tr><td class="paramname">index</td><td>The query type specific index.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57b723eecd29bfb3e5b35909d6cbb7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b723eecd29bfb3e5b35909d6cbb7af">&#9670;&nbsp;</a></span>beginTransformFeedback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::beginTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a>&#160;</td>
          <td class="paramname"><em>counterBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>counterBufferOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes active transform feedback for specific transform feedback buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counterBuffer</td><td>The handle of the buffer correspond to the counter buffer which contains a 4 byte integer value representing the byte offset from the start of the corresponding transform feedback buffer from where to start capturing vertex data.</td></tr>
    <tr><td class="paramname">counterBufferOffset</td><td>An optional offset within the counterBuffer where the counter values were previously written.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06530f4a0a7b0e10705650ca23d96b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06530f4a0a7b0e10705650ca23d96b2b">&#9670;&nbsp;</a></span>beginTransformFeedback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::beginTransformFeedback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstCounterBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numCounterBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a> *&#160;</td>
          <td class="paramname"><em>counterBuffers</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *&#160;</td>
          <td class="paramname"><em>counterBufferOffsets</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes active transform feedback for specific transform feedback buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstCounterBuffer</td><td>Index of the first transform feedback buffer.</td></tr>
    <tr><td class="paramname">numCounterBuffers</td><td>The number of buffers.</td></tr>
    <tr><td class="paramname">counterBuffers</td><td>An optional list of buffers where the handles of the buffers correspond to the counter buffers which contain a 4 byte integer value representing the byte offset from the start of the corresponding transform feedback buffer from where to start capturing vertex data.</td></tr>
    <tr><td class="paramname">counterBufferOffsets</td><td>An optional array of offsets within each of the pCounterBuffers where the counter values were previously written.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37e81e963a89f7b2b16112acb4c01d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e81e963a89f7b2b16112acb4c01d54">&#9670;&nbsp;</a></span>bindDescriptorSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindDescriptorSet </td>
          <td>(</td>
          <td class="paramtype">PipelineBindPoint&#160;</td>
          <td class="paramname"><em>bindingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a3639982454c70cc356ca557c7073c9f8">PipelineLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#aad7d79ce674b1d4114eafb17a5914133">DescriptorSet</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDynamicOffsets</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind descriptorset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td><a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> binding point</td></tr>
    <tr><td class="paramname">pipelineLayout</td><td><a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> layout</td></tr>
    <tr><td class="paramname">firstSet</td><td>The set number of the first descriptor set to be bound</td></tr>
    <tr><td class="paramname">set</td><td>Descriptor set to be bound</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>Pointer to an array of uint</td></tr>
  </table>
  </dd>
</dl>
<p>32_t values specifying dynamic offsets </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numDynamicOffsets</td><td>Number of dynamic offsets</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5d43d0aee637c66a1137e0e32d1c09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d43d0aee637c66a1137e0e32d1c09f">&#9670;&nbsp;</a></span>bindDescriptorSets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindDescriptorSets </td>
          <td>(</td>
          <td class="paramtype">PipelineBindPoint&#160;</td>
          <td class="paramname"><em>bindingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a3639982454c70cc356ca557c7073c9f8">PipelineLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#aad7d79ce674b1d4114eafb17a5914133">DescriptorSet</a> *&#160;</td>
          <td class="paramname"><em>sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDescriptorSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numDynamicOffsets</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind descriptorsets </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td><a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> binding point</td></tr>
    <tr><td class="paramname">pipelineLayout</td><td><a class="el" href="classpvrvk_1_1impl_1_1_pipeline.html" title="A Graphics Pipeline is a PVRVk adapter to a Vulkan Pipeline to a pipeline created for VK_PIPELINE_BIN...">Pipeline</a> layout</td></tr>
    <tr><td class="paramname">firstSet</td><td>The set number of the first descriptor set to be bound</td></tr>
    <tr><td class="paramname">sets</td><td>Pointer to the descriptor sets to be bound</td></tr>
    <tr><td class="paramname">numDescriptorSets</td><td>Number of descriptor sets</td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>Pointer to an array of uint</td></tr>
  </table>
  </dd>
</dl>
<p>32_t values specifying dynamic offsets </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numDynamicOffsets</td><td>Number of dynamic offsets</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa66ee757605ffa9afa68bf95ab9c7adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66ee757605ffa9afa68bf95ab9c7adf">&#9670;&nbsp;</a></span>bindIndexBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind index bufer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Imdex buffer</td></tr>
    <tr><td class="paramname">offset</td><td>Buffer offset</td></tr>
    <tr><td class="paramname">indexType</td><td>IndexType</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79d2f3d38f2aad3fa3ba4b7b793d1421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d2f3d38f2aad3fa3ba4b7b793d1421">&#9670;&nbsp;</a></span>bindPipeline() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a29a9475928347749fcf6e15f01d1ac9f">ComputePipeline</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a compute pipeline </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The ComputePipeline to bind</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfc394932317683fb0582841423527b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc394932317683fb0582841423527b2">&#9670;&nbsp;</a></span>bindPipeline() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0eb06716297c66be780d357af1d36e91">GraphicsPipeline</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a graphics pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The GraphicsPipeline to bind.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a181604abd7b574918c422a426c91a300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181604abd7b574918c422a426c91a300">&#9670;&nbsp;</a></span>bindPipeline() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#ae27af35258ddd3bb126a662c90d265b4">RaytracingPipeline</a> &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a ray tracing pipeline </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The RaytracingPipeline to bind</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a503e3d2574d33525209e5737814fe888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503e3d2574d33525209e5737814fe888">&#9670;&nbsp;</a></span>bindTransformFeedbackBuffers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindTransformFeedbackBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a transform feedback buffer to the command buffer for use in subsequent draw commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to bind the command buffer.</td></tr>
    <tr><td class="paramname">offset</td><td>A buffer offset.</td></tr>
    <tr><td class="paramname">size</td><td>An optional buffer size, which specifies the maximum number of bytes to capture to the corresponding transform feedback buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ef32304c508552915c284f6764bdd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef32304c508552915c284f6764bdd47">&#9670;&nbsp;</a></span>bindTransformFeedbackBuffers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindTransformFeedbackBuffers </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstBinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bindingCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *&#160;</td>
          <td class="paramname"><em>sizes</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binds a set of transform feedback buffers to the command buffer for use in subsequent draw commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstBinding</td><td>The index of the first transform feedback binding whose state is updated by the command.</td></tr>
    <tr><td class="paramname">bindingCount</td><td>The number of transform feedback bindings whose state is updated by the command.</td></tr>
    <tr><td class="paramname">buffers</td><td>A list of buffers to bind the command buffer.</td></tr>
    <tr><td class="paramname">offsets</td><td>Pointer to an array of buffer offsets.</td></tr>
    <tr><td class="paramname">sizes</td><td>An optional array of buffer sizes, which specifies the maximum number of bytes to capture to the corresponding transform feedback buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2853f758e9e70e100e3140405fc8e03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2853f758e9e70e100e3140405fc8e03c">&#9670;&nbsp;</a></span>bindVertexBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>startBinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>numBindings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind vertex buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Buffers to be bound</td></tr>
    <tr><td class="paramname">offsets</td><td>Pointer to an array of buffer offsets.</td></tr>
    <tr><td class="paramname">numBuffers</td><td>number of buffers</td></tr>
    <tr><td class="paramname">startBinding</td><td>The indices of the first vertex input binding whose state is updated by the command.</td></tr>
    <tr><td class="paramname">numBindings</td><td>Number of bindings</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2382fc789d3e96d50693f9e5483ff0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2382fc789d3e96d50693f9e5483ff0b0">&#9670;&nbsp;</a></span>bindVertexBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bindingIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind vertex buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer</td></tr>
    <tr><td class="paramname">offset</td><td>Buffer offset</td></tr>
    <tr><td class="paramname">bindingIndex</td><td>The index of the vertex input binding whose state is updated by the command.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40c135444b1cab09ac85b642323155cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c135444b1cab09ac85b642323155cb">&#9670;&nbsp;</a></span>bindVertexBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::bindVertexBuffers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstBinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bindingCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>offsets</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind vertex buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>A set of vertex buffers to bind</td></tr>
    <tr><td class="paramname">firstBinding</td><td>The first index into buffers</td></tr>
    <tr><td class="paramname">bindingCount</td><td>The number of vertex buffers to bind</td></tr>
    <tr><td class="paramname">offsets</td><td>A pointer to an array of bindingCount buffer offsets</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b6b3caadb988c50778a3867c229d652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6b3caadb988c50778a3867c229d652">&#9670;&nbsp;</a></span>blitImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::blitImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>dstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImageBlit *&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Filter&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>srcLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>dstLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>The src Image in the copy.</td></tr>
    <tr><td class="paramname">dstImage</td><td>The dst image.</td></tr>
    <tr><td class="paramname">regions</td><td>A pointer to an array of ImageBlitRange structures specifying the regions to blit.</td></tr>
    <tr><td class="paramname">numRegions</td><td>The number of regions to blit.</td></tr>
    <tr><td class="paramname">filter</td><td>A Filter specifying the filter to apply if the blits require scaling</td></tr>
    <tr><td class="paramname">srcLayout</td><td>The layout of the src image subresrcs for the blit.</td></tr>
    <tr><td class="paramname">dstLayout</td><td>The layout of the dst image subresrcs for the blit.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26d8498fee836c63989072eb483d8938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d8498fee836c63989072eb483d8938">&#9670;&nbsp;</a></span>clearAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearAttachment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> &amp;&#160;</td>
          <td class="paramname"><em>clearAttachment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ClearRect &amp;&#160;</td>
          <td class="paramname"><em>clearRectangle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a particular attachment using a provided region whilst inside of a renderpass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearAttachment</td><td>A single <a class="el" href="structpvrvk_1_1_clear_attachment.html" title="ClearAttachment structures defining the attachments to clear and the clear values to use....">ClearAttachment</a> structure defining the attachment to clear and the clear value to use</td></tr>
    <tr><td class="paramname">clearRectangle</td><td>A ClearRect structure defining a region within the attachment to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac681c14ddfb7b443d318e695633571b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac681c14ddfb7b443d318e695633571b5">&#9670;&nbsp;</a></span>clearAttachments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearAttachments </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numAttachments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_attachment.html">ClearAttachment</a> *&#160;</td>
          <td class="paramname"><em>clearAttachments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRectangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ClearRect *&#160;</td>
          <td class="paramname"><em>clearRectangles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a set of attacments using a number of regions for each selected attachment to clear whilst inside a renderpass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numAttachments</td><td>The number of entries in the clearAttachments array.</td></tr>
    <tr><td class="paramname">clearAttachments</td><td>Is a pointer to an array of <a class="el" href="structpvrvk_1_1_clear_attachment.html" title="ClearAttachment structures defining the attachments to clear and the clear values to use....">ClearAttachment</a> structures which defines the attachments to clear and the clear values to use.</td></tr>
    <tr><td class="paramname">numRectangles</td><td>Is the number of entries in the clearRects array.</td></tr>
    <tr><td class="paramname">clearRectangles</td><td>Points to an array of ClearRect structures defining regions within each selected attachment to clear.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1050ce0f6d621cb56b25e5ba0e862cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1050ce0f6d621cb56b25e5ba0e862cf">&#9670;&nbsp;</a></span>clearColorImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearColorImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#adc4f5e5a2423045c3197ce383a53d910">ImageView</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>currentLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a color image outside of a renderpass instance using a number of ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear.</td></tr>
    <tr><td class="paramname">clearColor</td><td>Clear color value.</td></tr>
    <tr><td class="paramname">currentLayout</td><td>Image current layout.</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>Base mip map level to clear.</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of a number of mipmap levels to clear.</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear.</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array array layers to clear.</td></tr>
    <tr><td class="paramname">numRanges</td><td>The number of elements in the baseMipLevel, numLevels, baseArrayLayers and numLayers arrays.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a5832f5365e38a33a1768baf09fc4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5832f5365e38a33a1768baf09fc4ba">&#9670;&nbsp;</a></span>clearColorImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearColorImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#adc4f5e5a2423045c3197ce383a53d910">ImageView</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_clear_color_value.html">ClearColorValue</a> &amp;&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>currentLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a color image outside of a renderpass instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearColor</td><td>Clear color value</td></tr>
    <tr><td class="paramname">currentLayout</td><td>Image current layout</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base array layer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51b58f4906588ca9dfa2438c37540c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b58f4906588ca9dfa2438c37540c30">&#9670;&nbsp;</a></span>clearDepthImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the depth image outside of a renderpass instance using a number of ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear depth value</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>A pointer to an array of base mip map levels to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of the number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array of the number of layers to clear</td></tr>
    <tr><td class="paramname">numRanges</td><td>A number of ranges of the stencil image to clear. This number will be used as the number of array elements in the arrays passed to baseMipLevels, numLevels, baseArrayLayers and numLayers</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac919e8871b7d6b2c6886562f08c5b5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac919e8871b7d6b2c6886562f08c5b5ac">&#9670;&nbsp;</a></span>clearDepthImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear depth image outside of a renderpass instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear value</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base arraylayer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
    <tr><td class="paramname">layout</td><td>Current layout of the image</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4caad1d3256751db0735dae4c4ecd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4caad1d3256751db0735dae4c4ecd14">&#9670;&nbsp;</a></span>clearDepthStencilImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthStencilImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear depth stencil image outside of a renderpass instance using a number of ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear depth value</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>A pointer to an array of base mip map levels to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of the number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array of the number of layers to clear</td></tr>
    <tr><td class="paramname">numRanges</td><td>A number of ranges of the depth stencil image to clear. This number will be used as the number of array elements in the arrays passed to baseMipLevels, numLevels, baseArrayLayers and numLayers</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc175f1965e8857291b3e61380fde0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc175f1965e8857291b3e61380fde0d1">&#9670;&nbsp;</a></span>clearDepthStencilImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearDepthStencilImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear depth stencil image outside of a renderpass instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearDepth</td><td>Clear depth value</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base array layer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7894b82302fae9d634b6564a0e912256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7894b82302fae9d634b6564a0e912256">&#9670;&nbsp;</a></span>clearStencilImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearStencilImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseMipLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>baseArrayLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear stencil image outside of a renderpass instance using a number of ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevels</td><td>A pointer to an array of base mip map levels to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>A pointer to an array of the number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayers</td><td>A pointer to an array of base array layers to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>A pointer to an array of the number of layers to clear</td></tr>
    <tr><td class="paramname">numRanges</td><td>A number of ranges of the stencil image to clear. This number will be used as the number of array elements in the arrays passed to baseMipLevels, numLevels, baseArrayLayers and numLayers</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96fcb36a78addbdf25d5f52044e37152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fcb36a78addbdf25d5f52044e37152">&#9670;&nbsp;</a></span>clearStencilImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::clearStencilImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearStencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>baseArrayLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>numLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears a stencil image outside of a renderpass instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Image to clear</td></tr>
    <tr><td class="paramname">clearStencil</td><td>Clear stencil value</td></tr>
    <tr><td class="paramname">baseMipLevel</td><td>Base mip map level to clear</td></tr>
    <tr><td class="paramname">numLevels</td><td>Number of mipmap levels to clear</td></tr>
    <tr><td class="paramname">baseArrayLayer</td><td>Base array layer to clear</td></tr>
    <tr><td class="paramname">numLayers</td><td>Number of array layers to clear</td></tr>
    <tr><td class="paramname">layout</td><td>Image current layout</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b549fa535fa2fe4af59f57232650da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b549fa535fa2fe4af59f57232650da0">&#9670;&nbsp;</a></span>constructShared() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacepvrvk.html#a3f629d1c9df2b60d79a4bde49fc969ab">CommandBufferBase</a> pvrvk::impl::CommandBufferBase_::constructShared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#aecbfc9aca0ecd8de47ccb6137aafcabd">DeviceWeakPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a19e4e901387a642d912f4e8e67d541b7">CommandPool</a> &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>myHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected function used to create a <a class="el" href="namespacepvrvk.html#a3f629d1c9df2b60d79a4bde49fc969ab" title="A CommandBuffer(Base) represents a std::string of commands that will be submitted to the GPU in a bat...">pvrvk::CommandBufferBase</a>. Note that this function shouldn't normally be called directly and will be called by a friend of <a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html" title="Contains all the commands and states that need to be recorded for later submission to the gpu includi...">CommandBufferBase_</a> which will generally be a CommandPool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device used to allocate the command buffer.</td></tr>
    <tr><td class="paramname">pool</td><td>The pool from which the command buffer will be allocated.</td></tr>
    <tr><td class="paramname">myHandle</td><td>The vulkan handle for this command buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a successfully created <a class="el" href="namespacepvrvk.html#a3f629d1c9df2b60d79a4bde49fc969ab" title="A CommandBuffer(Base) represents a std::string of commands that will be submitted to the GPU in a bat...">pvrvk::CommandBufferBase</a></dd></dl>

</div>
</div>
<a id="ab2ecea65366e5ba505ac4dd5479bed23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ecea65366e5ba505ac4dd5479bed23">&#9670;&nbsp;</a></span>constructShared() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacepvrvk.html#a672ec131cfc43b620333165b270a1b32">SecondaryCommandBuffer</a> pvrvk::impl::SecondaryCommandBuffer_::constructShared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#aecbfc9aca0ecd8de47ccb6137aafcabd">DeviceWeakPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a19e4e901387a642d912f4e8e67d541b7">CommandPool</a>&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>myHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected function used to create a <a class="el" href="namespacepvrvk.html#a672ec131cfc43b620333165b270a1b32" title="A SecondaryCommandBufferis a CommandBuffer that can only be submitted to a primary CommandBuffer and ...">pvrvk::SecondaryCommandBuffer</a>. Note that this function shouldn't normally be called directly and will be called by a friend of <a class="el" href="classpvrvk_1_1impl_1_1_secondary_command_buffer__.html" title="Contains all the commands and states that need to be submitted to the gpu, including pipeline,...">SecondaryCommandBuffer_</a> which will generally be a CommandPool </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device used to allocate the secondary command buffer.</td></tr>
    <tr><td class="paramname">pool</td><td>The pool from which the command buffer will be allocated.</td></tr>
    <tr><td class="paramname">myHandle</td><td>The vulkan handle for this command buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a successfully created <a class="el" href="namespacepvrvk.html#a672ec131cfc43b620333165b270a1b32" title="A SecondaryCommandBufferis a CommandBuffer that can only be submitted to a primary CommandBuffer and ...">pvrvk::SecondaryCommandBuffer</a></dd></dl>

</div>
</div>
<a id="a9fc6d67c3d3a47780e62c8d9632776cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc6d67c3d3a47780e62c8d9632776cb">&#9670;&nbsp;</a></span>copyBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>srcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferCopy *&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy Buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcBuffer</td><td>Source buffer</td></tr>
    <tr><td class="paramname">dstBuffer</td><td>Destination buffer</td></tr>
    <tr><td class="paramname">numRegions</td><td>Number of regions to copy</td></tr>
    <tr><td class="paramname">regions</td><td>Pointer to an array of BufferCopy structures specifying the regions to copy. Each region in pRegions is copied from the source buffer to the same region of the destination buffer. srcBuffer and dstBuffer can be the same buffer or alias the same memory, but the result is undefined if the copy regions overlap in memory.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a851659286aa0122bc8d42ec5c823604c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851659286aa0122bc8d42ec5c823604c">&#9670;&nbsp;</a></span>copyBufferToImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyBufferToImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>dstImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>regionsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferImageCopy *&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy buffer to image </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Source Buffer</td></tr>
    <tr><td class="paramname">image</td><td>Destination image</td></tr>
    <tr><td class="paramname">dstImageLayout</td><td>Destination image's current layout</td></tr>
    <tr><td class="paramname">regionsCount</td><td>Copy regions</td></tr>
    <tr><td class="paramname">regions</td><td>Number of regions</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a226df08eca4fcc10fac3976860cd70af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226df08eca4fcc10fac3976860cd70af">&#9670;&nbsp;</a></span>copyImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>dstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>srcImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>dstImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImageCopy *&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy data between Images </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>Source image</td></tr>
    <tr><td class="paramname">dstImage</td><td>Destination image</td></tr>
    <tr><td class="paramname">srcImageLayout</td><td>Source image layout</td></tr>
    <tr><td class="paramname">dstImageLayout</td><td>Destination image layout</td></tr>
    <tr><td class="paramname">regions</td><td>Regions to copy</td></tr>
    <tr><td class="paramname">numRegions</td><td>Number of regions</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8da3e72621920307892661c98f0cab01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da3e72621920307892661c98f0cab01">&#9670;&nbsp;</a></span>copyImageToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyImageToBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>srcImageLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BufferImageCopy *&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy image to buffer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>Source image to copy from</td></tr>
    <tr><td class="paramname">srcImageLayout</td><td>Current src image layout</td></tr>
    <tr><td class="paramname">dstBuffer</td><td>Destination buffer</td></tr>
    <tr><td class="paramname">regions</td><td>Regions to copy</td></tr>
    <tr><td class="paramname">numRegions</td><td>Number of regions</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7b0c98a25f798bb0af566f3f1238c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b0c98a25f798bb0af566f3f1238c3c">&#9670;&nbsp;</a></span>copyQueryPoolResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::copyQueryPoolResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QueryResultFlags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the query statuses and numerical results directly to buffer memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool which will manage the results of the query.</td></tr>
    <tr><td class="paramname">firstQuery</td><td>The first query index within the QueryPool which will contain the results.</td></tr>
    <tr><td class="paramname">queryCount</td><td>The number of queries.</td></tr>
    <tr><td class="paramname">dstBuffer</td><td>A buffer object which will receive the results of the copy command.</td></tr>
    <tr><td class="paramname">offset</td><td>An offset into dstBuffer.</td></tr>
    <tr><td class="paramname">stride</td><td>The stride in bytes between results for individual queries within dstBuffer.</td></tr>
    <tr><td class="paramname">flags</td><td>Specifies how and when the results are returned.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a30a9993a36579194e6c7f73b107a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a30a9993a36579194e6c7f73b107a8e">&#9670;&nbsp;</a></span>debugMarkerBeginEXT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::debugMarkerBeginEXT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpvrvk_1_1_debug_marker_marker_info.html">pvrvk::DebugMarkerMarkerInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>markerInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begins a debug marked region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markerInfo</td><td>Specifies the creation info for a marked region.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a029a7feee509f14715a509ef1de45b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029a7feee509f14715a509ef1de45b26">&#9670;&nbsp;</a></span>debugMarkerEndEXT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::debugMarkerEndEXT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a debug marked region. </p>

</div>
</div>
<a id="a61c72a73a8da59ae5356a6c8c30ba310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c72a73a8da59ae5356a6c8c30ba310">&#9670;&nbsp;</a></span>debugMarkerInsertEXT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::debugMarkerInsertEXT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpvrvk_1_1_debug_marker_marker_info.html">pvrvk::DebugMarkerMarkerInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>markerInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a debug marker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">markerInfo</td><td>Specifies creation info for the marker.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96aeb9ef8d82603dfeac45d2ff177ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96aeb9ef8d82603dfeac45d2ff177ba2">&#9670;&nbsp;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::dispatch </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numGroupX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numGroupY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numGroupZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numGroupX</td><td>The number of local workgroups to dispatch in the X dimension.</td></tr>
    <tr><td class="paramname">numGroupY</td><td>The number of local workgroups to dispatch in the Y dimension.</td></tr>
    <tr><td class="paramname">numGroupZ</td><td>The number of local workgroups to dispatch in the Z dimension.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb78b08d16568eeb47ffed3294d3f6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb78b08d16568eeb47ffed3294d3f6e2">&#9670;&nbsp;</a></span>dispatchIndirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::dispatchIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatching work provokes work in a compute pipeline. A compute pipeline must be bound to the command buffer before any dispatch commands are recorded. dispatchIndirect behaves similarly to dispatch except that the parameters are read by the device from a buffer during execution. The parameters of the dispatch are encoded in a DispatchIndirectCommand structure taken from buffer starting at offset </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing dispatch parameters.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into buffer where parameters begin.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a38f7566ddeb086f6aa546ee3311288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a38f7566ddeb086f6aa546ee3311288">&#9670;&nbsp;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::draw </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numInstances</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-indexed drawing command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstVertex</td><td>The index of the first vertex to draw.</td></tr>
    <tr><td class="paramname">numVertices</td><td>The number of vertices to draw.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The instance ID of the first instance to draw.</td></tr>
    <tr><td class="paramname">numInstances</td><td>The number of instances to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85499f2c0908567eb04903dc51b2c9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85499f2c0908567eb04903dc51b2c9da">&#9670;&nbsp;</a></span>drawIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::drawIndexed </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>vertexOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numInstances</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indexed drawing command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstIndex</td><td>The base index within the index buffer.</td></tr>
    <tr><td class="paramname">numIndices</td><td>The number of vertices to draw.</td></tr>
    <tr><td class="paramname">vertexOffset</td><td>The value added to the vertex index before indexining into the vertex buffer.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The instance ID of the first instance to draw.</td></tr>
    <tr><td class="paramname">numInstances</td><td>The number of instances to draw.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58c8d29b0470bcc6df46f83032408db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c8d29b0470bcc6df46f83032408db1">&#9670;&nbsp;</a></span>drawIndexedIndirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::drawIndexedIndirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-indexed indirect drawing command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing draw parameters.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into buffer where parameters begin.</td></tr>
    <tr><td class="paramname">count</td><td>The number of draws to execute.</td></tr>
    <tr><td class="paramname">stride</td><td>The byte stride between successive sets of draw commands.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ea627c5ef086a05ac210a4a4b3287ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea627c5ef086a05ac210a4a4b3287ea">&#9670;&nbsp;</a></span>drawIndirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::drawIndirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-indexed indirect drawing command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing draw parameters.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into buffer where parameters begin.</td></tr>
    <tr><td class="paramname">count</td><td>The number of draws to execute.</td></tr>
    <tr><td class="paramname">stride</td><td>The byte stride between successive sets of draw commands.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65d898c93ffd584464a0f079b7df6785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d898c93ffd584464a0f079b7df6785">&#9670;&nbsp;</a></span>drawIndirectByteCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::drawIndirectByteCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instanceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a>&#160;</td>
          <td class="paramname"><em>counterBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>counterBufferOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counterOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>vertexStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Records a non-indexed draw call, where the vertex count is based on a byte count read from a buffer and the passed in vertex stride parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instanceCount</td><td>The number of instances to draw.</td></tr>
    <tr><td class="paramname">firstInstance</td><td>The instance ID of the first instance to draw.</td></tr>
    <tr><td class="paramname">counterBuffer</td><td>The buffer handle from where the byte count is read.</td></tr>
    <tr><td class="paramname">counterBufferOffset</td><td>The offset into the buffer used to read the byte count, which is used to calculate the vertex count for this draw call.</td></tr>
    <tr><td class="paramname">counterOffset</td><td>Is subtracted from the byte count read from the counterBuffer at the counterBufferOffset.</td></tr>
    <tr><td class="paramname">vertexStride</td><td>The stride in bytes between each element of the vertex data that is used to calculate the vertex count from the counter value</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a571250974bf01a908011ca732dbb74d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571250974bf01a908011ca732dbb74d7">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this function when you are done recording commands. BeginRecording must be called first. </p>

</div>
</div>
<a id="a5041db8fba30b3e7711c66bff1841677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5041db8fba30b3e7711c66bff1841677">&#9670;&nbsp;</a></span>endDebugUtilsLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::endDebugUtilsLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a label region of work submitted to this command buffer. </p>

</div>
</div>
<a id="ac1bc81278e124ac66d23eac1fe2dc6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1bc81278e124ac66d23eac1fe2dc6cd">&#9670;&nbsp;</a></span>endQuery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::endQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a query for a particular QueryPool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool which will manage the results of the query.</td></tr>
    <tr><td class="paramname">queryIndex</td><td>The query index within the QueryPool which will contain the results.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87bef572ff59b8feb48ac11cc853931b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bef572ff59b8feb48ac11cc853931b">&#9670;&nbsp;</a></span>endQueryIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::endQueryIndexed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends a query for a particular QueryPool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool which will manage the results of the query.</td></tr>
    <tr><td class="paramname">queryIndex</td><td>The query index within the QueryPool which will contain the results.</td></tr>
    <tr><td class="paramname">index</td><td>The query type specific index.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27ad56f9817502bade39faeb9bd5e53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ad56f9817502bade39faeb9bd5e53a">&#9670;&nbsp;</a></span>endTransformFeedback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::endTransformFeedback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a>&#160;</td>
          <td class="paramname"><em>counterBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize&#160;</td>
          <td class="paramname"><em>counterBufferOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes inactive transform feedback for specific transform feedback buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counterBuffer</td><td>The handle of the buffer correspond to the counter buffer which contains a 4 byte integer value representing the byte offset from the start of the corresponding transform feedback buffer from where to start capturing vertex data.</td></tr>
    <tr><td class="paramname">counterBufferOffset</td><td>An optional offset within the counterBuffer where the counter values were previously written.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd32218e444b8b78a272b0db5c7b5ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd32218e444b8b78a272b0db5c7b5ca4">&#9670;&nbsp;</a></span>endTransformFeedback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::endTransformFeedback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstCounterBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numCounterBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">pvrvk::Buffer</a> *&#160;</td>
          <td class="paramname"><em>counterBuffers</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize *&#160;</td>
          <td class="paramname"><em>counterBufferOffsets</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes inactive transform feedback for specific transform feedback buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstCounterBuffer</td><td>Index of the first transform feedback buffer.</td></tr>
    <tr><td class="paramname">numCounterBuffers</td><td>The number of buffers.</td></tr>
    <tr><td class="paramname">counterBuffers</td><td>An optional list of buffers where the handles of the buffers correspond to the counter buffers which contain a 4 byte integer value representing the byte offset from the start of the corresponding transform feedback buffer from where to start capturing vertex data.</td></tr>
    <tr><td class="paramname">counterBufferOffsets</td><td>An optional array of offsets within each of the pCounterBuffers where the counter values were previously written.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9e4d36d3a03784aa145a257affc24c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e4d36d3a03784aa145a257affc24c3">&#9670;&nbsp;</a></span>fillBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::fillBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>dstBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dstOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>VK_WHOLE_SIZE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear buffer data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstBuffer</td><td>Destination buffer to be filled</td></tr>
    <tr><td class="paramname">dstOffset</td><td>The byte offset into the buffer at which to start filling.</td></tr>
    <tr><td class="paramname">data</td><td>A 4-byte word written repeatedly to the buffer to fill size bytes of data. The data word is written to memory according to the host endianness.</td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to fill, and must be either a multiple of 4, or VK_WHOLE_SIZE to fill the range from offset to the end of the buffer</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef1d41731998110bc7216fc79aca7e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1d41731998110bc7216fc79aca7e85">&#9670;&nbsp;</a></span>getCommandPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepvrvk.html#a19e4e901387a642d912f4e8e67d541b7">CommandPool</a> pvrvk::impl::CommandBufferBase_::getCommandPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const getter for the command pool used to allocate this command buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The command pool used to allocate this command buffer.</dd></dl>

</div>
</div>
<a id="a5fac1d61fb53bcce751d3386d97a41d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fac1d61fb53bcce751d3386d97a41d1">&#9670;&nbsp;</a></span>getDevice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a48baa2a10fcb9f1bafd42e398fdbce61">Device</a> <a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html">pvrvk::impl::PVRVkDeviceObjectBase</a>&lt; VkCommandBuffer , PVRVkObjectType &gt;::getDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Device </p>
<dl class="section return"><dt>Returns</dt><dd>DeviceWeakPtr</dd></dl>

</div>
</div>
<a id="ac8d29595868d7f06527e3d8fd0e72f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d29595868d7f06527e3d8fd0e72f92">&#9670;&nbsp;</a></span>getDevice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepvrvk.html#a48baa2a10fcb9f1bafd42e398fdbce61">Device</a> <a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html">pvrvk::impl::PVRVkDeviceObjectBase</a>&lt; VkCommandBuffer , PVRVkObjectType &gt;::getDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Device (const) </p>
<dl class="section return"><dt>Returns</dt><dd>DeviceWeakPtr</dd></dl>

</div>
</div>
<a id="a0a50f281b09625367de97d0b9d6b863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a50f281b09625367de97d0b9d6b863f">&#9670;&nbsp;</a></span>getObjectName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; <a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html">pvrvk::impl::DeviceObjectDebugUtils</a>&lt; <a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html">CommandBufferBase_</a>  &gt;::getObjectName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the Debug Marker name. </p>
<dl class="section return"><dt>Returns</dt><dd>The object name</dd></dl>

</div>
</div>
<a id="a0dd5073b84650d52de16ab11d80d9b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd5073b84650d52de16ab11d80d9b88">&#9670;&nbsp;</a></span>getObjectType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType <a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html">pvrvk::impl::PVRVkObjectBase</a>&lt; VkCommandBuffer , PVRVkObjectType &gt;::getObjectType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the specified object's type. </p>
<dl class="section return"><dt>Returns</dt><dd>The object type</dd></dl>

</div>
</div>
<a id="a9d2e6d460c18fca2adf251043c672bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2e6d460c18fca2adf251043c672bcc">&#9670;&nbsp;</a></span>getVkHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VkCommandBuffer &amp; <a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html">pvrvk::impl::PVRVkObjectBase</a>&lt; VkCommandBuffer , PVRVkObjectType &gt;::getVkHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get vulkan object (const) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the templated 'HandleType'</dd></dl>

</div>
</div>
<a id="a5dd58139997afe65b294d34815ee9dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd58139997afe65b294d34815ee9dbd">&#9670;&nbsp;</a></span>insertDebugUtilsLabel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::insertDebugUtilsLabel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_debug_utils_label.html">pvrvk::DebugUtilsLabel</a> &amp;&#160;</td>
          <td class="paramname"><em>labelInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a single debug label any time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">labelInfo</td><td>Specifies the parameters of the label region to insert</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f32e4b0b8899d01ff783456befcb5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f32e4b0b8899d01ff783456befcb5b9">&#9670;&nbsp;</a></span>isRecording()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::CommandBufferBase_::isRecording </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries if a command buffer is in the recording state </p>
<dl class="section return"><dt>Returns</dt><dd>True if recording, false otherwise</dd></dl>

</div>
</div>
<a id="a7f27bf1f81f790997dca75aa747ddaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f27bf1f81f790997dca75aa747ddaf2">&#9670;&nbsp;</a></span>pipelineBarrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::pipelineBarrier </td>
          <td>(</td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependencyByRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcStage</td><td>A bitmask of PipelineStageFlags specifying the src stage mask.</td></tr>
    <tr><td class="paramname">dstStage</td><td>A bitmask of PipelineStageFlags specifying the dst stage mask.</td></tr>
    <tr><td class="paramname">barriers</td><td>A set of memory barriers to be used in the pipeline barrier.</td></tr>
    <tr><td class="paramname">dependencyByRegion</td><td>A Specifes whether the dependencies in terms of how the execution and memory dependencies are formed.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a723ace2575665407b309eb3a397c180d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723ace2575665407b309eb3a397c180d">&#9670;&nbsp;</a></span>pushConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::pushConstants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a3639982454c70cc356ca557c7073c9f8">PipelineLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ShaderStageFlags&#160;</td>
          <td class="paramname"><em>stageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the value of shader push constants at the offset specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineLayout</td><td>The pipeline layout used to program the push constant updates.</td></tr>
    <tr><td class="paramname">stageFlags</td><td>A bitmask of ShaderStageFlag specifying the shader stages that will use the push constants in the updated range.</td></tr>
    <tr><td class="paramname">offset</td><td>The start offset of the push constant range to update, in units of bytes.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the push constant range to update, in units of bytes.</td></tr>
    <tr><td class="paramname">data</td><td>An array of size bytes containing the new push constant values.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4cea12c65ab4bbd82d0916a47e44437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4cea12c65ab4bbd82d0916a47e44437">&#9670;&nbsp;</a></span>resetEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::resetEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a635ac03f2c72ca7a64ecb846d10ca140">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>pipelineStageFlags</em> = <code>PipelineStageFlags::e_ALL_COMMANDS_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines an execution dependency on commands that were submitted before it, and defines an event unsignal operation which resets the event to the unsignaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event object that will be unsignaled.</td></tr>
    <tr><td class="paramname">pipelineStageFlags</td><td>Is a bitmask of PipelineStageFlags specifying the src stage mask used to determine when the event is unsignaled.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac34022a1a96759902c41c68a33264576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34022a1a96759902c41c68a33264576">&#9670;&nbsp;</a></span>resetObjectName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html">pvrvk::impl::DeviceObjectDebugUtils</a>&lt; <a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html">CommandBufferBase_</a>  &gt;::resetObjectName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the name of a specified object using the extension VK_EXT_debug_marker or VK_EXT_debug_utils. </p>

</div>
</div>
<a id="a7d37c209b0ef644c8f069a70be5bf156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d37c209b0ef644c8f069a70be5bf156">&#9670;&nbsp;</a></span>resetQueryPool() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::resetQueryPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a particular range of queries for a particular QueryPool and sets their status' to unavailable which also makes their numerical results undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool managing the queries being reset.</td></tr>
    <tr><td class="paramname">firstQuery</td><td>The first query index to reset.</td></tr>
    <tr><td class="paramname">queryCount</td><td>The number of queries to reset.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8148425c603008468c0a25e84c486b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8148425c603008468c0a25e84c486b1d">&#9670;&nbsp;</a></span>resetQueryPool() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::resetQueryPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a particular range of queries for a particular QueryPool and sets their status' to unavailable which also makes their numerical results undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool managing the queries being reset.</td></tr>
    <tr><td class="paramname">queryIndex</td><td>The query to reset.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7934a30102546d42737ea88999eb3e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7934a30102546d42737ea88999eb3e16">&#9670;&nbsp;</a></span>resolveImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::resolveImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>srcImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a5e7f46cb10bc00fb2407525312b4116b">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>dstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImageResolve *&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>srcLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageLayout&#160;</td>
          <td class="paramname"><em>dstLayout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies regions of a src image into a dst image, potentially also performing format conversions, aritrary scaling and filtering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcImage</td><td>The src Image in the copy.</td></tr>
    <tr><td class="paramname">dstImage</td><td>The dst image.</td></tr>
    <tr><td class="paramname">regions</td><td>A pointer to an array of ImageBlitRange structures specifying the regions to blit.</td></tr>
    <tr><td class="paramname">numRegions</td><td>The number of regions to blit.</td></tr>
    <tr><td class="paramname">srcLayout</td><td>The layout of the src image subresrcs for the blit.</td></tr>
    <tr><td class="paramname">dstLayout</td><td>The layout of the dst image subresrcs for the blit.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ce2c215aa9814e5e8aa02f679f9fa24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce2c215aa9814e5e8aa02f679f9fa24">&#9670;&nbsp;</a></span>setBlendConstants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setBlendConstants </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rgba</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic blend constant bias state affecting pipeline objects created with VK_DYNAMIC_STATE_BLEND_CONSTANTS enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgba</td><td>An array of four values specifying the R, G, B, and A components of the blend constant color used in blending, depending on the blend factor</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486a9d46e8f693398db0dc03fede5fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486a9d46e8f693398db0dc03fede5fb6">&#9670;&nbsp;</a></span>setDepthBias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setDepthBias </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>constantFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>slopeFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic depth bias state affecting pipeline objects created where depthBiasEnable is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constantFactor</td><td>A scalar factor controlling the constant depth value added to each fragment.</td></tr>
    <tr><td class="paramname">clamp</td><td>The maximum (or minimum) depth bias of a fragment.</td></tr>
    <tr><td class="paramname">slopeFactor</td><td>A scalar factor applied to a fragment's slope in depth bias calculations.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae41e1a87d69f9f3476ea6e20037b9b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41e1a87d69f9f3476ea6e20037b9b00">&#9670;&nbsp;</a></span>setDepthBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setDepthBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic depth bounds state affecting pipeline objects created with VK_DYNAMIC_STATE_DEPTH_BOUNDS enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The lower bound of the range of depth values used in the depth bounds test.</td></tr>
    <tr><td class="paramname">max</td><td>The upper bound of the range.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2c47766d3ed0ef1aa2dc0ea6819162c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c47766d3ed0ef1aa2dc0ea6819162c">&#9670;&nbsp;</a></span>setEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a635ac03f2c72ca7a64ecb846d10ca140">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>pipelineStageFlags</em> = <code>PipelineStageFlags::e_ALL_COMMANDS_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines an execution dependency on commands that were submitted before it, and defines an event signal operation which sets the event to the signaled state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event object that will be signaled.</td></tr>
    <tr><td class="paramname">pipelineStageFlags</td><td>Specifies the src stage mask used to determine when the event is signaled.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e36ba62ffb95e3a6fd71aa415542391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e36ba62ffb95e3a6fd71aa415542391">&#9670;&nbsp;</a></span>setLineWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setLineWidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic line width state affecting pipeline objects created with VK_DYNAMIC_STATE_LINE_WIDTH enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lineWidth</td><td>The width of rasterized line segments.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93cc55657dbc15c87bc158960f5ececd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cc55657dbc15c87bc158960f5ececd">&#9670;&nbsp;</a></span>setObjectName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html">pvrvk::impl::DeviceObjectDebugUtils</a>&lt; <a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html">CommandBufferBase_</a>  &gt;::setObjectName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objectName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes use of the extension VK_EXT_debug_marker or VK_EXT_debug_utils to provide a name for a specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectName</td><td>The name to use for the object</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f3e93927c6dfb8e82ef548282462f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3e93927c6dfb8e82ef548282462f03">&#9670;&nbsp;</a></span>setObjectTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpvrvk_1_1impl_1_1_device_object_debug_utils.html">pvrvk::impl::DeviceObjectDebugUtils</a>&lt; <a class="el" href="classpvrvk_1_1impl_1_1_command_buffer_base__.html">CommandBufferBase_</a>  &gt;::setObjectTag </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tagSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes use of the extension VK_EXT_debug_marker or VK_EXT_debug_utils to provide a tag for a specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>A numerical identifier of the tag for the object</td></tr>
    <tr><td class="paramname">tagSize</td><td>The number of bytes of data to attach to the object.</td></tr>
    <tr><td class="paramname">tag</td><td>An array of tagSize bytes containing the data to be associated with the object.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ee4dbcda7a265e6b5898a1a9d052d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ee4dbcda7a265e6b5898a1a9d052d2">&#9670;&nbsp;</a></span>setScissor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setScissor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>firstScissor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numScissors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rect2D *&#160;</td>
          <td class="paramname"><em>scissors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic scissor state affecting pipeline objects created with VK_DYNAMIC_STATE_SCISSOR enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstScissor</td><td>The index of the first scissor whose state is updated.</td></tr>
    <tr><td class="paramname">numScissors</td><td>The number of scissors whose rectangles are updated.</td></tr>
    <tr><td class="paramname">scissors</td><td>A pointer to an array of Rect2Di structures defining scissor rectangles.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acef9f36e3f5383594c1f561fa800aff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef9f36e3f5383594c1f561fa800aff7">&#9670;&nbsp;</a></span>setStencilCompareMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setStencilCompareMask </td>
          <td>(</td>
          <td class="paramtype">StencilFaceFlags&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compareMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic stencil compare mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A bitmask of StencilFaceFlags specifying the set of stencil state for which to update the compare mask.</td></tr>
    <tr><td class="paramname">compareMask</td><td>The new value to use as the stencil compare value.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc42ff2f511f268d68d0901b6281326d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc42ff2f511f268d68d0901b6281326d">&#9670;&nbsp;</a></span>setStencilReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setStencilReference </td>
          <td>(</td>
          <td class="paramtype">StencilFaceFlags&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic stencil reference mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_REFERENCE enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A bitmask of StencilFaceFlags specifying the set of stencil state for which to update the reference value.</td></tr>
    <tr><td class="paramname">reference</td><td>The new value to use as the stencil reference value.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3837e03b54149248c01087d7f77dd9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3837e03b54149248c01087d7f77dd9f8">&#9670;&nbsp;</a></span>setStencilWriteMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setStencilWriteMask </td>
          <td>(</td>
          <td class="paramtype">StencilFaceFlags&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>writeMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the dynamic stencil write mask state affecting pipeline objects created with VK_DYNAMIC_STATE_STENCIL_WRITE_MASK enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>A bitmask of StencilFaceFlags specifying the set of stencil state for which to update the write mask.</td></tr>
    <tr><td class="paramname">writeMask</td><td>The new value to use as the stencil write mask</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b850bccfeda750ecb9e2c98c8c2b018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b850bccfeda750ecb9e2c98c8c2b018">&#9670;&nbsp;</a></span>setViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::setViewport </td>
          <td>(</td>
          <td class="paramtype">const Viewport &amp;&#160;</td>
          <td class="paramname"><em>viewport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set viewport </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>Viewport</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdff785ab2013d7b2ff4c05f2f5e21af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdff785ab2013d7b2ff4c05f2f5e21af">&#9670;&nbsp;</a></span>updateBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::updateBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a0d42651ec741fa52e4c303d4f1026fd3">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates buffer data inline in a command buffer. The update is only allowed outside of a renderpass and is treated as a transfer operation for the purposes of syncrhonization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to be updated.</td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the src data for the buffer update. The data must be at least length bytes in size.</td></tr>
    <tr><td class="paramname">offset</td><td>The byte offset into the buffer to start updating, and must be a multiple of 4.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to update, and must be a multiple of 4.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff7cfaed7300edd34cd1de176278e516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7cfaed7300edd34cd1de176278e516">&#9670;&nbsp;</a></span>waitForEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::waitForEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a635ac03f2c72ca7a64ecb846d10ca140">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a memory dependency between prior event signal operations and subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event object to wait on.</td></tr>
    <tr><td class="paramname">srcStage</td><td>A bitmask of PipelineStageFlags specifying the src stage mask.</td></tr>
    <tr><td class="paramname">dstStage</td><td>A bitmask of PipelineStageFlags specifying the dst stage mask.</td></tr>
    <tr><td class="paramname">barriers</td><td>A set of memory barriers to be used in the pipeline barrier.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b7063f61ca8234126f81ec9625153e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7063f61ca8234126f81ec9625153e7">&#9670;&nbsp;</a></span>waitForEvents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::waitForEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvrvk.html#a635ac03f2c72ca7a64ecb846d10ca140">Event</a> *&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpvrvk_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a set of memory dependencies between prior event signal operations and subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>A pointer to an array of Event objects to wait on.</td></tr>
    <tr><td class="paramname">numEvents</td><td>The number of event objects to wait on.</td></tr>
    <tr><td class="paramname">srcStage</td><td>A bitmask of PipelineStageFlags specifying the src stage mask.</td></tr>
    <tr><td class="paramname">dstStage</td><td>A bitmask of PipelineStageFlags specifying the dst stage mask.</td></tr>
    <tr><td class="paramname">barriers</td><td>A set of .</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09fc5e0ce68a45bfda286a3a02fec71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fc5e0ce68a45bfda286a3a02fec71b">&#9670;&nbsp;</a></span>writeTimestamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvrvk::impl::CommandBufferBase_::writeTimestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvrvk.html#a20957638e6289593ae1a758c22818d18">QueryPool</a> &amp;&#160;</td>
          <td class="paramname"><em>queryPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>queryIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PipelineStageFlags&#160;</td>
          <td class="paramname"><em>pipelineStage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Requests a timestamp for a particular QueryPool to be written to the query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queryPool</td><td>Specifies the query pool which will manage the results of the query.</td></tr>
    <tr><td class="paramname">queryIndex</td><td>The query index within the QueryPool which will contain the results.</td></tr>
    <tr><td class="paramname">pipelineStage</td><td>Specifies the stage of the pipeline to write a timestamp for.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7e34537906b05ee353451b35dac332ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e34537906b05ee353451b35dac332ca">&#9670;&nbsp;</a></span>_device</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#aecbfc9aca0ecd8de47ccb6137aafcabd">DeviceWeakPtr</a> <a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_device_object_base.html">pvrvk::impl::PVRVkDeviceObjectBase</a>&lt; VkCommandBuffer , PVRVkObjectType &gt;::_device</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The device which was used to create this DeviceObject </p>

</div>
</div>
<a id="a759e4e7ca81cb8812048075ddcf274d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759e4e7ca81cb8812048075ddcf274d6">&#9670;&nbsp;</a></span>_isRecording</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvrvk::impl::CommandBufferBase_::_isRecording</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether the command buffer is currently in the recording state which is controlled via calling the begin function. </p>

</div>
</div>
<a id="ad5fab5878ab60a1307b8185a432bc861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fab5878ab60a1307b8185a432bc861">&#9670;&nbsp;</a></span>_objectReferences</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;void&gt; &gt; pvrvk::impl::CommandBufferBase_::_objectReferences</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Holds a list of references to the objects currently in use by this command buffer. This ensures that objects are kept alive through reference counting until the command buffer is finished with them. </p>

</div>
</div>
<a id="a4f6a5283158daab0cdc032c0c6925f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6a5283158daab0cdc032c0c6925f37">&#9670;&nbsp;</a></span>_objectType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType <a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html">pvrvk::impl::PVRVkObjectBase</a>&lt; VkCommandBuffer , PVRVkObjectType &gt;::_objectType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Vulkan object type. </p>

</div>
</div>
<a id="adb4cc024978587b241ae65a8541d5815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4cc024978587b241ae65a8541d5815">&#9670;&nbsp;</a></span>_pool</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacepvrvk.html#a19e4e901387a642d912f4e8e67d541b7">CommandPool</a> pvrvk::impl::CommandBufferBase_::_pool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The command pool from which this command buffer was allocated. </p>

</div>
</div>
<a id="a674fbf75f66ed66d68aa03d32e6114bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674fbf75f66ed66d68aa03d32e6114bd">&#9670;&nbsp;</a></span>_vkHandle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandBuffer  <a class="el" href="classpvrvk_1_1impl_1_1_p_v_r_vk_object_base.html">pvrvk::impl::PVRVkObjectBase</a>&lt; VkCommandBuffer , PVRVkObjectType &gt;::_vkHandle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Vulkan object handle representing the Vulkan object at an API level. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/usr/buildxl/buildroot/sdk/branch/SDK/framework/PVRVk/<a class="el" href="_command_buffer_vk_8h_source.html">CommandBufferVk.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="20%" height="20%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
